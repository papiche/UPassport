<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Nostrify Modal - NOSTR Music Mixxxer</title>
    
    <!-- Bootstrap 5 CSS -->
    <link href="{{ myIPFS }}/ipns/copylaradio.com/bootstrap.min.css" rel="stylesheet">
    <!-- Bootstrap Icons -->
    <link rel="stylesheet" href="{{ myIPFS }}/ipns/copylaradio.com/fonts/bootstrap-icons.css">
        
    <!-- Nostr integration -->
    <script src="{{ myIPFS }}/ipns/copylaradio.com/nostr.bundle.js"></script>
    <!-- Common.js with NOSTR functions -->
    <script src="{{ myIPFS }}/ipns/copylaradio.com/common.js"></script>
    <!-- Nostrify enhancements -->
    <script src="{{ myIPFS }}/ipns/copylaradio.com/nostrify.enhancements.js"></script>
    <link rel="stylesheet" href="{{ myIPFS }}/ipns/copylaradio.com/nostrify.enhancements.css" />
    
    <!-- Bootstrap 5 JS Bundle -->
    <script src="{{ myIPFS }}/ipns/copylaradio.com/bootstrap.bundle.min.js"></script>
    <style>
        * {
            box-sizing: border-box;
        }
        
        html, body {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            font-family: 'Roboto', 'Arial', sans-serif;
            background: #000000;
            color: #ffffff;
        }

        /* MP3 Modal - full screen with CSS Grid */
        .mp3-modal {
            width: 100vw !important;
            height: 100vh !important;
            display: grid !important;
            grid-template-rows: 60px calc(100vh - 60px) !important;
            grid-template-columns: 1fr !important;
            background: #000000 !important;
            overflow: hidden !important;
            position: fixed !important;
            top: 0 !important;
            left: 0 !important;
            z-index: 10000 !important;
        }
        
        /* Header bar - fixed height */
        .mp3-header {
            grid-row: 1;
            grid-column: 1;
            background: #181818;
            border-bottom: 1px solid #3f3f3f;
            padding: 12px 20px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 16px;
            height: 60px;
        }
        
        .mp3-header h5 {
            margin: 0;
            font-size: 16px;
            font-weight: 500;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
            flex: 1;
            max-width: 60%;
        }
        
        /* Main content area - CSS Grid: Audio player left, Comments & Links right */
        .mp3-content-grid {
            grid-row: 2 !important;
            grid-column: 1 !important;
            display: grid !important;
            grid-template-columns: 1fr 400px !important; /* Fixed width for right panel on desktop */
            height: calc(100vh - 60px) !important;
            gap: 0 !important;
            overflow: hidden !important;
        }
        
        /* Audio player container (left side, full height) */
        .mp3-audio-container {
            grid-column: 1 !important;
            grid-row: 1 !important;
            background: #000000 !important;
            display: flex !important;
            flex-direction: column !important;
            overflow: hidden !important;
            position: relative !important;
        }
        
        /* Audio player wrapper with album art */
        .mp3-audio-wrapper {
            flex: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            min-height: 0;
            background: linear-gradient(135deg, #1a1a1a 0%, #0f0f0f 100%);
            position: relative;
        }

        .mp3-album-art {
            width: 100%;
            max-width: 500px;
            max-height: 500px;
            aspect-ratio: 1;
            object-fit: cover;
            border-radius: 12px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5);
            margin: 20px;
        }

        .mp3-album-art-placeholder {
            width: 100%;
            max-width: 500px;
            max-height: 500px;
            aspect-ratio: 1;
            background: linear-gradient(135deg, #1db954 0%, #1ed760 100%);
            border-radius: 12px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 120px;
            color: rgba(255, 255, 255, 0.3);
            margin: 20px;
        }

        /* Audio player element */
        .mp3-audio-player {
            width: 100%;
            max-width: 600px;
            margin: 0 auto;
            padding: 20px;
        }
        
        /* Track info section (below audio player) */
        .mp3-track-info {
            flex-shrink: 0;
            padding: 16px 20px;
            background: #181818;
            border-top: 1px solid #3f3f3f;
            overflow-y: auto;
            max-height: 35%;
        }
        
        .mp3-track-info::-webkit-scrollbar {
            width: 6px;
        }
        
        .mp3-track-info::-webkit-scrollbar-track {
            background: #0f0f0f;
        }
        
        .mp3-track-info::-webkit-scrollbar-thumb {
            background: #3f3f3f;
            border-radius: 3px;
        }
        
        .mp3-track-info h6 {
            margin: 0 0 8px 0;
            font-size: 14px;
        }
        
        /* Right panel: Comments & Related Tracks */
        .mp3-right-panel {
            grid-column: 2 !important;
            grid-row: 1 !important;
            display: flex !important;
            flex-direction: column !important;
            overflow: hidden !important;
            background: #0f0f0f !important;
            border-left: 1px solid #3f3f3f !important;
        }

        /* Tabs for Comments and Related Tracks */
        .mp3-tabs {
            flex-shrink: 0;
            display: flex;
            background: #181818;
            border-bottom: 1px solid #3f3f3f;
        }

        .mp3-tab {
            flex: 1;
            padding: 12px 16px;
            background: transparent;
            border: none;
            color: #b3b3b3;
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
            transition: all 0.2s;
            border-bottom: 2px solid transparent;
        }

        .mp3-tab.active {
            color: #ffffff;
            border-bottom-color: #1db954;
            background: #0f0f0f;
        }

        .mp3-tab:hover {
            color: #ffffff;
            background: #1a1a1a;
        }

        /* Comments section */
        .mp3-comments-section {
            flex: 1;
            display: flex;
            flex-direction: column;
            overflow: hidden;
            display: none;
        }

        .mp3-comments-section.active {
            display: flex;
        }

        .mp3-comments-header {
            flex-shrink: 0;
            padding: 16px;
            border-bottom: 1px solid #3f3f3f;
            background: #181818;
        }
        
        .mp3-comments-header h6 {
            margin: 0 0 8px 0;
            font-size: 14px;
            font-weight: 600;
        }
        
        .mp3-comments-form {
            flex-shrink: 0;
            padding: 16px;
            border-bottom: 1px solid #3f3f3f;
            background: #0f0f0f;
        }
        
        .mp3-comments-list {
            flex: 1;
            overflow-y: auto;
            overflow-x: hidden;
            padding: 16px;
            min-height: 0;
        }
        
        .mp3-comments-list::-webkit-scrollbar {
            width: 8px;
        }
        
        .mp3-comments-list::-webkit-scrollbar-track {
            background: #0f0f0f;
        }
        
        .mp3-comments-list::-webkit-scrollbar-thumb {
            background: #3f3f3f;
            border-radius: 4px;
        }

        /* Mixxx Mode section */
        .mp3-mixxx-section {
            flex: 1;
            display: flex;
            flex-direction: column;
            overflow: hidden;
            display: none;
        }

        .mp3-mixxx-section.active {
            display: flex;
        }

        .mp3-mixxx-header {
            flex-shrink: 0;
            padding: 16px;
            border-bottom: 1px solid #3f3f3f;
            background: #181818;
        }

        .mp3-mixxx-users {
            flex-shrink: 0;
            padding: 16px;
            border-bottom: 1px solid #3f3f3f;
            background: #0f0f0f;
        }

        .mp3-mixxx-users-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 12px;
        }

        .mp3-mixxx-users-list {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
        }

        .mp3-mixxx-user-badge {
            display: flex;
            align-items: center;
            gap: 6px;
            padding: 6px 12px;
            background: rgba(29, 185, 84, 0.1);
            border: 1px solid rgba(29, 185, 84, 0.3);
            border-radius: 16px;
            font-size: 12px;
            color: #1db954;
        }

        .mp3-mixxx-suggest {
            flex-shrink: 0;
            padding: 16px;
            border-bottom: 1px solid #3f3f3f;
            background: #0f0f0f;
        }

        .mp3-mixxx-suggest-header {
            margin-bottom: 12px;
        }

        .mp3-mixxx-suggest-results {
            max-height: 200px;
            overflow-y: auto;
            margin-top: 8px;
        }

        .mp3-mixxx-suggestions {
            flex: 1;
            display: flex;
            flex-direction: column;
            overflow: hidden;
            min-height: 0;
        }

        .mp3-mixxx-suggestions-header {
            flex-shrink: 0;
            padding: 16px;
            border-bottom: 1px solid #3f3f3f;
            background: #181818;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .mp3-mixxx-suggestions-list {
            flex: 1;
            overflow-y: auto;
            overflow-x: hidden;
            padding: 16px;
            min-height: 0;
        }

        .mp3-mixxx-suggestions-list::-webkit-scrollbar {
            width: 8px;
        }

        .mp3-mixxx-suggestions-list::-webkit-scrollbar-track {
            background: #0f0f0f;
        }

        .mp3-mixxx-suggestions-list::-webkit-scrollbar-thumb {
            background: #3f3f3f;
            border-radius: 4px;
        }

        .mp3-mixxx-suggestion-item {
            background: #1a1a1a;
            padding: 12px;
            border-radius: 8px;
            margin-bottom: 12px;
            border: 1px solid #2a2a2a;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            gap: 12px;
            align-items: center;
        }

        .mp3-mixxx-suggestion-item:hover {
            background: #252525;
            border-color: #1db954;
        }

        .mp3-mixxx-suggestion-item-image {
            width: 50px;
            height: 50px;
            border-radius: 4px;
            object-fit: cover;
            flex-shrink: 0;
        }

        .mp3-mixxx-suggestion-item-info {
            flex: 1;
            min-width: 0;
        }

        .mp3-mixxx-suggestion-item-title {
            font-size: 13px;
            font-weight: 500;
            color: #ffffff;
            margin-bottom: 4px;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .mp3-mixxx-suggestion-item-artist {
            font-size: 11px;
            color: #b3b3b3;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .mp3-mixxx-suggestion-item-author {
            font-size: 10px;
            color: #888888;
            margin-top: 4px;
        }

        .mp3-mixxx-suggestion-item-actions {
            display: flex;
            gap: 4px;
            flex-shrink: 0;
        }

        .mp3-mixxx-suggestion-item-btn {
            background: transparent;
            border: 1px solid #3f3f3f;
            color: #b3b3b3;
            padding: 4px 8px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 11px;
            transition: all 0.2s;
        }

        .mp3-mixxx-suggestion-item-btn:hover {
            border-color: #1db954;
            color: #1db954;
        }

        .mp3-mixxx-suggestion-item-btn.primary {
            background: rgba(29, 185, 84, 0.1);
            border-color: #1db954;
            color: #1db954;
        }

        /* VJ Mixxx section */
        .mp3-mixxx-vj {
            flex-shrink: 0;
            padding: 16px;
            border-top: 1px solid #3f3f3f;
            border-bottom: 1px solid #3f3f3f;
            background: #0f0f0f;
        }

        .mp3-mixxx-vj-header {
            margin-bottom: 12px;
        }

        .mp3-mixxx-vj-results {
            max-height: 200px;
            overflow-y: auto;
            margin-top: 8px;
        }

        .mp3-mixxx-vj-suggestions {
            flex: 1;
            display: flex;
            flex-direction: column;
            overflow: hidden;
            min-height: 0;
        }

        .mp3-mixxx-vj-suggestions-header {
            flex-shrink: 0;
            padding: 16px;
            border-bottom: 1px solid #3f3f3f;
            background: #181818;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .mp3-mixxx-vj-suggestions-list {
            flex: 1;
            overflow-y: auto;
            overflow-x: hidden;
            padding: 16px;
            min-height: 0;
        }

        .mp3-mixxx-vj-suggestion-item {
            background: #1a1a1a;
            padding: 12px;
            border-radius: 8px;
            margin-bottom: 12px;
            border: 1px solid #2a2a2a;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            gap: 12px;
            align-items: center;
        }

        .mp3-mixxx-vj-suggestion-item:hover {
            background: #252525;
            border-color: #ff0000;
        }

        .mp3-mixxx-vj-suggestion-item-image {
            width: 80px;
            height: 60px;
            border-radius: 4px;
            object-fit: cover;
            flex-shrink: 0;
        }

        .mp3-mixxx-vj-suggestion-item-info {
            flex: 1;
            min-width: 0;
        }

        .mp3-mixxx-vj-suggestion-item-title {
            font-size: 13px;
            font-weight: 500;
            color: #ffffff;
            margin-bottom: 4px;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .mp3-mixxx-vj-suggestion-item-channel {
            font-size: 11px;
            color: #b3b3b3;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .mp3-mixxx-vj-suggestion-item-author {
            font-size: 10px;
            color: #888888;
            margin-top: 4px;
        }

        .mp3-mixxx-vj-suggestion-item-actions {
            display: flex;
            gap: 4px;
            flex-shrink: 0;
        }

        .mp3-mixxx-vj-suggestion-item-btn {
            background: transparent;
            border: 1px solid #3f3f3f;
            color: #b3b3b3;
            padding: 4px 8px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 11px;
            transition: all 0.2s;
        }

        .mp3-mixxx-vj-suggestion-item-btn:hover {
            border-color: #ff0000;
            color: #ff0000;
        }

        .mp3-mixxx-vj-suggestion-item-btn.primary {
            background: rgba(255, 0, 0, 0.1);
            border-color: #ff0000;
            color: #ff0000;
        }

        /* Related Tracks section */
        .mp3-related-section {
            flex: 1;
            display: flex;
            flex-direction: column;
            overflow: hidden;
            display: none;
        }

        .mp3-related-section.active {
            display: flex;
        }

        .mp3-related-header {
            flex-shrink: 0;
            padding: 16px;
            border-bottom: 1px solid #3f3f3f;
            background: #181818;
        }

        .mp3-related-header h6 {
            margin: 0 0 8px 0;
            font-size: 14px;
            font-weight: 600;
        }

        .mp3-related-search {
            flex-shrink: 0;
            padding: 16px;
            border-bottom: 1px solid #3f3f3f;
            background: #0f0f0f;
        }

        .mp3-related-list {
            flex: 1;
            overflow-y: auto;
            overflow-x: hidden;
            padding: 16px;
            min-height: 0;
        }

        .mp3-related-list::-webkit-scrollbar {
            width: 8px;
        }

        .mp3-related-list::-webkit-scrollbar-track {
            background: #0f0f0f;
        }

        .mp3-related-list::-webkit-scrollbar-thumb {
            background: #3f3f3f;
            border-radius: 4px;
        }

        /* Related track item */
        .mp3-related-item {
            background: #1a1a1a;
            padding: 12px;
            border-radius: 8px;
            margin-bottom: 12px;
            border: 1px solid #2a2a2a;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            gap: 12px;
            align-items: center;
        }

        .mp3-related-item:hover {
            background: #252525;
            border-color: #1db954;
        }

        .mp3-related-item-image {
            width: 60px;
            height: 60px;
            border-radius: 4px;
            object-fit: cover;
            flex-shrink: 0;
        }

        .mp3-related-item-info {
            flex: 1;
            min-width: 0;
        }

        .mp3-related-item-title {
            font-size: 14px;
            font-weight: 500;
            color: #ffffff;
            margin-bottom: 4px;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .mp3-related-item-artist {
            font-size: 12px;
            color: #b3b3b3;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .mp3-related-item-actions {
            display: flex;
            gap: 8px;
            flex-shrink: 0;
        }

        .mp3-related-item-btn {
            background: transparent;
            border: 1px solid #3f3f3f;
            color: #b3b3b3;
            padding: 6px 12px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
            transition: all 0.2s;
        }

        .mp3-related-item-btn:hover {
            border-color: #1db954;
            color: #1db954;
        }
        
        .mp3-uploader-link {
            color: #1db954;
            text-decoration: none;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        
        .mp3-uploader-link:hover {
            color: #1ed760;
            text-decoration: underline;
        }
        
        .mp3-comment-item {
            background: #1a1a1a;
            padding: 12px;
            border-radius: 8px;
            margin-bottom: 12px;
            border: 1px solid #2a2a2a;
            position: relative;
        }
        
        .mp3-comment-item.original-comment {
            background: rgba(29, 185, 84, 0.08);
            border-left: 3px solid #1db954;
            border: 1px solid rgba(29, 185, 84, 0.3);
        }
        
        .mp3-comment-item.original-comment .mp3-comment-author::after {
            content: " (Original)";
            font-size: 0.75em;
            color: #1db954;
            font-weight: normal;
        }
        
        .mp3-comment-replies {
            margin-left: 24px;
            margin-top: 12px;
            padding-left: 12px;
            border-left: 2px solid #3f3f3f;
        }
        
        .mp3-comment-item.reply {
            background: #151515;
            border-left: 2px solid #4a4a4a;
        }
        
        .mp3-comment-item.reply .mp3-comment-author {
            font-size: 12px;
        }
        
        .mp3-comment-item.reply .mp3-comment-content {
            font-size: 12px;
        }
        
        .mp3-comment-actions {
            display: flex;
            gap: 8px;
            margin-top: 8px;
            align-items: center;
        }
        
        .mp3-comment-reply-btn {
            background: transparent;
            border: none;
            color: #1db954;
            cursor: pointer;
            padding: 4px 8px;
            font-size: 11px;
            border-radius: 4px;
            transition: all 0.2s ease;
        }
        
        .mp3-comment-reply-btn:hover {
            background: rgba(29, 185, 84, 0.1);
            color: #1ed760;
        }
        
        .mp3-comment-reply-form {
            margin-top: 12px;
            padding: 12px;
            background: #0f0f0f;
            border-radius: 8px;
            border: 1px solid #3f3f3f;
            display: none;
        }
        
        .mp3-comment-reply-form.active {
            display: block;
        }
        
        .mp3-reply-count {
            font-size: 11px;
            color: #888888;
            margin-left: 8px;
        }
        
        .mp3-comment-author {
            font-weight: 600;
            color: #ffffff;
            margin-bottom: 6px;
            font-size: 13px;
        }
        
        .mp3-comment-content {
            color: #e0e0e0;
            font-size: 13px;
            line-height: 1.5;
            margin-bottom: 6px;
            white-space: pre-wrap;
            word-wrap: break-word;
        }
        
        .mp3-comment-time {
            color: #999999;
            font-size: 11px;
        }
        
        @keyframes slideIn {
            from {
                opacity: 0;
                transform: translateY(-10px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }
        
        .live-comment {
            animation: slideIn 0.3s ease-out;
        }

        /* Tablet: adjust proportions */
        @media (max-width: 1200px) and (min-width: 769px) {
            .mp3-content-grid {
                grid-template-columns: 1fr 350px !important;
            }
        }
        
        /* Mobile: stack everything vertically */
        @media (max-width: 768px) {
            .mp3-content-grid {
                display: flex !important;
                flex-direction: column !important;
                height: auto !important;
                min-height: calc(100vh - 60px) !important;
            }
            
            .mp3-audio-container {
                width: 100% !important;
                height: auto !important;
                min-height: 50vh !important;
                order: 1;
            }
            
            .mp3-track-info {
                width: 100% !important;
                max-height: none !important;
                order: 2;
                border-top: 1px solid #3f3f3f;
                padding: 12px 16px;
                max-height: 30vh;
            }
            
            .mp3-right-panel {
                width: 100% !important;
                height: auto !important;
                min-height: 50vh !important;
                max-height: 50vh !important;
                order: 3;
                border-left: none;
                border-top: 1px solid #3f3f3f;
            }
            
            .mp3-header h5 {
                font-size: 14px;
                max-width: 50%;
            }
        }
        
        /* Very small mobile devices */
        @media (max-width: 480px) {
            .mp3-header {
                padding: 8px 12px;
                height: 50px;
            }
            
            .mp3-header h5 {
                font-size: 13px;
                max-width: 40%;
            }
            
            .mp3-header .btn {
                padding: 4px 8px;
                font-size: 11px;
            }
            
            .mp3-header .btn span {
                display: none;
            }
        }
    </style>
</head>
<body class="bg-dark text-white">
    <div class="mp3-modal" id="mp3Modal">
        <!-- Header -->
        <div class="mp3-header">
            <h5 class="mb-0 text-truncate flex-grow-1" id="mp3Title" style="max-width: 60%;">Loading...</h5>
            <div class="d-flex gap-2 align-items-center">
                <button class="btn btn-sm btn-outline-secondary" id="mp3CloseBtn" title="Close" onclick="handleCloseMP3Modal()">
                    <i class="bi bi-x-lg"></i>
                </button>
                <button class="btn btn-sm btn-outline-info" id="mp3FollowBtn" title="Follow" style="display: none;">
                    <i class="bi bi-person-plus"></i> <span id="mp3FollowText">Follow</span>
                </button>
                <button class="btn btn-sm btn-outline-success" id="mp3LikeBtn" title="Like">
                    <i class="bi bi-hand-thumbs-up"></i>
                </button>
                <button class="btn btn-sm btn-outline-primary" id="mp3ShareBtn" title="Share">
                    <i class="bi bi-share"></i>
                </button>
            </div>
        </div>
        
        <!-- Main content grid -->
        <div class="mp3-content-grid">
            <!-- Audio player (left side) -->
            <div class="mp3-audio-container">
                <div class="mp3-audio-wrapper" style="position: relative;">
                    <img id="mp3AlbumArt" class="mp3-album-art" style="display: none;" alt="Album Art">
                    <div id="mp3AlbumArtPlaceholder" class="mp3-album-art-placeholder">ðŸŽµ</div>
                    <button id="mp3ChangeThumbnailBtn" class="btn btn-sm btn-secondary" style="position: absolute; top: 8px; right: 8px; z-index: 10; display: none; opacity: 0.8;" title="Change thumbnail">
                        <i class="bi bi-image"></i>
                    </button>
                </div>
                
                <!-- Audio player controls -->
                <div class="mp3-audio-player">
                    <audio 
                        id="mp3AudioPlayer" 
                        controls 
                        style="width: 100%;"
                        preload="metadata">
                        Your browser does not support audio playback.
                    </audio>
                </div>
                
                <!-- Track info (below audio player) -->
                <div class="mp3-track-info">
                    <div class="d-flex gap-3 mb-2 flex-wrap" id="mp3TrackStats">
                        <span class="badge bg-success rounded-pill"><i class="bi bi-hand-thumbs-up"></i> <span id="likeCount">0</span></span>
                        <span class="badge bg-primary rounded-pill"><i class="bi bi-share"></i> <span id="shareCount">0</span></span>
                        <span class="badge bg-info rounded-pill"><i class="bi bi-chat"></i> <span id="commentCount">0</span></span>
                    </div>
                    <div class="small text-secondary mb-2" id="mp3TrackMeta">
                        <span id="mp3ArtistContainer">
                            <span id="mp3Artist">Loading...</span>
                        </span>
                        <span id="mp3Duration"></span>
                    </div>
                    <div class="small text-white-50 lh-base" id="mp3Description"></div>
                    
                    <!-- Provenance section -->
                    <div class="mt-3 pt-3 border-top border-secondary" id="mp3ProvenanceSection" style="display: none;">
                        <div class="small">
                            <div class="text-secondary mb-2"><i class="bi bi-diagram-3"></i> <strong>Provenance</strong></div>
                            <div id="mp3UploadChain" class="mb-2"></div>
                            <div class="d-flex gap-2 flex-wrap" id="mp3ProvenanceLinks"></div>
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- Right panel: Comments & Related Tracks -->
            <div class="mp3-right-panel">
                <!-- Tabs -->
                <div class="mp3-tabs">
                    <button class="mp3-tab active" onclick="switchMP3Tab('comments')">
                        <i class="bi bi-chat-dots"></i> Comments
                    </button>
                    <button class="mp3-tab" onclick="switchMP3Tab('mixxx')">
                        <i class="bi bi-people"></i> Mixxx Mode
                    </button>
                    <button class="mp3-tab" onclick="switchMP3Tab('related')">
                        <i class="bi bi-music-note-list"></i> Related Tracks
                    </button>
                </div>

                <!-- Comments section -->
                <div class="mp3-comments-section active" id="mp3CommentsSection">
                    <div class="mp3-comments-header">
                        <h6 class="mb-1 text-white"><i class="bi bi-chat-dots"></i> Comments</h6>
                        <div class="small text-secondary" id="mp3CommentStats">0 comment(s)</div>
                    </div>
                    <div class="mp3-comments-form">
                        <textarea 
                            id="mp3CommentInput" 
                            class="form-control bg-dark text-white border-secondary mb-2"
                            placeholder="Add a comment..."
                            rows="3"></textarea>
                        <div class="d-flex gap-2 justify-content-end">
                            <button class="btn btn-sm btn-primary" id="submitMP3CommentBtn">
                                <i class="bi bi-send"></i> Publish
                            </button>
                        </div>
                    </div>
                    <div class="mp3-comments-list" id="mp3CommentsList">
                        <div class="text-center text-secondary py-5">Loading comments...</div>
                    </div>
                </div>

                <!-- Mixxx Mode section -->
                <div class="mp3-mixxx-section" id="mp3MixxxSection">
                    <div class="mp3-mixxx-header">
                        <h6 class="mb-1 text-white"><i class="bi bi-people"></i> Mixxx Mode</h6>
                        <div class="small text-secondary">Collaborative playlist building</div>
                    </div>
                    
                    <!-- Connected users -->
                    <div class="mp3-mixxx-users">
                        <div class="mp3-mixxx-users-header">
                            <span class="small text-secondary"><i class="bi bi-person-circle"></i> Connected DJs</span>
                            <span class="badge bg-success rounded-pill" id="mixxxUsersCount">0</span>
                        </div>
                        <div class="mp3-mixxx-users-list" id="mixxxUsersList">
                            <div class="text-center text-secondary py-3 small">Loading connected users...</div>
                        </div>
                    </div>
                    
                    <!-- Suggest next track -->
                    <div class="mp3-mixxx-suggest">
                        <div class="mp3-mixxx-suggest-header">
                            <span class="small text-white"><i class="bi bi-arrow-right-circle"></i> Suggest Next Track</span>
                        </div>
                        <div class="mp3-mixxx-suggest-search">
                            <input 
                                type="text" 
                                id="mp3MixxxSearchInput" 
                                class="form-control bg-dark text-white border-secondary mb-2"
                                placeholder="Search track to suggest..."
                                autocomplete="off">
                        </div>
                        <div class="mp3-mixxx-suggest-results" id="mp3MixxxSuggestResults" style="display: none;">
                            <!-- Search results will appear here -->
                        </div>
                    </div>
                    
                    <!-- Suggestions list -->
                    <div class="mp3-mixxx-suggestions">
                        <div class="mp3-mixxx-suggestions-header">
                            <span class="small text-white"><i class="bi bi-list-ul"></i> Track Suggestions</span>
                            <span class="badge bg-primary rounded-pill" id="mixxxSuggestionsCount">0</span>
                        </div>
                        <div class="mp3-mixxx-suggestions-list" id="mp3MixxxSuggestionsList">
                            <div class="text-center text-secondary py-5 small">No suggestions yet. Be the first to suggest a track!</div>
                        </div>
                    </div>
                    
                    <!-- VJ Mixxx section -->
                    <div class="mp3-mixxx-vj">
                        <div class="mp3-mixxx-vj-header">
                            <span class="small text-white"><i class="bi bi-camera-video"></i> VJ Mixxx - Suggest Video</span>
                        </div>
                        <div class="mp3-mixxx-vj-search">
                            <input 
                                type="text" 
                                id="mp3MixxxVJSearchInput" 
                                class="form-control bg-dark text-white border-secondary mb-2"
                                placeholder="Search video to suggest as VJ mix..."
                                autocomplete="off">
                        </div>
                        <div class="mp3-mixxx-vj-results" id="mp3MixxxVJResults" style="display: none;">
                            <!-- Search results will appear here -->
                        </div>
                    </div>
                    
                    <!-- VJ Suggestions list -->
                    <div class="mp3-mixxx-vj-suggestions">
                        <div class="mp3-mixxx-vj-suggestions-header">
                            <span class="small text-white"><i class="bi bi-film"></i> VJ Suggestions</span>
                            <span class="badge bg-danger rounded-pill" id="mixxxVJSuggestionsCount">0</span>
                        </div>
                        <div class="mp3-mixxx-vj-suggestions-list" id="mp3MixxxVJSuggestionsList">
                            <div class="text-center text-secondary py-5 small">No VJ suggestions yet. Be the first to suggest a video!</div>
                        </div>
                    </div>
                </div>

                <!-- Related Tracks section -->
                <div class="mp3-related-section" id="mp3RelatedSection">
                    <div class="mp3-related-header">
                        <h6 class="mb-1 text-white"><i class="bi bi-music-note-list"></i> Related Tracks</h6>
                        <div class="small text-secondary">Search and link to other tracks</div>
                    </div>
                    <div class="mp3-related-search">
                        <input 
                            type="text" 
                            id="mp3RelatedSearchInput" 
                            class="form-control bg-dark text-white border-secondary mb-2"
                            placeholder="Search tracks by title, artist, or album..."
                            autocomplete="off">
                        <div class="small text-secondary">Search results will appear below</div>
                    </div>
                    <div class="mp3-related-list" id="mp3RelatedList">
                        <div class="text-center text-secondary py-5">Search for tracks to link...</div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        /**
         * Handle close button click - wrapper to ensure function is available
         */
        function handleCloseMP3Modal() {
            console.log('ðŸ”´ handleCloseMP3Modal called');
            
            // Close any active comment subscriptions
            if (window.currentMP3CommentSubscription) {
                try {
                    console.log('ðŸ“¡ Closing comment subscription...');
                    window.currentMP3CommentSubscription.unsub();
                    window.currentMP3CommentSubscription = null;
                } catch (e) {
                    console.warn('âš ï¸ Error closing comment subscription:', e);
                }
            }
            
            // Close Mixxx mode subscriptions
            if (window.currentMixxxPresenceSubscription) {
                try {
                    window.currentMixxxPresenceSubscription.unsub();
                    window.currentMixxxPresenceSubscription = null;
                } catch (e) {
                    console.warn('âš ï¸ Error closing Mixxx presence subscription:', e);
                }
            }
            
            if (window.currentMixxxSuggestionsSubscription) {
                try {
                    window.currentMixxxSuggestionsSubscription.unsub();
                    window.currentMixxxSuggestionsSubscription = null;
                } catch (e) {
                    console.warn('âš ï¸ Error closing Mixxx suggestions subscription:', e);
                }
            }
            
            if (window.currentMixxxVJSuggestionsSubscription) {
                try {
                    window.currentMixxxVJSuggestionsSubscription.unsub();
                    window.currentMixxxVJSuggestionsSubscription = null;
                } catch (e) {
                    console.warn('âš ï¸ Error closing Mixxx VJ suggestions subscription:', e);
                }
            }
            
            // Pause and cleanup audio
            const audioPlayer = document.getElementById('mp3AudioPlayer');
            if (audioPlayer) {
                audioPlayer.pause();
                audioPlayer.src = '';
                audioPlayer.load();
            }
            
            // Detect context: are we in a standalone window/tab or an iframe?
            const isStandalone = (window.parent === window) || (window.location === window.parent.location);
            
            if (isStandalone) {
                // Standalone mode (opened in new tab from mp3.html)
                console.log('ðŸ“¤ Closing standalone MP3 modal window/tab');
                
                try {
                    window.close();
                } catch (e) {
                    console.warn('âš ï¸ Could not close window:', e);
                }
                
                if (!window.closed) {
                    console.log('ðŸ“¤ Attempting to go back in history');
                    if (window.history.length > 1) {
                        window.history.back();
                    } else {
                        window.location.href = '/mp3?html=1';
                    }
                }
                return;
            }
            
            // If we're in an iframe or modal context
            let closed = false;
            
            // Strategy 1: Try to use closeMP3Modal from parent or global context
            if (typeof window.closeMP3Modal === 'function') {
                try {
                    console.log('ðŸ“¤ Attempting to close via window.closeMP3Modal');
                    window.closeMP3Modal();
                    closed = true;
                    return;
                } catch (e) {
                    console.warn('âš ï¸ closeMP3Modal failed:', e);
                }
            }
            
            // Strategy 2: Try parent window if we're in an iframe
            if (!closed && window.parent && window.parent !== window) {
                if (typeof window.parent.closeMP3Modal === 'function') {
                    try {
                        console.log('ðŸ“¤ Attempting to close via parent.closeMP3Modal');
                        window.parent.closeMP3Modal();
                        closed = true;
                        return;
                    } catch (e) {
                        console.warn('âš ï¸ Parent closeMP3Modal failed:', e);
                    }
                }
                
                // Try to close via postMessage as backup
                if (!closed) {
                    try {
                        console.log('ðŸ“¤ Attempting to close via postMessage');
                        window.parent.postMessage({ type: 'close-mp3-modal' }, '*');
                        closed = true;
                        return;
                    } catch (e) {
                        console.warn('âš ï¸ PostMessage close failed:', e);
                    }
                }
            }
            
            // Strategy 3: Try to close Bootstrap modal directly
            if (!closed) {
                const modalEl = document.getElementById('mp3Modal') || 
                               document.querySelector('.mp3-modal');
                
                if (modalEl) {
                    try {
                        console.log('ðŸ“¤ Attempting to close Bootstrap modal directly');
                        if (typeof bootstrap !== 'undefined' && bootstrap.Modal) {
                            const bsModal = bootstrap.Modal.getInstance(modalEl);
                            if (bsModal) {
                                bsModal.hide();
                                closed = true;
                                return;
                            }
                        }
                        
                        // Fallback: remove modal directly
                        modalEl.style.display = 'none';
                        modalEl.classList.remove('show');
                        document.body.classList.remove('modal-open');
                        
                        const backdrop = document.querySelector('.modal-backdrop');
                        if (backdrop) {
                            backdrop.remove();
                        }
                        
                        closed = true;
                        return;
                    } catch (e) {
                        console.warn('âš ï¸ Direct modal close failed:', e);
                    }
                }
            }
            
            if (!closed) {
                console.error('âŒ All close strategies failed');
            }
        }
        
        // Expose function globally early
        window.handleCloseMP3Modal = handleCloseMP3Modal;

        /**
         * Switch between Comments, Mixxx Mode, and Related Tracks tabs
         */
        function switchMP3Tab(tabName) {
            // Update tab buttons
            document.querySelectorAll('.mp3-tab').forEach(tab => {
                tab.classList.remove('active');
            });
            event?.target?.classList.add('active');
            
            // Show/hide sections
            const commentsSection = document.getElementById('mp3CommentsSection');
            const mixxxSection = document.getElementById('mp3MixxxSection');
            const relatedSection = document.getElementById('mp3RelatedSection');
            
            if (tabName === 'comments') {
                if (commentsSection) commentsSection.classList.add('active');
                if (mixxxSection) mixxxSection.classList.remove('active');
                if (relatedSection) relatedSection.classList.remove('active');
            } else if (tabName === 'mixxx') {
                if (commentsSection) commentsSection.classList.remove('active');
                if (mixxxSection) mixxxSection.classList.add('active');
                if (relatedSection) relatedSection.classList.remove('active');
                
                // Initialize Mixxx mode
                initializeMixxxMode();
            } else if (tabName === 'related') {
                if (commentsSection) commentsSection.classList.remove('active');
                if (mixxxSection) mixxxSection.classList.remove('active');
                if (relatedSection) relatedSection.classList.add('active');
                
                // Focus search input when switching to related tab
                const searchInput = document.getElementById('mp3RelatedSearchInput');
                if (searchInput) {
                    setTimeout(() => searchInput.focus(), 100);
                }
            }
        }

        /**
         * Initialize MP3 modal with track data
         */
        function initializeMP3Modal(trackData) {
            if (!trackData) return;
            
            const audioPlayer = document.getElementById('mp3AudioPlayer');
            const titleEl = document.getElementById('mp3Title');
            const durationEl = document.getElementById('mp3Duration');
            const descriptionEl = document.getElementById('mp3Description');
            const artistEl = document.getElementById('mp3Artist');
            const albumArtEl = document.getElementById('mp3AlbumArt');
            const albumArtPlaceholder = document.getElementById('mp3AlbumArtPlaceholder');
            
            // Set title
            if (titleEl && trackData.title) {
                titleEl.textContent = trackData.title;
                document.title = `${trackData.title} - Nostrify`;
            }
            
            // Set audio source
            if (audioPlayer && trackData.url) {
                // Ensure IPFS_GATEWAY is defined
                if (!window.IPFS_GATEWAY) {
                    if (typeof detectIPFSGatewayGlobal === 'function') {
                        detectIPFSGatewayGlobal();
                    } else {
                        const currentURL = new URL(window.location.href);
                        const hostname = currentURL.hostname;
                        if (hostname === '127.0.0.1' || hostname === 'localhost') {
                            window.IPFS_GATEWAY = 'http://127.0.0.1:8080';
                        } else if (hostname.startsWith('u.')) {
                            const baseDomain = hostname.substring('u.'.length);
                            window.IPFS_GATEWAY = `${currentURL.protocol}//ipfs.${baseDomain}`;
                        } else {
                            window.IPFS_GATEWAY = 'https://ipfs.copylaradio.com';
                        }
                    }
                }
                
                // Convert IPFS URL if needed
                let audioUrl = trackData.url;
                if (typeof convertIPFSUrlGlobal === 'function') {
                    audioUrl = convertIPFSUrlGlobal(audioUrl);
                } else if (window.IPFS_GATEWAY && audioUrl.includes('/ipfs/')) {
                    const match = audioUrl.match(/\/ipfs\/[^?"#]+/);
                    if (match) {
                        audioUrl = window.IPFS_GATEWAY + match[0];
                    }
                }
                
                console.log('ðŸŽµ Loading audio:', audioUrl);
                
                audioPlayer.src = audioUrl;
                audioPlayer.load();
                
                // Store metadata
                if (trackData.eventId) {
                    audioPlayer.setAttribute('data-event-id', trackData.eventId);
                }
                if (trackData.authorId) {
                    audioPlayer.setAttribute('data-author-id', trackData.authorId);
                }
                if (trackData.url) {
                    audioPlayer.setAttribute('data-ipfs-url', trackData.url);
                }
            }
            
            // Set album art
            if (trackData.thumbnail) {
                let thumbnailUrl = trackData.thumbnail;
                if (typeof convertIPFSUrlGlobal === 'function') {
                    thumbnailUrl = convertIPFSUrlGlobal(thumbnailUrl);
                } else if (window.IPFS_GATEWAY && thumbnailUrl.includes('/ipfs/')) {
                    const match = thumbnailUrl.match(/\/ipfs\/[^?"#]+/);
                    if (match) {
                        thumbnailUrl = window.IPFS_GATEWAY + match[0];
                    }
                }
                
                if (albumArtEl) {
                    albumArtEl.src = thumbnailUrl;
                    albumArtEl.style.display = 'block';
                    if (albumArtPlaceholder) {
                        albumArtPlaceholder.style.display = 'none';
                    }
                }
            } else {
                if (albumArtEl) albumArtEl.style.display = 'none';
                if (albumArtPlaceholder) albumArtPlaceholder.style.display = 'flex';
            }
            
            // Setup thumbnail change button
            const changeThumbnailBtn = document.getElementById('mp3ChangeThumbnailBtn');
            if (changeThumbnailBtn) {
                changeThumbnailBtn.style.display = 'block';
                changeThumbnailBtn.onclick = () => openThumbnailSearch();
                
                // Show button on hover
                const audioWrapper = document.querySelector('.mp3-audio-wrapper');
                if (audioWrapper) {
                    audioWrapper.addEventListener('mouseenter', () => {
                        if (changeThumbnailBtn) changeThumbnailBtn.style.opacity = '1';
                    });
                    audioWrapper.addEventListener('mouseleave', () => {
                        if (changeThumbnailBtn) changeThumbnailBtn.style.opacity = '0.8';
                    });
                }
            }
            
            // Set duration
            if (durationEl && trackData.duration) {
                const minutes = Math.floor(trackData.duration / 60);
                const seconds = Math.floor(trackData.duration % 60);
                durationEl.textContent = ` â€¢ ${minutes}:${String(seconds).padStart(2, '0')}`;
            }
            
            // Set description (enriched with comprehensive metadata)
            if (descriptionEl) {
                let descriptionText = trackData.description || '';
                
                // Add comprehensive metadata to description if available
                if (trackData.infoJson || trackData.youtubeMetadata || trackData.statistics) {
                    const metadataParts = [];
                    
                    // Add channel info
                    if (trackData.channel || trackData.channelInfo?.display_name) {
                        const channelName = trackData.channel || trackData.channelInfo?.display_name || trackData.channelInfo?.name;
                        if (channelName) {
                            metadataParts.push(`ðŸ“º Channel: ${channelName}`);
                        }
                    }
                    
                    // Add YouTube URL
                    if (trackData.youtubeUrl) {
                        metadataParts.push(`ðŸ”— YouTube: ${trackData.youtubeUrl}`);
                    }
                    
                    // Add statistics
                    if (trackData.viewCount > 0 || trackData.statistics?.view_count > 0) {
                        const views = trackData.viewCount || trackData.statistics?.view_count || 0;
                        metadataParts.push(`ðŸ‘ï¸ Views: ${views.toLocaleString()}`);
                    }
                    if (trackData.likeCount > 0 || trackData.statistics?.like_count > 0) {
                        const likes = trackData.likeCount || trackData.statistics?.like_count || 0;
                        metadataParts.push(`ðŸ‘ Likes: ${likes.toLocaleString()}`);
                    }
                    if (trackData.commentCount > 0 || trackData.statistics?.comment_count > 0) {
                        const comments = trackData.commentCount || trackData.statistics?.comment_count || 0;
                        metadataParts.push(`ðŸ’¬ Comments: ${comments.toLocaleString()}`);
                    }
                    
                    // Add dates
                    if (trackData.uploadDate || trackData.dates?.upload_date) {
                        const uploadDate = trackData.uploadDate || trackData.dates?.upload_date;
                        if (uploadDate) {
                            // Format date (YYYYMMDD -> YYYY-MM-DD)
                            const formattedDate = uploadDate.length === 8 
                                ? `${uploadDate.substring(0, 4)}-${uploadDate.substring(4, 6)}-${uploadDate.substring(6, 8)}`
                                : uploadDate;
                            metadataParts.push(`ðŸ“… Uploaded: ${formattedDate}`);
                        }
                    }
                    if (trackData.releaseDate || trackData.dates?.release_date) {
                        const releaseDate = trackData.releaseDate || trackData.dates?.release_date;
                        if (releaseDate) {
                            const formattedDate = releaseDate.length === 8 
                                ? `${releaseDate.substring(0, 4)}-${releaseDate.substring(4, 6)}-${releaseDate.substring(6, 8)}`
                                : releaseDate;
                            metadataParts.push(`ðŸŽ¬ Released: ${formattedDate}`);
                        }
                    }
                    
                    // Add technical info
                    if (trackData.abr > 0 || trackData.technicalInfo?.abr > 0) {
                        const abr = trackData.abr || trackData.technicalInfo?.abr || 0;
                        metadataParts.push(`ðŸŽšï¸ Bitrate: ${abr} kbps`);
                    }
                    if (trackData.acodec || trackData.technicalInfo?.acodec) {
                        const acodec = trackData.acodec || trackData.technicalInfo?.acodec;
                        metadataParts.push(`ðŸ”Š Codec: ${acodec}`);
                    }
                    
                    // Add tags/categories
                    if (trackData.tags && trackData.tags.length > 0) {
                        metadataParts.push(`ðŸ·ï¸ Tags: ${trackData.tags.slice(0, 5).join(', ')}${trackData.tags.length > 5 ? '...' : ''}`);
                    }
                    if (trackData.categories && trackData.categories.length > 0) {
                        metadataParts.push(`ðŸ“‚ Categories: ${trackData.categories.slice(0, 3).join(', ')}${trackData.categories.length > 3 ? '...' : ''}`);
                    }
                    
                    // Add language
                    if (trackData.language || trackData.contentInfo?.language) {
                        const lang = trackData.language || trackData.contentInfo?.language;
                        metadataParts.push(`ðŸŒ Language: ${lang}`);
                    }
                    
                    // Add license
                    if (trackData.license || trackData.contentInfo?.license) {
                        const license = trackData.license || trackData.contentInfo?.license;
                        metadataParts.push(`ðŸ“œ License: ${license}`);
                    }
                    
                    // Combine description with metadata
                    if (descriptionText) {
                        descriptionText += '\n\n' + metadataParts.join('\n');
                    } else {
                        descriptionText = metadataParts.join('\n');
                    }
                }
                
                descriptionEl.textContent = descriptionText;
            }
            
            // Load artist (enriched)
            if (artistEl) {
                let artistText = trackData.artist || 'Unknown Artist';
                
                // Add creator if different from artist
                if (trackData.creator && trackData.creator !== artistText) {
                    artistText += ` (by ${trackData.creator})`;
                }
                
                // Add album if available
                if (trackData.album && trackData.album !== 'â€”') {
                    artistText += ` â€¢ ${trackData.album}`;
                }
                
                artistEl.textContent = artistText;
            }
            
            // Update track stats with comprehensive metadata
            const likeCountEl = document.getElementById('likeCount');
            const shareCountEl = document.getElementById('shareCount');
            const commentCountEl = document.getElementById('commentCount');
            
            if (likeCountEl && (trackData.likeCount > 0 || trackData.statistics?.like_count > 0)) {
                const likes = trackData.likeCount || trackData.statistics?.like_count || 0;
                likeCountEl.textContent = likes.toLocaleString();
            }
            
            if (commentCountEl && (trackData.commentCount > 0 || trackData.statistics?.comment_count > 0)) {
                const comments = trackData.commentCount || trackData.statistics?.comment_count || 0;
                commentCountEl.textContent = comments.toLocaleString();
            }
            
            // Update track meta section with additional info
            const trackMetaEl = document.getElementById('mp3TrackMeta');
            if (trackMetaEl) {
                const metaParts = [];
                
                if (trackData.channel || trackData.channelInfo?.display_name) {
                    const channelName = trackData.channel || trackData.channelInfo?.display_name || trackData.channelInfo?.name;
                    if (channelName) {
                        metaParts.push(`ðŸ“º ${channelName}`);
                    }
                }
                
                if (trackData.viewCount > 0 || trackData.statistics?.view_count > 0) {
                    const views = trackData.viewCount || trackData.statistics?.view_count || 0;
                    metaParts.push(`ðŸ‘ï¸ ${views.toLocaleString()} views`);
                }
                
                if (metaParts.length > 0) {
                    const existingMeta = trackMetaEl.textContent || '';
                    if (!existingMeta.includes(metaParts[0])) {
                        trackMetaEl.innerHTML = metaParts.join(' â€¢ ') + (existingMeta ? ` â€¢ ${existingMeta}` : '');
                    }
                }
            }
            
            // Load comments
            if (trackData.eventId) {
                setTimeout(() => {
                    loadMP3Comments(trackData.eventId, trackData.authorId, trackData.description || trackData.content);
                }, 500);
            }
            
            // Setup related tracks search
            setupRelatedTracksSearch();
            
            // Load linked tracks
            if (trackData.eventId) {
                setTimeout(() => {
                    loadLinkedTracks(trackData.eventId);
                }, 1000);
            }
            
            // Publish presence for Mixxx mode (if user is connected)
            if (trackData.eventId && typeof userPubkey !== 'undefined' && userPubkey) {
                setTimeout(() => {
                    publishMixxxPresence(trackData.eventId);
                }, 1000);
            }
        }

        /**
         * Setup related tracks search functionality
         */
        function setupRelatedTracksSearch() {
            const searchInput = document.getElementById('mp3RelatedSearchInput');
            if (!searchInput) return;
            
            let searchTimeout = null;
            
            searchInput.addEventListener('input', function(e) {
                const query = e.target.value.trim();
                
                // Clear previous timeout
                if (searchTimeout) {
                    clearTimeout(searchTimeout);
                }
                
                // Debounce search
                searchTimeout = setTimeout(async () => {
                    if (query.length >= 2) {
                        await searchRelatedTracks(query);
                    } else {
                        const relatedList = document.getElementById('mp3RelatedList');
                        if (relatedList) {
                            relatedList.innerHTML = '<div class="text-center text-secondary py-5">Type at least 2 characters to search...</div>';
                        }
                    }
                }, 500);
            });
        }

        /**
         * Search and display related tracks
         */
        async function searchRelatedTracks(query) {
            const relatedList = document.getElementById('mp3RelatedSearchInput');
            if (!relatedList) return;
            
            const listEl = document.getElementById('mp3RelatedList');
            if (!listEl) return;
            
            listEl.innerHTML = '<div class="text-center text-secondary py-5">Searching...</div>';
            
            try {
                // Use searchNostrTracks from nostrify.enhancements.js
                let tracks = [];
                if (typeof searchNostrTracks === 'function') {
                    tracks = await searchNostrTracks(query, 20);
                } else if (typeof fetchNostrMP3Tracks === 'function') {
                    // Fallback: fetch all and filter
                    const allTracks = await fetchNostrMP3Tracks(100);
                    const searchTerm = query.toLowerCase();
                    tracks = allTracks.filter(track => {
                        const title = (track.title || '').toLowerCase();
                        const artist = (track.artist || '').toLowerCase();
                        const album = (track.album || '').toLowerCase();
                        return title.includes(searchTerm) || artist.includes(searchTerm) || album.includes(searchTerm);
                    }).slice(0, 20);
                }
                
                if (tracks.length === 0) {
                    listEl.innerHTML = '<div class="text-center text-secondary py-5">No tracks found</div>';
                    return;
                }
                
                // Render tracks
                const escapeFn = typeof escapeHtml !== 'undefined' ? escapeHtml : (text) => {
                    const div = document.createElement('div');
                    div.textContent = text;
                    return div.innerHTML;
                };
                
                // Get linked track IDs to avoid showing them in search results
                const linkedIds = (window.currentLinkedTracks || []).map(lt => lt.eventId);
                
                // Filter out already linked tracks
                const unlinkedTracks = tracks.filter(track => !linkedIds.includes(track.eventId));
                
                const searchResultsHtml = unlinkedTracks.map(track => `
                    <div class="mp3-related-item" onclick="openRelatedTrack('${track.eventId}')">
                        <img src="${track.thumbnail || ''}" class="mp3-related-item-image" alt="${escapeFn(track.title || '')}" onerror="this.style.display='none'">
                        <div class="mp3-related-item-info">
                            <div class="mp3-related-item-title">${escapeFn(track.title || 'Unknown Title')}</div>
                            <div class="mp3-related-item-artist">${escapeFn(track.artist || 'Unknown Artist')}</div>
                        </div>
                        <div class="mp3-related-item-actions">
                            <button class="mp3-related-item-btn" onclick="event.stopPropagation(); linkRelatedTrack('${track.eventId}', '${escapeFn(track.title || '')}')" title="Link this track">
                                <i class="bi bi-link-45deg"></i> Link
                            </button>
                        </div>
                    </div>
                `).join('');
                
                // Combine linked tracks and search results
                if (window.currentLinkedTracks && window.currentLinkedTracks.length > 0) {
                    renderLinkedTracks(window.currentLinkedTracks);
                    // Append search results
                    const linkedSection = listEl.querySelector('.mb-3');
                    if (linkedSection && searchResultsHtml) {
                        const separator = document.createElement('div');
                        separator.className = 'mt-3 pt-3 border-top border-secondary';
                        separator.innerHTML = `
                            <div class="small text-secondary mb-2">Search Results</div>
                            ${searchResultsHtml}
                        `;
                        listEl.appendChild(separator);
                    } else if (searchResultsHtml) {
                        listEl.innerHTML = searchResultsHtml;
                    }
                } else {
                    listEl.innerHTML = searchResultsHtml;
                }
                
            } catch (error) {
                console.error('Error searching tracks:', error);
                listEl.innerHTML = '<div class="text-center text-secondary py-5">Error searching tracks</div>';
            }
        }

        /**
         * Open a related track in the modal
         */
        async function openRelatedTrack(eventId) {
            console.log('Opening related track:', eventId);
            
            // Load track data and reinitialize modal
            try {
                const track = await loadTrackFromEventId(eventId);
                if (track) {
                    // Clear search input when switching tracks
                    const searchInput = document.getElementById('mp3RelatedSearchInput');
                    if (searchInput) {
                        searchInput.value = '';
                    }
                    const relatedList = document.getElementById('mp3RelatedList');
                    if (relatedList) {
                        relatedList.innerHTML = '<div class="text-center text-secondary py-5">Loading linked tracks...</div>';
                    }
                    
                    initializeMP3Modal(track);
                }
            } catch (error) {
                console.error('Error loading related track:', error);
                alert('Error loading track: ' + error.message);
            }
        }

        /**
         * Load linked tracks (kind 1 events with track-link tag)
         */
        async function loadLinkedTracks(currentEventId) {
            const relatedList = document.getElementById('mp3RelatedList');
            if (!relatedList || !currentEventId) return;
            
            try {
                let currentRelay = window.nostrRelay || nostrRelay;
                
                if (!currentRelay || typeof currentRelay.sub !== 'function') {
                    if (typeof connectToRelay === 'function') {
                        await connectToRelay();
                        await new Promise(resolve => setTimeout(resolve, 500));
                    }
                    currentRelay = window.nostrRelay || nostrRelay;
                }
                
                if (!currentRelay || typeof currentRelay.sub !== 'function') {
                    return;
                }
                
                // Subscribe to kind 1 events with track-link tag that reference this track
                const linkedTracks = [];
                const trackMetadataCache = new Map();
                
                const sub = currentRelay.sub([{
                    kinds: [1],
                    '#t': ['track-link'],
                    '#e': [currentEventId],
                    limit: 50
                }]);
                
                sub.on('event', async (event) => {
                    try {
                        // Extract linked track eventId from tags
                        // Look for 'e' tag with 'reply' marker (the linked track)
                        const replyTag = event.tags.find(t => t[0] === 'e' && t[3] === 'reply');
                        const linkedEventId = replyTag ? replyTag[1] : null;
                        
                        if (!linkedEventId) return;
                        
                        // Check if already in list
                        if (linkedTracks.find(t => t.eventId === linkedEventId)) return;
                        
                        // Load track metadata
                        let trackData = trackMetadataCache.get(linkedEventId);
                        if (!trackData) {
                            try {
                                trackData = await loadTrackFromEventId(linkedEventId);
                                trackMetadataCache.set(linkedEventId, trackData);
                            } catch (e) {
                                console.warn('Could not load linked track:', e);
                                // Still add it with minimal info
                                trackData = {
                                    eventId: linkedEventId,
                                    title: 'Loading...',
                                    artist: 'Unknown Artist',
                                    thumbnail: null
                                };
                            }
                        }
                        
                        linkedTracks.push({
                            eventId: linkedEventId,
                            trackData: trackData,
                            linkEventId: event.id,
                            linkAuthorId: event.pubkey,
                            linkCreatedAt: event.created_at
                        });
                        
                        renderLinkedTracks(linkedTracks);
                    } catch (e) {
                        console.error('Error processing linked track:', e);
                    }
                });
                
                sub.on('eose', () => {
                    console.log('âœ… Linked tracks subscription active');
                    if (linkedTracks.length === 0) {
                        relatedList.innerHTML = '<div class="text-center text-secondary py-5">No linked tracks yet. Search and link tracks above.</div>';
                    }
                });
                
                setTimeout(() => {
                    sub.unsub();
                    if (linkedTracks.length === 0) {
                        relatedList.innerHTML = '<div class="text-center text-secondary py-5">No linked tracks yet. Search and link tracks above.</div>';
                    }
                }, 5000);
                
            } catch (error) {
                console.error('Error loading linked tracks:', error);
            }
        }
        
        // Store linked tracks globally
        window.currentLinkedTracks = [];
        
        /**
         * Render linked tracks
         */
        function renderLinkedTracks(linkedTracks) {
            const relatedList = document.getElementById('mp3RelatedList');
            if (!relatedList) return;
            
            // Store globally
            window.currentLinkedTracks = linkedTracks;
            
            if (linkedTracks.length === 0) {
                // Only show message if there are no search results
                const searchInput = document.getElementById('mp3RelatedSearchInput');
                if (!searchInput || !searchInput.value.trim()) {
                    relatedList.innerHTML = '<div class="text-center text-secondary py-5">No linked tracks yet. Search and link tracks above.</div>';
                }
                return;
            }
            
            const escapeFn = typeof escapeHtml !== 'undefined' ? escapeHtml : (text) => {
                const div = document.createElement('div');
                div.textContent = text;
                return div.innerHTML;
            };
            
            // Show linked tracks at the top
            const linkedTracksHtml = linkedTracks.map(linked => {
                const track = linked.trackData;
                return `
                    <div class="mp3-related-item" onclick="openRelatedTrack('${track.eventId}')">
                        <img src="${track.thumbnail || ''}" class="mp3-related-item-image" alt="${escapeFn(track.title || '')}" onerror="this.style.display='none'">
                        <div class="mp3-related-item-info">
                            <div class="mp3-related-item-title">${escapeFn(track.title || 'Unknown Title')}</div>
                            <div class="mp3-related-item-artist">${escapeFn(track.artist || 'Unknown Artist')}</div>
                        </div>
                        <div class="mp3-related-item-actions">
                            <button class="mp3-related-item-btn" onclick="event.stopPropagation(); openRelatedTrack('${track.eventId}')" title="Open this track">
                                <i class="bi bi-play-fill"></i> Play
                            </button>
                        </div>
                    </div>
                `;
            }).join('');
            
            // Check if there are search results
            const searchInput = document.getElementById('mp3RelatedSearchInput');
            const hasSearchQuery = searchInput && searchInput.value.trim().length >= 2;
            
            if (!hasSearchQuery) {
                // No search query, show only linked tracks
                relatedList.innerHTML = `
                    <div class="mb-3">
                        <div class="small text-secondary mb-2"><i class="bi bi-link-45deg"></i> Linked Tracks (${linkedTracks.length})</div>
                        ${linkedTracksHtml}
                    </div>
                    <div class="mt-3 pt-3 border-top border-secondary">
                        <div class="small text-secondary mb-2">Search for more tracks to link...</div>
                    </div>
                `;
            } else {
                // There's a search query, prepend linked tracks to existing search results
                const existingContent = relatedList.innerHTML;
                if (existingContent && existingContent.includes('mp3-related-item')) {
                    // Extract search results (items that are not in linked tracks)
                    const linkedIds = linkedTracks.map(lt => lt.eventId);
                    const searchResultsHtml = existingContent;
                    
                    relatedList.innerHTML = `
                        <div class="mb-3">
                            <div class="small text-secondary mb-2"><i class="bi bi-link-45deg"></i> Linked Tracks (${linkedTracks.length})</div>
                            ${linkedTracksHtml}
                        </div>
                        <div class="mt-3 pt-3 border-top border-secondary">
                            <div class="small text-secondary mb-2">Search Results</div>
                            ${searchResultsHtml}
                        </div>
                    `;
                } else {
                    // No search results yet, show linked tracks
                    relatedList.innerHTML = `
                        <div class="mb-3">
                            <div class="small text-secondary mb-2"><i class="bi bi-link-45deg"></i> Linked Tracks (${linkedTracks.length})</div>
                            ${linkedTracksHtml}
                        </div>
                    `;
                }
            }
        }
        
        /**
         * Link a related track (create a reference/link)
         */
        async function linkRelatedTrack(eventId, trackTitle) {
            console.log('Linking track:', eventId, trackTitle);
            
            // Get current track
            const audioPlayer = document.getElementById('mp3AudioPlayer');
            const currentEventId = audioPlayer?.getAttribute('data-event-id');
            
            if (!currentEventId) {
                alert('Current track not found');
                return;
            }
            
            // Check if user is connected
            if (typeof userPubkey === 'undefined' || !userPubkey) {
                if (typeof connectNostr === 'function') {
                    try {
                        const pubkey = await connectNostr();
                        if (!pubkey) {
                            alert('Connection required to link tracks');
                            return;
                        }
                    } catch (error) {
                        console.error('Error connecting:', error);
                        alert('Error connecting');
                        return;
                    }
                } else {
                    alert('Connection required to link tracks');
                    return;
                }
            }
            
            // Create a link/reference event (kind 1 with tags)
            // This creates a reference between tracks
            try {
                const tags = [
                    ['e', currentEventId, '', 'root'], // Current track
                    ['e', eventId, '', 'reply'], // Linked track
                    ['k', '1063'], // Kind 1063 (MP3 file)
                    ['t', 'track-link'], // Topic tag
                    ['i', `source:linked`] // Source tag
                ];
                
                const content = `ðŸ”— Linked to: ${trackTitle}`;
                
                if (typeof publishNote === 'function') {
                    const result = await publishNote(content, tags, 1, { silent: false });
                    if (result && result.success) {
                        alert(`Track linked successfully!`);
                        
                        // Reload linked tracks to show the new link
                        const audioPlayer = document.getElementById('mp3AudioPlayer');
                        const currentEventId = audioPlayer?.getAttribute('data-event-id');
                        if (currentEventId) {
                            setTimeout(() => {
                                loadLinkedTracks(currentEventId);
                            }, 500);
                        }
                    } else {
                        alert('Error linking track');
                    }
                } else {
                    alert('Publish function not available');
                }
            } catch (error) {
                console.error('Error linking track:', error);
                alert('Error linking track: ' + error.message);
            }
        }

        /**
         * Load track from NOSTR event ID
         * Uses loadTrackFromEventId from nostrify.enhancements.js which already loads .info.json
         * Store global function reference before creating local alias
         */
        const globalLoadTrackFromEventId = (typeof window !== 'undefined' && typeof window.loadTrackFromEventId === 'function') 
            ? window.loadTrackFromEventId 
            : null;
        
        async function loadTrackFromEventId(eventId) {
            // Use function from nostrify.enhancements.js if available
            if (globalLoadTrackFromEventId) {
                return await globalLoadTrackFromEventId(eventId);
            }
            
            // Fallback: try to load basic track data
            throw new Error('loadTrackFromEventId function not available from nostrify.enhancements.js');
        }

        /**
         * Load comments for the track
         */
        async function loadMP3Comments(eventId, authorId, originalContent) {
            const commentsList = document.getElementById('mp3CommentsList');
            const commentStats = document.getElementById('mp3CommentStats');
            
            if (!commentsList || !eventId) {
                if (commentsList) {
                    commentsList.innerHTML = '<div class="no-comments">No comments available</div>';
                }
                return;
            }
            
            commentsList.innerHTML = '<div class="loading-comments">Loading comments...</div>';
            
            try {
                let currentRelay = window.nostrRelay || nostrRelay;
                
                if (!currentRelay || typeof currentRelay.sub !== 'function') {
                    if (typeof connectToRelay === 'function') {
                        console.log('ðŸ”Œ Connecting to relay for comments...');
                        await connectToRelay();
                        await new Promise(resolve => setTimeout(resolve, 500));
                    }
                    
                    currentRelay = window.nostrRelay || nostrRelay || currentRelay;
                    if (!currentRelay || typeof currentRelay.sub !== 'function') {
                        commentsList.innerHTML = '<div class="error-comments">NOSTR not connected</div>';
                        return;
                    }
                }
                
                // Initialize global comments array
                window.mp3Comments = [];
                const comments = window.mp3Comments;
                
                // Add original comment if available
                if (originalContent && originalContent.trim()) {
                    let authorName = 'Track Author';
                    
                    if (authorId) {
                        try {
                            if (typeof fetchUserMetadata !== 'undefined') {
                                const profile = await Promise.race([
                                    fetchUserMetadata(authorId),
                                    new Promise((_, reject) => setTimeout(() => reject(new Error('Timeout')), 1500))
                                ]);
                                if (profile) {
                                    authorName = profile.display_name || profile.name || authorName;
                                }
                            }
                        } catch (e) {
                            console.warn('Could not fetch profile:', e);
                        }
                    }
                    
                    comments.push({
                        id: eventId,
                        authorId: authorId,
                        authorName: authorName,
                        content: originalContent,
                        timestamp: null,
                        isOriginal: true,
                        created_at: null
                    });
                }
                
                // Fetch comments from NOSTR (kind 1111 - NIP-22 comments)
                const sub = currentRelay.sub([{
                    kinds: [1111],
                    '#E': [eventId]
                }]);
                
                window.currentMP3CommentSubscription = sub;
                
                let initialLoadComplete = false;
                const timeout = setTimeout(() => {
                    initialLoadComplete = true;
                    displayMP3Comments(comments, commentStats);
                    console.log('âœ… Initial comments loaded');
                }, 3000);
                
                const authorNameCache = new Map();
                
                sub.on('event', async (event) => {
                    try {
                        if (event.id === eventId) {
                            return; // Skip original event
                        }
                        
                        if (comments.find(c => c.id === event.id)) {
                            return; // Skip duplicates
                        }
                        
                        let authorName = authorNameCache.get(event.pubkey) || event.pubkey.substring(0, 8) + '...';
                        
                        if (!authorNameCache.has(event.pubkey) && typeof fetchUserMetadata !== 'undefined') {
                            try {
                                const profile = await Promise.race([
                                    fetchUserMetadata(event.pubkey),
                                    new Promise((_, reject) => setTimeout(() => reject(new Error('Timeout')), 1000))
                                ]);
                                if (profile) {
                                    authorName = profile.display_name || profile.name || authorName;
                                    authorNameCache.set(event.pubkey, authorName);
                                }
                            } catch (e) {
                                authorNameCache.set(event.pubkey, authorName);
                            }
                        } else if (authorNameCache.has(event.pubkey)) {
                            authorName = authorNameCache.get(event.pubkey);
                        }
                        
                        const newComment = {
                            id: event.id,
                            authorId: event.pubkey,
                            authorName: authorName,
                            content: event.content,
                            timestamp: null,
                            isOriginal: false,
                            created_at: event.created_at,
                            rawEvent: event
                        };
                        
                        comments.push(newComment);
                        
                        if (initialLoadComplete) {
                            displayMP3Comments(comments, commentStats);
                            
                            setTimeout(() => {
                                const commentsList = document.getElementById('mp3CommentsList');
                                if (commentsList) {
                                    const commentElements = commentsList.querySelectorAll('.mp3-comment-item:not(.original-comment)');
                                    const lastComment = commentElements[commentElements.length - 1];
                                    if (lastComment) {
                                        lastComment.classList.add('live-comment');
                                        lastComment.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
                                    }
                                }
                            }, 100);
                        }
                    } catch (e) {
                        console.error('Error processing comment:', e);
                    }
                });
                
                sub.on('eose', () => {
                    clearTimeout(timeout);
                    initialLoadComplete = true;
                    displayMP3Comments(comments, commentStats);
                    console.log('ðŸ“¡ Comment subscription active');
                });
                
            } catch (error) {
                console.error('Error loading comments:', error);
                commentsList.innerHTML = '<div class="error-comments">Error loading comments</div>';
            }
        }

        /**
         * Display comments
         */
        function displayMP3Comments(comments, commentStats) {
            const commentsList = document.getElementById('mp3CommentsList');
            if (!commentsList) return;
            
            if (comments.length === 0) {
                commentsList.innerHTML = '<div class="no-comments">No comments</div>';
                if (commentStats) {
                    commentStats.textContent = '0 comment(s)';
                }
                return;
            }
            
            if (commentStats) {
                commentStats.textContent = `${comments.length} comment${comments.length > 1 ? 's' : ''}`;
            }
            
            const escapeFn = typeof escapeHtml !== 'undefined' ? escapeHtml : (text) => {
                const div = document.createElement('div');
                div.textContent = text;
                return div.innerHTML;
            };
            
            const formatRelativeFn = typeof formatRelativeTime !== 'undefined' ? formatRelativeTime : (timestamp) => {
                const seconds = Math.floor((Date.now() / 1000) - timestamp);
                if (seconds < 60) return `${seconds}s ago`;
                if (seconds < 3600) return `${Math.floor(seconds / 60)}m ago`;
                if (seconds < 86400) return `${Math.floor(seconds / 3600)}h ago`;
                return `${Math.floor(seconds / 86400)}d ago`;
            };
            
            // Build comment tree
            const topLevel = [];
            const replies = new Map();
            
            comments.forEach(comment => {
                if (comment.isOriginal) {
                    topLevel.push(comment);
                    return;
                }
                
                const parentTag = comment.rawEvent?.tags?.find(t => t[0] === 'e');
                const parentId = parentTag ? parentTag[1] : null;
                
                if (parentId) {
                    if (!replies.has(parentId)) {
                        replies.set(parentId, []);
                    }
                    replies.get(parentId).push(comment);
                } else {
                    topLevel.push(comment);
                }
            });
            
            topLevel.sort((a, b) => {
                if (a.isOriginal) return -1;
                if (b.isOriginal) return 1;
                return (b.created_at || 0) - (a.created_at || 0);
            });
            
            replies.forEach(replyList => {
                replyList.sort((a, b) => (a.created_at || 0) - (b.created_at || 0));
            });
            
            // Render comments
            const html = topLevel.map(comment => renderMP3Comment(comment, replies, escapeFn, formatRelativeFn, 0)).join('');
            commentsList.innerHTML = html;
        }

        /**
         * Render a single comment with its replies
         */
        function renderMP3Comment(comment, repliesMap, escapeFn, formatRelativeFn, depth = 0) {
            const timeAgo = comment.created_at && formatRelativeFn ? formatRelativeFn(comment.created_at) : '';
            const openProfileFn = typeof openProfileModalInMP3 !== 'undefined' ? 'openProfileModalInMP3' :
                                 (typeof openProfileModal !== 'undefined' ? 'openProfileModal' : null);
            const authorLink = comment.authorId && openProfileFn
                ? `<a href="#" onclick="event.preventDefault(); ${openProfileFn}('${comment.authorId}', '${escapeFn(comment.authorName)}'); return false;" class="mp3-uploader-link">${escapeFn(comment.authorName)}</a>`
                : escapeFn(comment.authorName);
            
            const replies = repliesMap.get(comment.id) || [];
            const replyCount = replies.length;
            const isReply = depth > 0;
            const replyClass = isReply ? 'reply' : '';
            
            let html = `
                <div class="mp3-comment-item ${comment.isOriginal ? 'original-comment' : ''} ${replyClass}" data-comment-id="${comment.id}">
                    <div class="mp3-comment-author">${authorLink}</div>
                    <div class="mp3-comment-content">${escapeFn(comment.content)}</div>
                    <div class="mp3-comment-actions">
                        ${timeAgo ? `<span class="mp3-comment-time">${timeAgo}</span>` : ''}
                        ${replyCount > 0 ? `<span class="mp3-reply-count"><i class="bi bi-chat-dots"></i> ${replyCount} reply${replyCount > 1 ? 'ies' : ''}</span>` : ''}
                        <button class="mp3-comment-reply-btn" onclick="toggleMP3ReplyForm('${comment.id}')">
                            <i class="bi bi-reply"></i> Reply
                        </button>
                    </div>
                    
                    <div class="mp3-comment-reply-form" id="mp3-reply-form-${comment.id}">
                        <textarea 
                            class="form-control bg-dark text-white border-secondary mb-2"
                            placeholder="Reply to ${escapeFn(comment.authorName)}..."
                            rows="2"
                            id="mp3-reply-input-${comment.id}"></textarea>
                        <div class="d-flex gap-2 justify-content-end">
                            <button class="btn btn-sm btn-secondary" onclick="toggleMP3ReplyForm('${comment.id}')">
                                Cancel
                            </button>
                            <button class="btn btn-sm btn-primary" onclick="submitMP3Reply('${comment.id}', '${comment.authorId || ''}')">
                                <i class="bi bi-send"></i> Reply
                            </button>
                        </div>
                    </div>
            `;
            
            if (replyCount > 0) {
                html += '<div class="mp3-comment-replies">';
                replies.forEach(reply => {
                    html += renderMP3Comment(reply, repliesMap, escapeFn, formatRelativeFn, depth + 1);
                });
                html += '</div>';
            }
            
            html += '</div>';
            return html;
        }

        /**
         * Toggle reply form visibility
         */
        function toggleMP3ReplyForm(commentId) {
            const form = document.getElementById(`mp3-reply-form-${commentId}`);
            if (!form) return;
            
            document.querySelectorAll('.mp3-comment-reply-form.active').forEach(otherForm => {
                if (otherForm.id !== `mp3-reply-form-${commentId}`) {
                    otherForm.classList.remove('active');
                }
            });
            
            form.classList.toggle('active');
            
            if (form.classList.contains('active')) {
                const input = document.getElementById(`mp3-reply-input-${commentId}`);
                if (input) {
                    input.focus();
                }
            }
        }

        /**
         * Submit a reply to a comment
         */
        async function submitMP3Reply(parentCommentId, parentAuthorId) {
            const input = document.getElementById(`mp3-reply-input-${parentCommentId}`);
            const audioPlayer = document.getElementById('mp3AudioPlayer');
            
            if (!input || !audioPlayer) return;
            
            const rawContent = input.value.trim();
            if (!rawContent) {
                alert('Reply cannot be empty');
                return;
            }
            
            const content = rawContent.substring(0, 5000);
            
            const trackEventId = audioPlayer.getAttribute('data-event-id');
            const trackAuthorId = audioPlayer.getAttribute('data-author-id');
            
            if (!trackEventId) {
                alert('Track ID not found');
                return;
            }
            
            let nostrVars = getNostrVariables();
            let currentUserPubkey = nostrVars.userPubkey;
            let currentNostrRelay = nostrVars.nostrRelay;
            
            if (!currentUserPubkey) {
                const connectFn = (window.parent && window.parent !== window && typeof window.parent.connectNostr === 'function') 
                    ? window.parent.connectNostr 
                    : (typeof connectNostr === 'function' ? connectNostr : null);
                
                if (connectFn) {
                    try {
                        currentUserPubkey = await connectFn();
                        if (!currentUserPubkey) {
                            alert('You must be connected to reply');
                            return;
                        }
                        nostrVars.userPubkey = currentUserPubkey;
                    } catch (error) {
                        console.error('Error connecting:', error);
                        alert('Error connecting: ' + error.message);
                        return;
                    }
                } else {
                    alert('You must be connected to reply');
                    return;
                }
            }
            
            if (!currentNostrRelay || !nostrVars.isNostrConnected) {
                const connectRelayFn = (window.parent && window.parent !== window && typeof window.parent.connectToRelay === 'function')
                    ? window.parent.connectToRelay
                    : (typeof connectToRelay === 'function' ? connectToRelay : null);
                
                if (connectRelayFn) {
                    try {
                        currentNostrRelay = await connectRelayFn();
                        if (!currentNostrRelay) {
                            alert('Error connecting to relay');
                            return;
                        }
                        nostrVars.nostrRelay = currentNostrRelay;
                        nostrVars.isNostrConnected = true;
                    } catch (error) {
                        console.error('Error connecting to relay:', error);
                        alert('Error connecting to relay: ' + error.message);
                        return;
                    }
                } else {
                    alert('Relay connection not available');
                    return;
                }
            }
            
            try {
                const relayHint = currentNostrRelay?.url || '';
                
                const tags = [
                    ['E', trackEventId, relayHint, trackAuthorId || ''],
                    ['K', '1063'],
                    ['P', trackAuthorId || '', relayHint],
                    ['e', parentCommentId, relayHint, parentAuthorId || ''],
                    ['k', '1111'],
                    ['p', parentAuthorId || '', relayHint]
                ];
                
                const publishFn = (window.parent && window.parent !== window && typeof window.parent.publishNote === 'function')
                    ? window.parent.publishNote
                    : (typeof publishNote === 'function' ? publishNote : null);
                
                if (!publishFn) {
                    alert('Publish function not available');
                    return;
                }
                
                const result = await publishFn(content, tags, 1111, { silent: false });
                
                const publishedEvent = result?.event || result;
                const success = result && (result.success === true || result.id || publishedEvent?.id);
                
                if (success) {
                    input.value = '';
                    toggleMP3ReplyForm(parentCommentId);
                    
                    if (publishedEvent && publishedEvent.id && currentUserPubkey) {
                        let userName = currentUserPubkey.substring(0, 8) + '...';
                        const fetchUserMetadataFn = (window.parent && window.parent !== window && typeof window.parent.fetchUserMetadata === 'function')
                            ? window.parent.fetchUserMetadata
                            : (typeof fetchUserMetadata !== 'undefined' ? fetchUserMetadata : null);
                        
                        if (fetchUserMetadataFn) {
                            try {
                                const profile = await fetchUserMetadataFn(currentUserPubkey);
                                if (profile) {
                                    userName = profile.display_name || profile.name || userName;
                                }
                            } catch (e) {
                                console.warn('Could not fetch user metadata:', e);
                            }
                        }
                        
                        const newReply = {
                            id: publishedEvent.id,
                            authorId: currentUserPubkey,
                            authorName: userName,
                            content: content,
                            timestamp: null,
                            isOriginal: false,
                            created_at: publishedEvent.created_at || Math.floor(Date.now() / 1000),
                            rawEvent: publishedEvent
                        };
                        
                        if (typeof window.mp3Comments !== 'undefined') {
                            if (!window.mp3Comments.find(c => c.id === newReply.id)) {
                                window.mp3Comments.push(newReply);
                                
                                const commentsList = document.getElementById('mp3CommentsList');
                                const commentStats = document.getElementById('mp3CommentStats');
                                if (typeof displayMP3Comments === 'function') {
                                    displayMP3Comments(window.mp3Comments, commentStats);
                                    
                                    setTimeout(() => {
                                        if (commentsList) {
                                            const replyElement = commentsList.querySelector(`[data-comment-id="${newReply.id}"]`);
                                            if (replyElement) {
                                                replyElement.classList.add('live-comment');
                                                replyElement.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
                                            }
                                        }
                                    }, 100);
                                }
                            }
                        }
                    }
                    
                    console.log('âœ… Reply published successfully');
                } else {
                    alert('âŒ Error publishing reply');
                }
            } catch (error) {
                console.error('Error submitting reply:', error);
                alert('Error publishing reply: ' + error.message);
            }
        }

        /**
         * Submit a comment
         */
        async function submitMP3Comment() {
            const input = document.getElementById('mp3CommentInput');
            const audioPlayer = document.getElementById('mp3AudioPlayer');
            
            if (!input || !audioPlayer) return;
            
            const rawContent = input.value.trim();
            if (!rawContent) {
                alert('Comment cannot be empty');
                return;
            }
            
            const content = rawContent.substring(0, 5000);
            
            const eventId = audioPlayer.getAttribute('data-event-id');
            const authorId = audioPlayer.getAttribute('data-author-id');
            
            if (!eventId) {
                alert('Track ID not found');
                return;
            }
            
            let nostrVars = getNostrVariables();
            let currentUserPubkey = nostrVars.userPubkey;
            let currentNostrRelay = nostrVars.nostrRelay;
            
            if (!currentUserPubkey) {
                const connectFn = (window.parent && window.parent !== window && typeof window.parent.connectNostr === 'function') 
                    ? window.parent.connectNostr 
                    : (typeof connectNostr === 'function' ? connectNostr : null);
                
                if (connectFn) {
                    try {
                        currentUserPubkey = await connectFn();
                        if (!currentUserPubkey) {
                            alert('You must be connected to comment');
                            return;
                        }
                        nostrVars.userPubkey = currentUserPubkey;
                    } catch (error) {
                        console.error('Error connecting:', error);
                        alert('Error connecting: ' + error.message);
                        return;
                    }
                } else {
                    alert('You must be connected to comment');
                    return;
                }
            }
            
            if (!currentNostrRelay || !nostrVars.isNostrConnected) {
                const connectRelayFn = (window.parent && window.parent !== window && typeof window.parent.connectToRelay === 'function')
                    ? window.parent.connectToRelay
                    : (typeof connectToRelay === 'function' ? connectToRelay : null);
                
                if (connectRelayFn) {
                    try {
                        currentNostrRelay = await connectRelayFn();
                        if (!currentNostrRelay) {
                            alert('Error connecting to relay');
                            return;
                        }
                        nostrVars.nostrRelay = currentNostrRelay;
                        nostrVars.isNostrConnected = true;
                    } catch (error) {
                        console.error('Error connecting to relay:', error);
                        alert('Error connecting to relay: ' + error.message);
                        return;
                    }
                } else {
                    alert('Relay connection not available');
                    return;
                }
            }
            
            try {
                const relayHint = currentNostrRelay?.url || '';
                
                const tags = [
                    ['E', eventId, relayHint, authorId || ''],
                    ['K', '1063'],
                    ['P', authorId || '', relayHint],
                    ['e', eventId, relayHint, authorId || ''],
                    ['k', '1063'],
                    ['p', authorId || '', relayHint]
                ];
                
                const publishFn = (window.parent && window.parent !== window && typeof window.parent.publishNote === 'function')
                    ? window.parent.publishNote
                    : (typeof publishNote === 'function' ? publishNote : null);
                
                if (!publishFn) {
                    alert('Publish function not available');
                    return;
                }
                
                const result = await publishFn(content, tags, 1111, { silent: false });
                
                const publishedEvent = result?.event || result;
                const success = result && (result.success === true || result.id || publishedEvent?.id);
                
                if (success) {
                    input.value = '';
                    
                    if (publishedEvent && publishedEvent.id && currentUserPubkey) {
                        let userName = currentUserPubkey.substring(0, 8) + '...';
                        const fetchUserMetadataFn = (window.parent && window.parent !== window && typeof window.parent.fetchUserMetadata === 'function')
                            ? window.parent.fetchUserMetadata
                            : (typeof fetchUserMetadata !== 'undefined' ? fetchUserMetadata : null);
                        
                        if (fetchUserMetadataFn) {
                            try {
                                const profile = await fetchUserMetadataFn(currentUserPubkey);
                                if (profile) {
                                    userName = profile.display_name || profile.name || userName;
                                }
                            } catch (e) {
                                console.warn('Could not fetch user metadata:', e);
                            }
                        }
                        
                        const newComment = {
                            id: publishedEvent.id,
                            authorId: currentUserPubkey,
                            authorName: userName,
                            content: content,
                            timestamp: null,
                            isOriginal: false,
                            created_at: publishedEvent.created_at || Math.floor(Date.now() / 1000),
                            rawEvent: publishedEvent
                        };
                        
                        if (typeof window.mp3Comments !== 'undefined') {
                            if (!window.mp3Comments.find(c => c.id === newComment.id)) {
                                window.mp3Comments.push(newComment);
                                
                                const commentsList = document.getElementById('mp3CommentsList');
                                const commentStats = document.getElementById('mp3CommentStats');
                                if (typeof displayMP3Comments === 'function') {
                                    displayMP3Comments(window.mp3Comments, commentStats);
                                    
                                    setTimeout(() => {
                                        if (commentsList) {
                                            const commentElements = commentsList.querySelectorAll('.mp3-comment-item:not(.original-comment)');
                                            const lastComment = commentElements[commentElements.length - 1];
                                            if (lastComment) {
                                                lastComment.classList.add('live-comment');
                                                lastComment.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
                                            }
                                        }
                                    }, 100);
                                }
                            }
                        }
                    }
                    
                    const submitBtn = document.getElementById('submitMP3CommentBtn');
                    const originalText = submitBtn?.textContent || 'Publish';
                    if (submitBtn) {
                        submitBtn.textContent = 'âœ… Published!';
                        submitBtn.disabled = true;
                        setTimeout(() => {
                            submitBtn.textContent = originalText;
                            submitBtn.disabled = false;
                        }, 2000);
                    }
                } else {
                    alert('âŒ Error publishing comment');
                }
            } catch (error) {
                console.error('Error submitting comment:', error);
                alert('Error publishing comment: ' + error.message);
            }
        }

        /**
         * Handle like button click
         */
        async function handleMP3Like() {
            const audioPlayer = document.getElementById('mp3AudioPlayer');
            if (!audioPlayer) {
                alert('Track not found');
                return;
            }
            
            const eventId = audioPlayer.getAttribute('data-event-id');
            const authorId = audioPlayer.getAttribute('data-author-id');
            
            if (!eventId) {
                alert('Track ID not found');
                return;
            }
            
            if (typeof userPubkey === 'undefined' || !userPubkey) {
                if (typeof connectNostr === 'function') {
                    try {
                        const pubkey = await connectNostr();
                        if (!pubkey) {
                            alert('âŒ Connection required to like. Please connect with NOSTR.');
                            return;
                        }
                    } catch (error) {
                        console.error('Error connecting:', error);
                        alert('âŒ Error connecting. Please connect manually.');
                        return;
                    }
                } else {
                    alert('âŒ Connection required to like.');
                    return;
                }
            }
            
            if (typeof isNostrConnected !== 'undefined' && !isNostrConnected) {
                if (typeof connectToRelay === 'function') {
                    try {
                        await connectToRelay();
                    } catch (error) {
                        console.error('Error connecting to relay:', error);
                        alert('âŒ Error connecting to relay.');
                        return;
                    }
                }
            }
            
            const likeBtn = document.getElementById('mp3LikeBtn');
            const originalHtml = likeBtn ? likeBtn.innerHTML : '';
            
            if (likeBtn) {
                likeBtn.disabled = true;
                likeBtn.innerHTML = '<i class="bi bi-hourglass-split"></i>';
            }
            
            try {
                if (typeof sendLike === 'function') {
                    const result = await sendLike(eventId, authorId, '+');
                    if (result) {
                        if (likeBtn) {
                            likeBtn.innerHTML = '<i class="bi bi-hand-thumbs-up-fill text-success"></i>';
                            setTimeout(() => {
                                likeBtn.innerHTML = originalHtml;
                                likeBtn.disabled = false;
                            }, 2000);
                        }
                        
                        const likeCountEl = document.getElementById('likeCount');
                        if (likeCountEl) {
                            const currentCount = parseInt(likeCountEl.textContent || '0');
                            likeCountEl.textContent = currentCount + 1;
                        }
                    } else {
                        throw new Error('Failed to send like');
                    }
                } else {
                    throw new Error('sendLike function not available');
                }
            } catch (error) {
                console.error('Error liking track:', error);
                alert('Error liking track: ' + error.message);
                if (likeBtn) {
                    likeBtn.innerHTML = originalHtml;
                    likeBtn.disabled = false;
                }
            }
        }

        /**
         * Handle follow button click
         */
        async function handleMP3Follow() {
            const audioPlayer = document.getElementById('mp3AudioPlayer');
            if (!audioPlayer) {
                alert('Track not found');
                return;
            }
            
            const authorId = audioPlayer.getAttribute('data-author-id');
            
            if (!authorId) {
                alert('Author not found');
                return;
            }
            
            const followBtn = document.getElementById('mp3FollowBtn');
            const followText = document.getElementById('mp3FollowText');
            const originalHtml = followBtn ? followBtn.innerHTML : '';
            
            if (followBtn) {
                followBtn.disabled = true;
                followBtn.innerHTML = '<i class="bi bi-hourglass-split"></i> ...';
            }
            
            try {
                if (typeof toggleUserFollow === 'function') {
                    const result = await toggleUserFollow(authorId, {
                        silent: false,
                        onSuccess: (action, newFollowList) => {
                            if (followBtn && followText) {
                                if (action === 'follow') {
                                    followBtn.classList.remove('btn-outline-info');
                                    followBtn.classList.add('btn-info');
                                    followText.textContent = 'Following';
                                    followBtn.innerHTML = '<i class="bi bi-person-check-fill"></i> <span id="mp3FollowText">Following</span>';
                                } else {
                                    followBtn.classList.remove('btn-info');
                                    followBtn.classList.add('btn-outline-info');
                                    followText.textContent = 'Follow';
                                    followBtn.innerHTML = '<i class="bi bi-person-plus"></i> <span id="mp3FollowText">Follow</span>';
                                }
                                
                                setTimeout(() => {
                                    followBtn.disabled = false;
                                }, 500);
                            }
                        },
                        onError: (error) => {
                            console.error('Error in toggleUserFollow:', error);
                            if (followBtn) {
                                followBtn.innerHTML = originalHtml;
                                followBtn.disabled = false;
                            }
                        }
                    });
                    
                    if (!result || !result.success) {
                        throw new Error(result?.error || 'Failed to update follow list');
                    }
                } else {
                    throw new Error('toggleUserFollow function not available from common.js');
                }
            } catch (error) {
                console.error('Error following/unfollowing:', error);
                alert('Error updating: ' + error.message);
                if (followBtn) {
                    followBtn.innerHTML = originalHtml;
                    followBtn.disabled = false;
                }
            }
        }

        /**
         * Handle share button click
         */
        async function handleMP3Share() {
            const audioPlayer = document.getElementById('mp3AudioPlayer');
            if (!audioPlayer) {
                alert('Track not found');
                return;
            }
            
            const eventId = audioPlayer.getAttribute('data-event-id');
            const titleEl = document.getElementById('mp3Title');
            const title = titleEl ? titleEl.textContent : 'Track';
            
            // Get current URL
            const currentUrl = window.location.href;
            const shareUrl = eventId ? `${window.location.origin}/mp3-modal?track=${eventId}` : currentUrl;
            
            // Try Web Share API first
            if (navigator.share) {
                try {
                    await navigator.share({
                        title: title,
                        text: `Check out this track: ${title}`,
                        url: shareUrl
                    });
                    return;
                } catch (error) {
                    if (error.name !== 'AbortError') {
                        console.warn('Web Share API failed:', error);
                    } else {
                        return; // User cancelled
                    }
                }
            }
            
            // Fallback: copy to clipboard
            try {
                await navigator.clipboard.writeText(shareUrl);
                alert('Link copied to clipboard!');
            } catch (error) {
                console.error('Error copying to clipboard:', error);
                // Final fallback: show URL
                prompt('Share this link:', shareUrl);
            }
        }

        /**
         * Get NOSTR variables from parent or current window
         */
        function getNostrVariables() {
            let parentUserPubkey = null;
            let parentNostrRelay = null;
            let parentIsNostrConnected = false;
            
            if (window.parent && window.parent !== window) {
                try {
                    parentUserPubkey = window.parent.userPubkey || window.parent.window?.userPubkey;
                    parentNostrRelay = window.parent.nostrRelay || window.parent.window?.nostrRelay;
                    parentIsNostrConnected = window.parent.isNostrConnected || window.parent.window?.isNostrConnected || false;
                } catch (e) {
                    console.warn('âš ï¸ Could not access parent window variables:', e);
                }
            }
            
            return {
                userPubkey: parentUserPubkey || (typeof userPubkey !== 'undefined' ? userPubkey : null),
                nostrRelay: parentNostrRelay || (typeof nostrRelay !== 'undefined' ? nostrRelay : null),
                isNostrConnected: parentIsNostrConnected || (typeof isNostrConnected !== 'undefined' ? isNostrConnected : false)
            };
        }

        /**
         * Update follow button status
         */
        async function updateMP3FollowButtonStatus(authorId) {
            const followBtn = document.getElementById('mp3FollowBtn');
            const followText = document.getElementById('mp3FollowText');
            
            if (!followBtn || !authorId) return;
            
            if (typeof userPubkey === 'undefined' || !userPubkey || userPubkey === authorId) {
                followBtn.style.display = 'none';
                return;
            }
            
            followBtn.style.display = 'inline-block';
            followBtn.classList.remove('btn-info');
            followBtn.classList.add('btn-outline-info');
            if (followText) {
                followText.textContent = 'Follow';
            }
            
            try {
                const currentRelay = window.nostrRelay || nostrRelay;
                if (currentRelay && typeof currentRelay.sub === 'function') {
                    const followListPromise = new Promise((resolve) => {
                        const sub = currentRelay.sub([{
                            kinds: [3],
                            authors: [userPubkey],
                            limit: 1
                        }]);
                        
                        let followEvent = null;
                        
                        sub.on('event', (event) => {
                            followEvent = event;
                        });
                        
                        sub.on('eose', () => {
                            sub.unsub();
                            resolve(followEvent);
                        });
                        
                        setTimeout(() => {
                            sub.unsub();
                            resolve(followEvent);
                        }, 2000);
                    });
                    
                    const followEvent = await followListPromise;
                    
                    if (followEvent && followEvent.tags) {
                        const followList = followEvent.tags
                            .filter(tag => tag[0] === 'p' && tag[1])
                            .map(tag => tag[1]);
                        
                        const isFollowing = followList.includes(authorId);
                        
                        if (isFollowing) {
                            followBtn.classList.remove('btn-outline-info');
                            followBtn.classList.add('btn-info');
                            if (followText) {
                                followText.textContent = 'Following';
                            }
                            followBtn.innerHTML = '<i class="bi bi-person-check-fill"></i> <span id="mp3FollowText">Following</span>';
                        }
                    }
                }
            } catch (error) {
                console.warn('Could not check follow status:', error);
            }
        }

        /**
         * Load track author information
         */
        async function loadMP3Author(authorId, artistName) {
            const artistContainer = document.getElementById('mp3ArtistContainer');
            if (!artistContainer) return;
            
            const artistEl = document.getElementById('mp3Artist');
            let displayName = artistName || 'Unknown Artist';
            
            if (artistEl) {
                const existingName = artistEl.textContent || artistEl.innerText;
                if (existingName && existingName !== 'Loading...' && existingName.trim()) {
                    displayName = existingName.trim();
                }
            }
            
            const escapeFn = typeof escapeHtml !== 'undefined' ? escapeHtml : (text) => {
                const div = document.createElement('div');
                div.textContent = text;
                return div.innerHTML;
            };
            
            if (authorId) {
                const link = document.createElement('a');
                link.href = '#';
                link.className = 'mp3-uploader-link';
                link.textContent = displayName;
                link.onclick = function(e) {
                    e.preventDefault();
                    openProfileModalInMP3(authorId, displayName);
                    return false;
                };
                artistContainer.innerHTML = '';
                artistContainer.appendChild(link);
                
                if (artistEl && artistEl !== artistContainer) {
                    artistEl.textContent = displayName;
                }
                
                updateMP3FollowButtonStatus(authorId);
                
                try {
                    if (typeof fetchUserMetadata !== 'undefined') {
                        const profile = await Promise.race([
                            fetchUserMetadata(authorId),
                            new Promise((_, reject) => setTimeout(() => reject(new Error('Timeout')), 2000))
                        ]);
                        if (profile) {
                            let newDisplayName = displayName;
                            if (profile.display_name) {
                                newDisplayName = profile.display_name;
                            } else if (profile.name) {
                                newDisplayName = profile.name;
                            }
                            
                            if (newDisplayName !== displayName) {
                                displayName = newDisplayName;
                                link.textContent = displayName;
                                if (artistEl && artistEl !== artistContainer) {
                                    artistEl.textContent = displayName;
                                }
                            }
                        }
                    }
                } catch (error) {
                    console.warn('Could not fetch author profile:', error);
                }
            } else {
                artistContainer.innerHTML = `<strong>${escapeFn(displayName)}</strong>`;
                if (artistEl && artistEl !== artistContainer) {
                    artistEl.textContent = displayName;
                }
            }
        }

        /**
         * Open profile modal
         */
        async function openProfileModalInMP3(authorId, userName = 'Profile') {
            let ipfsGateway = '';
            if (window.IPFS_GATEWAY) {
                ipfsGateway = window.IPFS_GATEWAY;
            } else if (typeof detectIPFSGatewayGlobal === 'function') {
                detectIPFSGatewayGlobal();
                ipfsGateway = window.IPFS_GATEWAY || 'https://ipfs.copylaradio.com';
            } else {
                const currentURL = new URL(window.location.href);
                const hostname = currentURL.hostname;
                if (hostname === '127.0.0.1' || hostname === 'localhost') {
                    ipfsGateway = 'http://127.0.0.1:8080';
                } else if (hostname.startsWith('u.')) {
                    const baseDomain = hostname.substring('u.'.length);
                    ipfsGateway = `${currentURL.protocol}//ipfs.${baseDomain}`;
                } else {
                    ipfsGateway = 'https://ipfs.copylaradio.com';
                }
            }
            
            const profileUrl = `${ipfsGateway}/ipns/copylaradio.com/nostr_profile_viewer.html?hex=${authorId}`;
            
            let modal = document.getElementById('iframe-modal');
            if (!modal && typeof window.parent !== 'undefined' && window.parent.document) {
                modal = window.parent.document.getElementById('iframe-modal');
            }
            
            if (modal) {
                const iframe = modal.querySelector('#iframe-modal-iframe') || modal.querySelector('iframe');
                const titleEl = modal.querySelector('#iframe-modal-title') || modal.querySelector('h3');
                const openNewBtn = modal.querySelector('#iframe-modal-open-new');
                
                if (iframe) {
                    if (iframe.dataset) {
                        iframe.dataset.currentUrl = profileUrl;
                    } else {
                        iframe.setAttribute('data-current-url', profileUrl);
                    }
                    iframe.src = profileUrl;
                }
                if (titleEl) {
                    titleEl.textContent = `ðŸ‘¤ ${userName}`;
                }
                
                if (openNewBtn) {
                    openNewBtn.style.display = 'flex';
                }
                
                modal.style.zIndex = '10002';
                modal.style.display = 'flex';
                
                const body = modal.ownerDocument.body;
                if (body) {
                    body.style.overflow = 'hidden';
                }
            } else if (typeof openProfileModal !== 'undefined') {
                openProfileModal(authorId, userName);
            } else if (typeof window.parent !== 'undefined' && typeof window.parent.openProfileModal === 'function') {
                window.parent.openProfileModal(authorId, userName);
            } else {
                window.open(profileUrl, '_blank');
            }
        }

        // Initialize Bootstrap tooltips and event listeners
        document.addEventListener('DOMContentLoaded', function() {
            // Initialize tooltips
            const tooltipTriggerList = [].slice.call(document.querySelectorAll('[data-bs-toggle="tooltip"]'));
            tooltipTriggerList.map(function (tooltipTriggerEl) {
                return new bootstrap.Tooltip(tooltipTriggerEl);
            });
            
            // Attach event listeners to buttons
            const likeBtn = document.getElementById('mp3LikeBtn');
            if (likeBtn) {
                likeBtn.addEventListener('click', handleMP3Like);
            }
            
            const followBtn = document.getElementById('mp3FollowBtn');
            if (followBtn) {
                followBtn.addEventListener('click', handleMP3Follow);
            }
            
            const shareBtn = document.getElementById('mp3ShareBtn');
            if (shareBtn) {
                shareBtn.addEventListener('click', handleMP3Share);
            }
            
            const submitCommentBtn = document.getElementById('submitMP3CommentBtn');
            if (submitCommentBtn) {
                submitCommentBtn.addEventListener('click', submitMP3Comment);
            }
        });

        /**
         * Initialize NOSTR connection for standalone mode
         */
        async function initNostrConnectionStandalone() {
            const isInIframe = window.self !== window.top;
            
            if (isInIframe && window.parent && window.parent !== window) {
                try {
                    if (window.parent.userPubkey) {
                        userPubkey = window.parent.userPubkey;
                        nostrRelay = window.parent.nostrRelay || null;
                        isNostrConnected = window.parent.isNostrConnected || false;
                        
                        if (typeof window !== 'undefined') {
                            window.userPubkey = userPubkey;
                            window.nostrRelay = nostrRelay;
                            window.isNostrConnected = isNostrConnected;
                        }
                        
                        console.log('[MP3-MODAL] âœ… Using connection from parent window');
                        return;
                    }
                } catch (e) {
                    console.warn('[MP3-MODAL] âš ï¸ Could not access parent window variables:', e);
                }
            }
            
            if (!nostrRelay || !isNostrConnected) {
                console.log('[MP3-MODAL] ðŸ”Œ Standalone mode - connecting to relay (anonymous)...');
                
                try {
                    if (typeof connectToRelay === 'function') {
                        nostrRelay = await connectToRelay(false);
                        isNostrConnected = nostrRelay !== null;
                        if (nostrRelay && typeof window !== 'undefined') {
                            window.nostrRelay = nostrRelay;
                            window.isNostrConnected = isNostrConnected;
                        }
                        console.log('[MP3-MODAL] âœ… Connected to relay (anonymous mode)');
                    }
                } catch (error) {
                    console.error('[MP3-MODAL] âŒ Error connecting to relay:', error);
                }
            }
        }
        
        // Initialize NOSTR connection on page load
        document.addEventListener('DOMContentLoaded', async function() {
            await initNostrConnectionStandalone();
            
            // Initialize modal if trackData is passed
            if (window.trackData) {
                initializeMP3Modal(window.trackData);
                return;
            }
            
            // Check if track parameter is in URL and load it automatically
            const urlParams = new URLSearchParams(window.location.search);
            const trackIdParam = urlParams.get('track');
            const trackIdTemplate = '{{ track_id if track_id else "" }}';
            const trackId = trackIdParam || trackIdTemplate;
            
            if (trackId && trackId.trim() && !window.trackData) {
                console.log('ðŸŽµ Loading track from URL parameter:', trackId);
                try {
                    const track = await loadTrackFromEventId(trackId);
                    if (track) {
                        initializeMP3Modal(track);
                    }
                } catch (error) {
                    console.error('Error loading track:', error);
                    const titleElement = document.getElementById('mp3Title');
                    if (titleElement) {
                        titleElement.textContent = 'Error loading track';
                    }
                }
            }
        });
        
        // Listen for close messages from parent
        window.addEventListener('message', function(event) {
            if (event.data && event.data.type === 'close-mp3-modal') {
                handleCloseMP3Modal();
            }
        });
        
        // Listen for ESC key
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape') {
                handleCloseMP3Modal();
            }
        });

        /**
         * Initialize Mixxx Mode - collaborative playlist building
         */
        async function initializeMixxxMode() {
            const audioPlayer = document.getElementById('mp3AudioPlayer');
            const currentEventId = audioPlayer?.getAttribute('data-event-id');
            
            if (!currentEventId) {
                console.warn('No track event ID available for Mixxx mode');
                return;
            }
            
            // Load connected users and suggestions
            await loadMixxxConnectedUsers(currentEventId);
            await loadMixxxSuggestions(currentEventId);
            await loadMixxxVJSuggestions(currentEventId);
            
            // Setup search for suggesting tracks
            setupMixxxTrackSearch();
            
            // Setup search for suggesting VJ videos
            setupMixxxVJSearch();
        }
        
        /**
         * Load connected users (MULTIPASS) viewing this track
         */
        async function loadMixxxConnectedUsers(eventId) {
            const usersList = document.getElementById('mixxxUsersList');
            const usersCount = document.getElementById('mixxxUsersCount');
            
            if (!usersList) return;
            
            try {
                let currentRelay = window.nostrRelay || nostrRelay;
                
                if (!currentRelay || typeof currentRelay.sub !== 'function') {
                    if (typeof connectToRelay === 'function') {
                        await connectToRelay();
                        await new Promise(resolve => setTimeout(resolve, 500));
                    }
                    currentRelay = window.nostrRelay || nostrRelay;
                }
                
                if (!currentRelay || typeof currentRelay.sub !== 'function') {
                    usersList.innerHTML = '<div class="text-center text-secondary py-3 small">NOSTR not connected</div>';
                    return;
                }
                
                // Subscribe to presence events (kind 1 with special tag)
                // Users can publish a presence event when viewing a track
                const presenceSub = currentRelay.sub([{
                    kinds: [1],
                    '#t': ['mixxx:presence'],
                    '#e': [eventId],
                    limit: 50
                }]);
                
                const connectedUsers = new Map();
                const userMetadataCache = new Map();
                
                presenceSub.on('event', async (event) => {
                    try {
                        if (connectedUsers.has(event.pubkey)) return;
                        
                        let userName = userMetadataCache.get(event.pubkey) || event.pubkey.substring(0, 8) + '...';
                        
                        if (!userMetadataCache.has(event.pubkey) && typeof fetchUserMetadata !== 'undefined') {
                            try {
                                const profile = await Promise.race([
                                    fetchUserMetadata(event.pubkey),
                                    new Promise((_, reject) => setTimeout(() => reject(new Error('Timeout')), 1000))
                                ]);
                                if (profile) {
                                    userName = profile.display_name || profile.name || userName;
                                    userMetadataCache.set(event.pubkey, userName);
                                }
                            } catch (e) {
                                userMetadataCache.set(event.pubkey, userName);
                            }
                        }
                        
                        connectedUsers.set(event.pubkey, {
                            pubkey: event.pubkey,
                            name: userName,
                            timestamp: event.created_at
                        });
                        
                        renderMixxxUsers(Array.from(connectedUsers.values()));
                    } catch (e) {
                        console.error('Error processing presence event:', e);
                    }
                });
                
                presenceSub.on('eose', () => {
                    console.log('âœ… Mixxx presence subscription active');
                });
                
                // Publish our own presence
                if (typeof userPubkey !== 'undefined' && userPubkey) {
                    publishMixxxPresence(eventId);
                }
                
                // Store subscription for cleanup
                window.currentMixxxPresenceSubscription = presenceSub;
                
            } catch (error) {
                console.error('Error loading connected users:', error);
                usersList.innerHTML = '<div class="text-center text-secondary py-3 small">Error loading users</div>';
            }
        }
        
        /**
         * Publish presence event to show we're viewing this track
         */
        async function publishMixxxPresence(eventId) {
            try {
                const nostrVars = getNostrVariables();
                let currentUserPubkey = nostrVars.userPubkey;
                let currentNostrRelay = nostrVars.nostrRelay;
                
                if (!currentUserPubkey) {
                    if (typeof connectNostr === 'function') {
                        currentUserPubkey = await connectNostr();
                    }
                }
                
                if (!currentUserPubkey) return;
                
                if (!currentNostrRelay || !nostrVars.isNostrConnected) {
                    if (typeof connectToRelay === 'function') {
                        currentNostrRelay = await connectToRelay();
                    }
                }
                
                if (!currentNostrRelay) return;
                
                const relayHint = currentNostrRelay?.url || '';
                const tags = [
                    ['t', 'mixxx:presence'],
                    ['e', eventId, relayHint],
                    ['k', '1063']
                ];
                
                const publishFn = (window.parent && window.parent !== window && typeof window.parent.publishNote === 'function')
                    ? window.parent.publishNote
                    : (typeof publishNote === 'function' ? publishNote : null);
                
                if (publishFn) {
                    await publishFn('ðŸŽ§ Listening in Mixxx mode', tags, 1, { silent: true });
                }
            } catch (error) {
                console.warn('Could not publish presence:', error);
            }
        }
        
        /**
         * Render connected users list
         */
        function renderMixxxUsers(users) {
            const usersList = document.getElementById('mixxxUsersList');
            const usersCount = document.getElementById('mixxxUsersCount');
            
            if (!usersList) return;
            
            if (users.length === 0) {
                usersList.innerHTML = '<div class="text-center text-secondary py-3 small">No other DJs connected</div>';
                if (usersCount) usersCount.textContent = '0';
                return;
            }
            
            if (usersCount) usersCount.textContent = users.length.toString();
            
            const escapeFn = typeof escapeHtml !== 'undefined' ? escapeHtml : (text) => {
                const div = document.createElement('div');
                div.textContent = text;
                return div.innerHTML;
            };
            
            usersList.innerHTML = users.map(user => `
                <div class="mp3-mixxx-user-badge" title="${escapeFn(user.name)}">
                    <i class="bi bi-person-circle"></i>
                    <span>${escapeFn(user.name)}</span>
                </div>
            `).join('');
        }
        
        /**
         * Load Mixxx suggestions (kind 1111 comments with mixxx:suggest tag)
         */
        async function loadMixxxSuggestions(eventId) {
            const suggestionsList = document.getElementById('mp3MixxxSuggestionsList');
            const suggestionsCount = document.getElementById('mixxxSuggestionsCount');
            
            if (!suggestionsList) return;
            
            try {
                let currentRelay = window.nostrRelay || nostrRelay;
                
                if (!currentRelay || typeof currentRelay.sub !== 'function') {
                    if (typeof connectToRelay === 'function') {
                        await connectToRelay();
                        await new Promise(resolve => setTimeout(resolve, 500));
                    }
                    currentRelay = window.nostrRelay || nostrRelay;
                }
                
                if (!currentRelay || typeof currentRelay.sub !== 'function') {
                    suggestionsList.innerHTML = '<div class="text-center text-secondary py-5 small">NOSTR not connected</div>';
                    return;
                }
                
                // Subscribe to mixxx suggestions (kind 1111 with mixxx:suggest tag)
                const suggestionsSub = currentRelay.sub([{
                    kinds: [1111],
                    '#E': [eventId],
                    '#t': ['mixxx:suggest']
                }]);
                
                const suggestions = [];
                const userMetadataCache = new Map();
                
                suggestionsSub.on('event', async (event) => {
                    try {
                        // Extract suggested track eventId from tags
                        const nextTag = event.tags.find(t => t[0] === 'next' || t[0] === 'suggest');
                        const suggestedEventId = nextTag ? nextTag[1] : null;
                        
                        if (!suggestedEventId) return;
                        
                        // Check if already in list
                        if (suggestions.find(s => s.id === event.id)) return;
                        
                        let userName = userMetadataCache.get(event.pubkey) || event.pubkey.substring(0, 8) + '...';
                        
                        if (!userMetadataCache.has(event.pubkey) && typeof fetchUserMetadata !== 'undefined') {
                            try {
                                const profile = await Promise.race([
                                    fetchUserMetadata(event.pubkey),
                                    new Promise((_, reject) => setTimeout(() => reject(new Error('Timeout')), 1000))
                                ]);
                                if (profile) {
                                    userName = profile.display_name || profile.name || userName;
                                    userMetadataCache.set(event.pubkey, userName);
                                }
                            } catch (e) {
                                userMetadataCache.set(event.pubkey, userName);
                            }
                        }
                        
                        // Load suggested track metadata
                        let trackData = null;
                        try {
                            trackData = await loadTrackFromEventId(suggestedEventId);
                        } catch (e) {
                            console.warn('Could not load suggested track:', e);
                        }
                        
                        suggestions.push({
                            id: event.id,
                            authorId: event.pubkey,
                            authorName: userName,
                            suggestedEventId: suggestedEventId,
                            trackData: trackData,
                            content: event.content || '',
                            created_at: event.created_at,
                            rawEvent: event
                        });
                        
                        // Sort by timestamp (newest first)
                        suggestions.sort((a, b) => (b.created_at || 0) - (a.created_at || 0));
                        
                        renderMixxxSuggestions(suggestions, suggestionsCount);
                    } catch (e) {
                        console.error('Error processing suggestion:', e);
                    }
                });
                
                suggestionsSub.on('eose', () => {
                    console.log('âœ… Mixxx suggestions subscription active');
                });
                
                // Store subscription for cleanup
                window.currentMixxxSuggestionsSubscription = suggestionsSub;
                
            } catch (error) {
                console.error('Error loading suggestions:', error);
                suggestionsList.innerHTML = '<div class="text-center text-secondary py-5 small">Error loading suggestions</div>';
            }
        }
        
        /**
         * Render Mixxx suggestions
         */
        function renderMixxxSuggestions(suggestions, suggestionsCount) {
            const suggestionsList = document.getElementById('mp3MixxxSuggestionsList');
            
            if (!suggestionsList) return;
            
            if (suggestions.length === 0) {
                suggestionsList.innerHTML = '<div class="text-center text-secondary py-5 small">No suggestions yet. Be the first to suggest a track!</div>';
                if (suggestionsCount) suggestionsCount.textContent = '0';
                return;
            }
            
            if (suggestionsCount) suggestionsCount.textContent = suggestions.length.toString();
            
            const escapeFn = typeof escapeHtml !== 'undefined' ? escapeHtml : (text) => {
                const div = document.createElement('div');
                div.textContent = text;
                return div.innerHTML;
            };
            
            const formatRelativeFn = typeof formatRelativeTime !== 'undefined' ? formatRelativeTime : (timestamp) => {
                const seconds = Math.floor((Date.now() / 1000) - timestamp);
                if (seconds < 60) return `${seconds}s ago`;
                if (seconds < 3600) return `${Math.floor(seconds / 60)}m ago`;
                if (seconds < 86400) return `${Math.floor(seconds / 3600)}h ago`;
                return `${Math.floor(seconds / 86400)}d ago`;
            };
            
            suggestionsList.innerHTML = suggestions.map(suggestion => {
                const track = suggestion.trackData;
                const thumbnail = track?.thumbnail || '';
                const title = track?.title || 'Loading...';
                const artist = track?.artist || 'Unknown Artist';
                const timeAgo = suggestion.created_at ? formatRelativeFn(suggestion.created_at) : '';
                
                return `
                    <div class="mp3-mixxx-suggestion-item" onclick="openMixxxSuggestedTrack('${suggestion.suggestedEventId}')">
                        ${thumbnail ? `<img src="${thumbnail}" class="mp3-mixxx-suggestion-item-image" alt="${escapeFn(title)}" onerror="this.style.display='none'">` : '<div class="mp3-mixxx-suggestion-item-image" style="background: linear-gradient(135deg, #450af5, #c4efd9); display: flex; align-items: center; justify-content: center; font-size: 20px;">ðŸŽµ</div>'}
                        <div class="mp3-mixxx-suggestion-item-info">
                            <div class="mp3-mixxx-suggestion-item-title">${escapeFn(title)}</div>
                            <div class="mp3-mixxx-suggestion-item-artist">${escapeFn(artist)}</div>
                            <div class="mp3-mixxx-suggestion-item-author">
                                Suggested by ${escapeFn(suggestion.authorName)} ${timeAgo ? `â€¢ ${timeAgo}` : ''}
                            </div>
                        </div>
                        <div class="mp3-mixxx-suggestion-item-actions">
                            <button class="mp3-mixxx-suggestion-item-btn primary" onclick="event.stopPropagation(); continueMixxxPlaylist('${suggestion.suggestedEventId}')" title="Continue playlist">
                                <i class="bi bi-play-fill"></i>
                            </button>
                            <button class="mp3-mixxx-suggestion-item-btn" onclick="event.stopPropagation(); forkMixxxPlaylist('${suggestion.suggestedEventId}')" title="Fork playlist">
                                <i class="bi bi-diagram-3"></i>
                            </button>
                        </div>
                    </div>
                `;
            }).join('');
        }
        
        /**
         * Setup track search for Mixxx suggestions
         */
        function setupMixxxTrackSearch() {
            const searchInput = document.getElementById('mp3MixxxSearchInput');
            const resultsDiv = document.getElementById('mp3MixxxSuggestResults');
            
            if (!searchInput || !resultsDiv) return;
            
            let searchTimeout = null;
            
            searchInput.addEventListener('input', function(e) {
                const query = e.target.value.trim();
                
                if (searchTimeout) {
                    clearTimeout(searchTimeout);
                }
                
                searchTimeout = setTimeout(async () => {
                    if (query.length >= 2) {
                        await searchMixxxTracks(query, resultsDiv);
                    } else {
                        resultsDiv.style.display = 'none';
                    }
                }, 500);
            });
        }
        
        /**
         * Search tracks for Mixxx suggestion
         */
        async function searchMixxxTracks(query, resultsDiv) {
            resultsDiv.style.display = 'block';
            resultsDiv.innerHTML = '<div class="text-center text-secondary py-3 small">Searching...</div>';
            
            try {
                let tracks = [];
                if (typeof searchNostrTracks === 'function') {
                    tracks = await searchNostrTracks(query, 10);
                } else if (typeof fetchNostrMP3Tracks === 'function') {
                    const allTracks = await fetchNostrMP3Tracks(50);
                    const searchTerm = query.toLowerCase();
                    tracks = allTracks.filter(track => {
                        const title = (track.title || '').toLowerCase();
                        const artist = (track.artist || '').toLowerCase();
                        const album = (track.album || '').toLowerCase();
                        return title.includes(searchTerm) || artist.includes(searchTerm) || album.includes(searchTerm);
                    }).slice(0, 10);
                }
                
                if (tracks.length === 0) {
                    // No tracks found - offer to upload via /webcam
                    const escapeFn = typeof escapeHtml !== 'undefined' ? escapeHtml : (text) => {
                        const div = document.createElement('div');
                        div.textContent = text;
                        return div.innerHTML;
                    };
                    
                    resultsDiv.innerHTML = `
                        <div class="text-center text-secondary py-3 small" style="margin-bottom: 12px;">
                            No tracks found for "${escapeFn(query)}"
                        </div>
                        <div class="mp3-mixxx-upload-prompt" style="background: rgba(29, 185, 84, 0.1); border: 1px solid rgba(29, 185, 84, 0.3); border-radius: 8px; padding: 16px; text-align: center;">
                            <div style="font-size: 24px; margin-bottom: 8px;">ðŸŽµ</div>
                            <div style="color: #1db954; font-weight: 600; margin-bottom: 8px; font-size: 13px;">
                                Upload your MP3 track
                            </div>
                            <div style="color: #b3b3b3; font-size: 11px; margin-bottom: 12px;">
                                Can't find the track? Upload it to UPlanet and suggest it!
                            </div>
                            <button 
                                class="mp3-mixxx-suggestion-item-btn primary" 
                                onclick="openWebcamUpload()" 
                                style="width: 100%; padding: 10px; font-size: 12px; font-weight: 600;"
                                title="Open multimedia upload interface">
                                <i class="bi bi-upload"></i> Upload MP3 via Webcam
                            </button>
                        </div>
                    `;
                    return;
                }
                
                const escapeFn = typeof escapeHtml !== 'undefined' ? escapeHtml : (text) => {
                    const div = document.createElement('div');
                    div.textContent = text;
                    return div.innerHTML;
                };
                
                resultsDiv.innerHTML = tracks.map(track => `
                    <div class="mp3-mixxx-suggestion-item" onclick="suggestMixxxTrack('${track.eventId}')" style="margin-bottom: 8px;">
                        ${track.thumbnail ? `<img src="${track.thumbnail}" class="mp3-mixxx-suggestion-item-image" alt="${escapeFn(track.title || '')}" onerror="this.style.display='none'">` : '<div class="mp3-mixxx-suggestion-item-image" style="background: linear-gradient(135deg, #450af5, #c4efd9); display: flex; align-items: center; justify-content: center; font-size: 20px;">ðŸŽµ</div>'}
                        <div class="mp3-mixxx-suggestion-item-info">
                            <div class="mp3-mixxx-suggestion-item-title">${escapeFn(track.title || 'Unknown Title')}</div>
                            <div class="mp3-mixxx-suggestion-item-artist">${escapeFn(track.artist || 'Unknown Artist')}</div>
                        </div>
                        <div class="mp3-mixxx-suggestion-item-actions">
                            <button class="mp3-mixxx-suggestion-item-btn primary" onclick="event.stopPropagation(); suggestMixxxTrack('${track.eventId}')" title="Suggest this track">
                                <i class="bi bi-plus-circle"></i> Suggest
                            </button>
                        </div>
                    </div>
                `).join('');
                
            } catch (error) {
                console.error('Error searching tracks:', error);
                resultsDiv.innerHTML = '<div class="text-center text-secondary py-3 small">Error searching tracks</div>';
            }
        }
        
        /**
         * Suggest a track as next in Mixxx mode
         */
        async function suggestMixxxTrack(suggestedEventId) {
            const audioPlayer = document.getElementById('mp3AudioPlayer');
            const currentEventId = audioPlayer?.getAttribute('data-event-id');
            const authorId = audioPlayer?.getAttribute('data-author-id');
            
            if (!currentEventId) {
                alert('Current track ID not found');
                return;
            }
            
            let nostrVars = getNostrVariables();
            let currentUserPubkey = nostrVars.userPubkey;
            let currentNostrRelay = nostrVars.nostrRelay;
            
            if (!currentUserPubkey) {
                if (typeof connectNostr === 'function') {
                    currentUserPubkey = await connectNostr();
                    if (!currentUserPubkey) {
                        alert('You must be connected to suggest tracks');
                        return;
                    }
                } else {
                    alert('You must be connected to suggest tracks');
                    return;
                }
            }
            
            if (!currentNostrRelay || !nostrVars.isNostrConnected) {
                if (typeof connectToRelay === 'function') {
                    currentNostrRelay = await connectToRelay();
                    if (!currentNostrRelay) {
                        alert('Error connecting to relay');
                        return;
                    }
                } else {
                    alert('Relay connection not available');
                    return;
                }
            }
            
            try {
                const relayHint = currentNostrRelay?.url || '';
                
                // Create kind 1111 comment with mixxx:suggest protocol
                const tags = [
                    ['E', currentEventId, relayHint, authorId || ''],
                    ['K', '1063'],
                    ['P', authorId || '', relayHint],
                    ['e', currentEventId, relayHint, authorId || ''],
                    ['k', '1063'],
                    ['p', authorId || '', relayHint],
                    ['t', 'mixxx:suggest'],  // Protocol identifier
                    ['next', suggestedEventId, relayHint],  // Suggested track eventId
                    ['k', '1063']  // Suggested track kind
                ];
                
                const content = `ðŸŽµ Suggested next track`;
                
                const publishFn = (window.parent && window.parent !== window && typeof window.parent.publishNote === 'function')
                    ? window.parent.publishNote
                    : (typeof publishNote === 'function' ? publishNote : null);
                
                if (!publishFn) {
                    alert('Publish function not available');
                    return;
                }
                
                const result = await publishFn(content, tags, 1111, { silent: false });
                
                const publishedEvent = result?.event || result;
                const success = result && (result.success === true || result.id || publishedEvent?.id);
                
                if (success) {
                    // Clear search
                    const searchInput = document.getElementById('mp3MixxxSearchInput');
                    const resultsDiv = document.getElementById('mp3MixxxSuggestResults');
                    if (searchInput) searchInput.value = '';
                    if (resultsDiv) resultsDiv.style.display = 'none';
                    
                    alert('âœ… Track suggestion published!');
                } else {
                    alert('âŒ Error publishing suggestion');
                }
            } catch (error) {
                console.error('Error suggesting track:', error);
                alert('Error suggesting track: ' + error.message);
            }
        }
        
        /**
         * Open a suggested track in modal
         */
        async function openMixxxSuggestedTrack(eventId) {
            try {
                const track = await loadTrackFromEventId(eventId);
                if (track) {
                    initializeMP3Modal(track);
                }
            } catch (error) {
                console.error('Error loading suggested track:', error);
                alert('Error loading track: ' + error.message);
            }
        }
        
        /**
         * Continue playlist with suggested track
         */
        async function continueMixxxPlaylist(suggestedEventId) {
            // Open the suggested track in modal to continue listening
            await openMixxxSuggestedTrack(suggestedEventId);
        }
        
        /**
         * Fork playlist (create a new playlist starting from suggested track)
         */
        async function forkMixxxPlaylist(suggestedEventId) {
            // TODO: Implement playlist forking
            // For now, just open the track
            await openMixxxSuggestedTrack(suggestedEventId);
            alert('Playlist forking feature coming soon!');
        }
        
        /**
         * Open webcam upload interface for MP3 upload
         */
        function openWebcamUpload() {
            // Determine the base URL
            const currentPath = window.location.pathname;
            const basePath = currentPath.includes('/mp3') ? '/webcam' : '/webcam';
            
            // Open in new tab/window
            const webcamUrl = `${basePath}?html=1&audio=1`;
            window.open(webcamUrl, '_blank', 'noopener,noreferrer');
            
            // Show info message
            if (typeof showInfo === 'function') {
                showInfo(
                    'The upload interface will open in a new tab. After uploading your MP3, you can return here to suggest it.',
                    'Upload Interface'
                );
            } else {
                alert('Upload interface opening in new tab. After uploading your MP3, return here to suggest it.');
            }
        }
        
        /**
         * Setup VJ video search for Mixxx mode
         */
        function setupMixxxVJSearch() {
            const searchInput = document.getElementById('mp3MixxxVJSearchInput');
            const resultsDiv = document.getElementById('mp3MixxxVJResults');
            
            if (!searchInput || !resultsDiv) return;
            
            let searchTimeout = null;
            
            searchInput.addEventListener('input', function(e) {
                const query = e.target.value.trim();
                
                if (searchTimeout) {
                    clearTimeout(searchTimeout);
                }
                
                searchTimeout = setTimeout(async () => {
                    if (query.length >= 2) {
                        await searchMixxxVideos(query, resultsDiv);
                    } else {
                        resultsDiv.style.display = 'none';
                    }
                }, 500);
            });
        }
        
        /**
         * Search videos for VJ Mixxx suggestion
         */
        async function searchMixxxVideos(query, resultsDiv) {
            resultsDiv.style.display = 'block';
            resultsDiv.innerHTML = '<div class="text-center text-secondary py-3 small">Searching videos...</div>';
            
            try {
                // Fetch videos from /youtube endpoint
                const apiBase = typeof getAPIBaseUrl === 'function' ? getAPIBaseUrl() : window.location.origin;
                const response = await fetch(`${apiBase}/youtube?search=${encodeURIComponent(query)}&json=1&limit=10`);
                
                if (!response.ok) {
                    throw new Error('Failed to fetch videos');
                }
                
                const data = await response.json();
                
                if (!data.success || !data.channels) {
                    resultsDiv.innerHTML = '<div class="text-center text-secondary py-3 small">No videos found</div>';
                    return;
                }
                
                // Extract all videos from all channels
                let videos = [];
                for (const channelName in data.channels) {
                    const channel = data.channels[channelName];
                    if (channel.videos && Array.isArray(channel.videos)) {
                        videos.push(...channel.videos);
                    }
                }
                
                if (videos.length === 0) {
                    resultsDiv.innerHTML = '<div class="text-center text-secondary py-3 small">No videos found</div>';
                    return;
                }
                
                const escapeFn = typeof escapeHtml !== 'undefined' ? escapeHtml : (text) => {
                    const div = document.createElement('div');
                    div.textContent = text;
                    return div.innerHTML;
                };
                
                const getIPFSGatewayFn = typeof getIPFSGateway === 'function' ? getIPFSGateway : () => 'https://ipfs.copylaradio.com';
                
                resultsDiv.innerHTML = videos.slice(0, 10).map(video => {
                    const thumbnail = video.thumbnail_ipfs ? 
                        getIPFSGatewayFn() + '/ipfs/' + video.thumbnail_ipfs :
                        '';
                    const title = video.title || 'Unknown Title';
                    const channel = video.channel_name || 'Unknown Channel';
                    
                    return `
                        <div class="mp3-mixxx-vj-suggestion-item" onclick="suggestMixxxVJ('${video.message_id}')" style="margin-bottom: 8px;">
                            ${thumbnail ? `<img src="${thumbnail}" class="mp3-mixxx-vj-suggestion-item-image" alt="${escapeFn(title)}" onerror="this.style.display='none'">` : '<div class="mp3-mixxx-vj-suggestion-item-image" style="background: linear-gradient(135deg, #ff0000, #cc0000); display: flex; align-items: center; justify-content: center; font-size: 20px;">ðŸŽ¬</div>'}
                            <div class="mp3-mixxx-vj-suggestion-item-info">
                                <div class="mp3-mixxx-vj-suggestion-item-title">${escapeFn(title)}</div>
                                <div class="mp3-mixxx-vj-suggestion-item-channel">${escapeFn(channel)}</div>
                            </div>
                            <div class="mp3-mixxx-vj-suggestion-item-actions">
                                <button class="mp3-mixxx-vj-suggestion-item-btn primary" onclick="event.stopPropagation(); suggestMixxxVJ('${video.message_id}')" title="Suggest this video as VJ mix">
                                    <i class="bi bi-camera-video"></i> Suggest VJ
                                </button>
                            </div>
                        </div>
                    `;
                }).join('');
                
            } catch (error) {
                console.error('Error searching videos:', error);
                resultsDiv.innerHTML = '<div class="text-center text-secondary py-3 small">Error searching videos</div>';
            }
        }
        
        /**
         * Load Mixxx VJ suggestions (kind 1111 comments with mixxx:vj tag)
         */
        async function loadMixxxVJSuggestions(eventId) {
            const suggestionsList = document.getElementById('mp3MixxxVJSuggestionsList');
            const suggestionsCount = document.getElementById('mixxxVJSuggestionsCount');
            
            if (!suggestionsList) return;
            
            try {
                let currentRelay = window.nostrRelay || nostrRelay;
                
                if (!currentRelay || typeof currentRelay.sub !== 'function') {
                    if (typeof connectToRelay === 'function') {
                        await connectToRelay();
                        await new Promise(resolve => setTimeout(resolve, 500));
                    }
                    currentRelay = window.nostrRelay || nostrRelay;
                }
                
                if (!currentRelay || typeof currentRelay.sub !== 'function') {
                    suggestionsList.innerHTML = '<div class="text-center text-secondary py-5 small">NOSTR not connected</div>';
                    return;
                }
                
                // Subscribe to mixxx VJ suggestions (kind 1111 with mixxx:vj tag)
                const suggestionsSub = currentRelay.sub([{
                    kinds: [1111],
                    '#E': [eventId],
                    '#t': ['mixxx:vj']
                }]);
                
                const suggestions = [];
                const userMetadataCache = new Map();
                
                suggestionsSub.on('event', async (event) => {
                    try {
                        // Extract suggested video eventId from tags
                        const vjTag = event.tags.find(t => t[0] === 'vj' || t[0] === 'video');
                        const suggestedVideoEventId = vjTag ? vjTag[1] : null;
                        
                        if (!suggestedVideoEventId) return;
                        
                        // Check if already in list
                        if (suggestions.find(s => s.id === event.id)) return;
                        
                        let userName = userMetadataCache.get(event.pubkey) || event.pubkey.substring(0, 8) + '...';
                        
                        if (!userMetadataCache.has(event.pubkey) && typeof fetchUserMetadata !== 'undefined') {
                            try {
                                const profile = await Promise.race([
                                    fetchUserMetadata(event.pubkey),
                                    new Promise((_, reject) => setTimeout(() => reject(new Error('Timeout')), 1000))
                                ]);
                                if (profile) {
                                    userName = profile.display_name || profile.name || userName;
                                    userMetadataCache.set(event.pubkey, userName);
                                }
                            } catch (e) {
                                userMetadataCache.set(event.pubkey, userName);
                            }
                        }
                        
                        // Load suggested video metadata from /youtube endpoint
                        let videoData = null;
                        try {
                            const apiBase = typeof getAPIBaseUrl === 'function' ? getAPIBaseUrl() : window.location.origin;
                            const videoResponse = await fetch(`${apiBase}/youtube?json=1&limit=100`);
                            if (videoResponse.ok) {
                                const videoDataResponse = await videoResponse.json();
                                if (videoDataResponse.success && videoDataResponse.channels) {
                                    // Find video by message_id
                                    for (const channelName in videoDataResponse.channels) {
                                        const channel = videoDataResponse.channels[channelName];
                                        if (channel.videos) {
                                            const foundVideo = channel.videos.find(v => v.message_id === suggestedVideoEventId);
                                            if (foundVideo) {
                                                videoData = foundVideo;
                                                break;
                                            }
                                        }
                                    }
                                }
                            }
                        } catch (e) {
                            console.warn('Could not load suggested video:', e);
                        }
                        
                        suggestions.push({
                            id: event.id,
                            authorId: event.pubkey,
                            authorName: userName,
                            suggestedVideoEventId: suggestedVideoEventId,
                            videoData: videoData,
                            content: event.content || '',
                            created_at: event.created_at,
                            rawEvent: event
                        });
                        
                        // Sort by timestamp (newest first)
                        suggestions.sort((a, b) => (b.created_at || 0) - (a.created_at || 0));
                        
                        renderMixxxVJSuggestions(suggestions, suggestionsCount);
                    } catch (e) {
                        console.error('Error processing VJ suggestion:', e);
                    }
                });
                
                suggestionsSub.on('eose', () => {
                    console.log('âœ… Mixxx VJ suggestions subscription active');
                });
                
                // Store subscription for cleanup
                window.currentMixxxVJSuggestionsSubscription = suggestionsSub;
                
            } catch (error) {
                console.error('Error loading VJ suggestions:', error);
                suggestionsList.innerHTML = '<div class="text-center text-secondary py-5 small">Error loading VJ suggestions</div>';
            }
        }
        
        /**
         * Render Mixxx VJ suggestions
         */
        function renderMixxxVJSuggestions(suggestions, suggestionsCount) {
            const suggestionsList = document.getElementById('mp3MixxxVJSuggestionsList');
            
            if (!suggestionsList) return;
            
            if (suggestions.length === 0) {
                suggestionsList.innerHTML = '<div class="text-center text-secondary py-5 small">No VJ suggestions yet. Be the first to suggest a video!</div>';
                if (suggestionsCount) suggestionsCount.textContent = '0';
                return;
            }
            
            if (suggestionsCount) suggestionsCount.textContent = suggestions.length.toString();
            
            const escapeFn = typeof escapeHtml !== 'undefined' ? escapeHtml : (text) => {
                const div = document.createElement('div');
                div.textContent = text;
                return div.innerHTML;
            };
            
            const formatRelativeFn = typeof formatRelativeTime !== 'undefined' ? formatRelativeTime : (timestamp) => {
                const seconds = Math.floor((Date.now() / 1000) - timestamp);
                if (seconds < 60) return `${seconds}s ago`;
                if (seconds < 3600) return `${Math.floor(seconds / 60)}m ago`;
                if (seconds < 86400) return `${Math.floor(seconds / 3600)}h ago`;
                return `${Math.floor(seconds / 86400)}d ago`;
            };
            
            const getIPFSGatewayFn = typeof getIPFSGateway === 'function' ? getIPFSGateway : () => 'https://ipfs.copylaradio.com';
            
            suggestionsList.innerHTML = suggestions.map(suggestion => {
                const video = suggestion.videoData;
                const thumbnail = video?.thumbnail_ipfs ? 
                    getIPFSGatewayFn() + '/ipfs/' + video.thumbnail_ipfs :
                    '';
                const title = video?.title || 'Loading...';
                const channel = video?.channel_name || 'Unknown Channel';
                const timeAgo = suggestion.created_at ? formatRelativeFn(suggestion.created_at) : '';
                
                return `
                    <div class="mp3-mixxx-vj-suggestion-item" onclick="openMixxxSuggestedVJ('${suggestion.suggestedVideoEventId}')">
                        ${thumbnail ? `<img src="${thumbnail}" class="mp3-mixxx-vj-suggestion-item-image" alt="${escapeFn(title)}" onerror="this.style.display='none'">` : '<div class="mp3-mixxx-vj-suggestion-item-image" style="background: linear-gradient(135deg, #ff0000, #cc0000); display: flex; align-items: center; justify-content: center; font-size: 20px;">ðŸŽ¬</div>'}
                        <div class="mp3-mixxx-vj-suggestion-item-info">
                            <div class="mp3-mixxx-vj-suggestion-item-title">${escapeFn(title)}</div>
                            <div class="mp3-mixxx-vj-suggestion-item-channel">${escapeFn(channel)}</div>
                            <div class="mp3-mixxx-vj-suggestion-item-author">
                                Suggested by ${escapeFn(suggestion.authorName)} ${timeAgo ? `â€¢ ${timeAgo}` : ''}
                            </div>
                        </div>
                        <div class="mp3-mixxx-vj-suggestion-item-actions">
                            <button class="mp3-mixxx-vj-suggestion-item-btn primary" onclick="event.stopPropagation(); openMixxxSuggestedVJ('${suggestion.suggestedVideoEventId}')" title="Open video">
                                <i class="bi bi-play-fill"></i>
                            </button>
                        </div>
                    </div>
                `;
            }).join('');
        }
        
        /**
         * Suggest a video as VJ mix for this audio track
         */
        async function suggestMixxxVJ(suggestedVideoEventId) {
            const audioPlayer = document.getElementById('mp3AudioPlayer');
            const currentEventId = audioPlayer?.getAttribute('data-event-id');
            const authorId = audioPlayer?.getAttribute('data-author-id');
            
            if (!currentEventId) {
                alert('Current track ID not found');
                return;
            }
            
            let nostrVars = getNostrVariables();
            let currentUserPubkey = nostrVars.userPubkey;
            let currentNostrRelay = nostrVars.nostrRelay;
            
            if (!currentUserPubkey) {
                if (typeof connectNostr === 'function') {
                    currentUserPubkey = await connectNostr();
                    if (!currentUserPubkey) {
                        alert('You must be connected to suggest videos');
                        return;
                    }
                } else {
                    alert('You must be connected to suggest videos');
                    return;
                }
            }
            
            if (!currentNostrRelay || !nostrVars.isNostrConnected) {
                if (typeof connectToRelay === 'function') {
                    currentNostrRelay = await connectToRelay();
                    if (!currentNostrRelay) {
                        alert('Error connecting to relay');
                        return;
                    }
                } else {
                    alert('Relay connection not available');
                    return;
                }
            }
            
            try {
                const relayHint = currentNostrRelay?.url || '';
                
                // Create kind 1111 comment with mixxx:vj protocol
                const tags = [
                    ['E', currentEventId, relayHint, authorId || ''],
                    ['K', '1063'],
                    ['P', authorId || '', relayHint],
                    ['e', currentEventId, relayHint, authorId || ''],
                    ['k', '1063'],
                    ['p', authorId || '', relayHint],
                    ['t', 'mixxx:vj'],  // Protocol identifier for VJ suggestions
                    ['vj', suggestedVideoEventId, relayHint],  // Suggested video eventId
                    ['k', '21']  // Suggested video kind (kind 21 for videos)
                ];
                
                const content = `ðŸŽ¬ Suggested VJ mix video`;
                
                const publishFn = (window.parent && window.parent !== window && typeof window.parent.publishNote === 'function')
                    ? window.parent.publishNote
                    : (typeof publishNote === 'function' ? publishNote : null);
                
                if (!publishFn) {
                    alert('Publish function not available');
                    return;
                }
                
                const result = await publishFn(content, tags, 1111, { silent: false });
                
                const publishedEvent = result?.event || result;
                const success = result && (result.success === true || result.id || publishedEvent?.id);
                
                if (success) {
                    // Clear search
                    const searchInput = document.getElementById('mp3MixxxVJSearchInput');
                    const resultsDiv = document.getElementById('mp3MixxxVJResults');
                    if (searchInput) searchInput.value = '';
                    if (resultsDiv) resultsDiv.style.display = 'none';
                    
                    alert('âœ… VJ video suggestion published!');
                } else {
                    alert('âŒ Error publishing VJ suggestion');
                }
            } catch (error) {
                console.error('Error suggesting VJ video:', error);
                alert('Error suggesting VJ video: ' + error.message);
            }
        }
        
        /**
         * Open a suggested VJ video
         */
        async function openMixxxSuggestedVJ(videoEventId) {
            // Open video in new tab or redirect to /youtube
            const apiBase = typeof getAPIBaseUrl === 'function' ? getAPIBaseUrl() : window.location.origin;
            const youtubeUrl = `${apiBase}/youtube?html=1&video=${videoEventId}`;
            window.open(youtubeUrl, '_blank', 'noopener,noreferrer');
        }

        // Expose functions globally
        window.handleCloseMP3Modal = handleCloseMP3Modal;
        window.switchMP3Tab = switchMP3Tab;
        window.initializeMP3Modal = initializeMP3Modal;
        window.loadMP3Comments = loadMP3Comments;
        window.displayMP3Comments = displayMP3Comments;
        window.toggleMP3ReplyForm = toggleMP3ReplyForm;
        window.submitMP3Reply = submitMP3Reply;
        window.submitMP3Comment = submitMP3Comment;
        window.handleMP3Like = handleMP3Like;
        window.handleMP3Follow = handleMP3Follow;
        window.handleMP3Share = handleMP3Share;
        window.searchRelatedTracks = searchRelatedTracks;
        window.openRelatedTrack = openRelatedTrack;
        window.linkRelatedTrack = linkRelatedTrack;
        window.loadTrackFromEventId = loadTrackFromEventId;
        window.openProfileModalInMP3 = openProfileModalInMP3;
        window.initializeMixxxMode = initializeMixxxMode;
        window.suggestMixxxTrack = suggestMixxxTrack;
        window.openMixxxSuggestedTrack = openMixxxSuggestedTrack;
        window.continueMixxxPlaylist = continueMixxxPlaylist;
        window.forkMixxxPlaylist = forkMixxxPlaylist;
        window.openWebcamUpload = openWebcamUpload;
        window.setupMixxxVJSearch = setupMixxxVJSearch;
        window.searchMixxxVideos = searchMixxxVideos;
        window.suggestMixxxVJ = suggestMixxxVJ;
        window.openMixxxSuggestedVJ = openMixxxSuggestedVJ;
        window.loadLinkedTracks = loadLinkedTracks;
        window.renderLinkedTracks = renderLinkedTracks;
        
        /**
         * Open thumbnail search modal
         */
        function openThumbnailSearch() {
            const modal = new bootstrap.Modal(document.getElementById('thumbnailSearchModal'));
            modal.show();
            
            // Setup search input
            const searchInput = document.getElementById('thumbnailSearchInput');
            if (searchInput) {
                searchInput.value = '';
                searchInput.oninput = debounce((e) => {
                    const query = e.target.value.trim();
                    if (query.length >= 2) {
                        searchThumbnailImages(query);
                    } else {
                        const results = document.getElementById('thumbnailSearchResults');
                        if (results) {
                            results.innerHTML = '<div class="col-12 text-center text-secondary py-4"><i class="bi bi-search"></i> Enter a search term to find images</div>';
                        }
                    }
                }, 500);
            }
        }
        
        /**
         * Search for images (kind 1063 with mime-type image/*)
         */
        async function searchThumbnailImages(query) {
            const results = document.getElementById('thumbnailSearchResults');
            if (!results) return;
            
            results.innerHTML = '<div class="col-12 text-center text-secondary py-4"><i class="bi bi-hourglass-split"></i> Searching images...</div>';
            
            try {
                const currentRelay = window.nostrRelay || nostrRelay;
                if (!currentRelay || typeof currentRelay.sub !== 'function') {
                    results.innerHTML = '<div class="col-12 text-center text-danger py-4">âš ï¸ Relay not connected</div>';
                    return;
                }
                
                const images = await new Promise((resolve) => {
                    const imageEvents = [];
                    const sub = currentRelay.sub([{
                        kinds: [1063],
                        limit: 50
                    }]);
                    
                    sub.on('event', (event) => {
                        // Check if it's an image (mime-type starts with image/)
                        const mimeTag = event.tags.find(tag => tag[0] === 'm');
                        if (mimeTag && mimeTag[1] && mimeTag[1].startsWith('image/')) {
                            // Check if query matches title, description, or content
                            const titleTag = event.tags.find(tag => tag[0] === 'title');
                            const descTag = event.tags.find(tag => tag[0] === 'description');
                            const searchText = (titleTag ? titleTag[1] : '') + ' ' + (descTag ? descTag[1] : '') + ' ' + (event.content || '');
                            
                            if (query === '' || searchText.toLowerCase().includes(query.toLowerCase())) {
                                imageEvents.push(event);
                            }
                        }
                    });
                    
                    sub.on('eose', () => {
                        sub.unsub();
                        resolve(imageEvents);
                    });
                    
                    setTimeout(() => {
                        sub.unsub();
                        resolve(imageEvents);
                    }, 5000);
                });
                
                if (images.length === 0) {
                    results.innerHTML = '<div class="col-12 text-center text-secondary py-4"><i class="bi bi-image"></i> No images found</div>';
                    return;
                }
                
                // Render images
                results.innerHTML = images.map(event => {
                    const urlTag = event.tags.find(tag => tag[0] === 'url');
                    const titleTag = event.tags.find(tag => tag[0] === 'title');
                    const imageTag = event.tags.find(tag => tag[0] === 'image');
                    const rTag = event.tags.find(tag => tag[0] === 'r' && tag[2] === 'Thumbnail');
                    
                    let imageUrl = imageTag ? imageTag[1] : (rTag ? rTag[1] : (urlTag ? urlTag[1] : null));
                    if (imageUrl && typeof convertIPFSUrlGlobal === 'function') {
                        imageUrl = convertIPFSUrlGlobal(imageUrl);
                    } else if (imageUrl && window.IPFS_GATEWAY && (imageUrl.startsWith('/ipfs/') || imageUrl.startsWith('ipfs://'))) {
                        if (imageUrl.startsWith('ipfs://')) {
                            imageUrl = window.IPFS_GATEWAY + imageUrl.replace('ipfs://', '/ipfs/');
                        } else {
                            imageUrl = window.IPFS_GATEWAY + imageUrl;
                        }
                    }
                    
                    const title = titleTag ? titleTag[1] : 'Untitled Image';
                    const eventId = event.id;
                    
                    return `
                        <div class="col-6 col-md-4 col-lg-3">
                            <div class="card bg-secondary border-secondary" style="cursor: pointer;" onclick="selectThumbnailImage('${eventId}', '${imageUrl || ''}')">
                                ${imageUrl ? `<img src="${imageUrl}" class="card-img-top" style="height: 120px; object-fit: cover;" onerror="this.style.display='none'">` : '<div class="card-img-top bg-dark d-flex align-items-center justify-content-center" style="height: 120px;"><i class="bi bi-image text-secondary"></i></div>'}
                                <div class="card-body p-2">
                                    <div class="small text-white text-truncate" title="${escapeHtml(title)}">${escapeHtml(title)}</div>
                                </div>
                            </div>
                        </div>
                    `;
                }).join('');
                
            } catch (error) {
                console.error('Error searching images:', error);
                results.innerHTML = '<div class="col-12 text-center text-danger py-4">âš ï¸ Error searching images</div>';
            }
        }
        
        /**
         * Select thumbnail image
         */
        async function selectThumbnailImage(eventId, imageUrl) {
            const audioPlayer = document.getElementById('mp3AudioPlayer');
            const currentEventId = audioPlayer?.getAttribute('data-event-id');
            
            if (!currentEventId) {
                alert('No track selected');
                return;
            }
            
            // Close modal
            const modal = bootstrap.Modal.getInstance(document.getElementById('thumbnailSearchModal'));
            if (modal) modal.hide();
            
            // Update thumbnail display immediately
            const albumArtEl = document.getElementById('mp3AlbumArt');
            const albumArtPlaceholder = document.getElementById('mp3AlbumArtPlaceholder');
            
            if (albumArtEl && imageUrl) {
                albumArtEl.src = imageUrl;
                albumArtEl.style.display = 'block';
                if (albumArtPlaceholder) {
                    albumArtPlaceholder.style.display = 'none';
                }
            }
            
            // TODO: Publish a kind 1111 comment or update the track event with the new thumbnail
            // For now, we just update the display
            console.log('Selected thumbnail:', eventId, imageUrl);
            alert('Thumbnail updated! (Note: This is a visual update only. Full implementation would require publishing an update event.)');
        }
        
        /**
         * Debounce helper
         */
        function debounce(func, wait) {
            let timeout;
            return function executedFunction(...args) {
                const later = () => {
                    clearTimeout(timeout);
                    func(...args);
                };
                clearTimeout(timeout);
                timeout = setTimeout(later, wait);
            };
        }
        
        /**
         * Escape HTML helper
         */
        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }
        
        // Expose functions globally
        window.openThumbnailSearch = openThumbnailSearch;
        window.searchThumbnailImages = searchThumbnailImages;
        window.selectThumbnailImage = selectThumbnailImage;
    </script>
    <!-- Thumbnail Search Modal -->
    <div class="modal fade" id="thumbnailSearchModal" tabindex="-1" aria-labelledby="thumbnailSearchModalLabel" aria-hidden="true">
        <div class="modal-dialog modal-lg">
            <div class="modal-content bg-dark text-white">
                <div class="modal-header border-secondary">
                    <h5 class="modal-title" id="thumbnailSearchModalLabel">
                        <i class="bi bi-image"></i> Search Image for Thumbnail
                    </h5>
                    <button type="button" class="btn-close btn-close-white" data-bs-dismiss="modal" aria-label="Close"></button>
                </div>
                <div class="modal-body">
                    <div class="mb-3">
                        <input type="text" class="form-control bg-dark text-white border-secondary" id="thumbnailSearchInput" placeholder="Search images...">
                    </div>
                    <div id="thumbnailSearchResults" class="row g-2" style="max-height: 400px; overflow-y: auto;">
                        <div class="col-12 text-center text-secondary py-4">
                            <i class="bi bi-search"></i> Enter a search term to find images
                        </div>
                    </div>
                </div>
                <div class="modal-footer border-secondary">
                    <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Cancel</button>
                </div>
            </div>
        </div>
    </div>
</body>
</html>

