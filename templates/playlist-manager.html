<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Playlist Manager - Nostr Tube</title>
    <!-- Bootstrap 5 CSS -->
    <link href="{{ myIPFS }}/ipns/copylaradio.com/bootstrap.min.css" rel="stylesheet">
    <!-- Bootstrap Icons -->
    <link rel="stylesheet" href="{{ myIPFS }}/ipns/copylaradio.com/fonts/bootstrap-icons.css">
    
    <!-- Nostr integration -->
    <script src="{{ myIPFS }}/ipns/copylaradio.com/nostr.bundle.js"></script>
    <!-- Common.js with NOSTR functions -->
    <script src="{{ myIPFS }}/ipns/copylaradio.com/common.js"></script>
    <!-- NOSTR Tube functions -->
    <script src="{{ myIPFS }}/ipns/copylaradio.com/youtube.enhancements.js"></script>
    <link rel="stylesheet" href="{{ myIPFS }}/ipns/copylaradio.com/youtube.enhancements.css" />
    
    <!-- Bootstrap 5 JS Bundle -->
    <script src="{{ myIPFS }}/ipns/copylaradio.com/bootstrap.bundle.min.js"></script>
    
    <style>
        body {
            font-family: 'Roboto', 'Arial', sans-serif;
            background: #0f0f0f;
            color: #ffffff;
            min-height: 100vh;
        }

        .playlists-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(320px, 1fr));
            gap: 24px;
        }

        .playlist-card {
            background: #181818;
            border: 1px solid #3f3f3f;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            position: relative;
            overflow: hidden;
        }
        
        .playlist-card::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 3px;
            background: linear-gradient(90deg, #3ea6ff, #4ade80);
            transform: scaleX(0);
            transform-origin: left;
            transition: transform 0.3s ease;
        }

        .playlist-card:hover {
            background: #212121;
            border-color: #3ea6ff;
            transform: translateY(-4px);
            box-shadow: 0 8px 24px rgba(0, 0, 0, 0.4);
        }
        
        .playlist-card:hover::before {
            transform: scaleX(1);
        }

        .playlist-video-thumbnail {
            aspect-ratio: 16/9;
            background: #2a2a2a;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
            overflow: hidden;
        }

        .playlist-video-thumbnail img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }
        
        .playlist-manage-btn:hover {
            opacity: 0.8;
        }
        
        /* Video list styles */
        .video-list-container {
            display: flex;
            flex-direction: column;
            gap: 12px;
            margin-top: 24px;
        }
        
        .video-list-item {
            background: #181818;
            border: 1px solid #3f3f3f;
            border-radius: 12px;
            padding: 16px;
            display: flex;
            gap: 16px;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            cursor: grab;
            position: relative;
        }
        
        .video-list-item:hover {
            background: #212121;
            border-color: #3ea6ff;
            transform: translateX(4px);
        }
        
        .video-list-item.dragging {
            opacity: 0.5;
            cursor: grabbing;
            transform: rotate(2deg);
        }
        
        .video-list-item.drag-over {
            border-color: #4ade80;
            background: #1a2e1a;
        }
        
        .video-drag-handle {
            display: flex;
            align-items: center;
            color: #666;
            cursor: grab;
            padding: 8px;
            font-size: 20px;
        }
        
        .video-drag-handle:active {
            cursor: grabbing;
        }
        
        .video-thumbnail-container {
            flex-shrink: 0;
            width: 200px;
            height: 112px;
            border-radius: 8px;
            overflow: hidden;
            background: #2a2a2a;
            position: relative;
        }
        
        .video-thumbnail-container img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }
        
        .video-thumbnail-container .play-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            background: rgba(0, 0, 0, 0.5);
            opacity: 0;
            transition: opacity 0.2s;
            cursor: pointer;
        }
        
        .video-thumbnail-container:hover .play-overlay {
            opacity: 1;
        }
        
        .video-thumbnail-container .play-overlay i {
            font-size: 48px;
            color: #fff;
        }
        
        .video-info {
            flex: 1;
            display: flex;
            flex-direction: column;
            gap: 8px;
            min-width: 0;
        }
        
        .video-title {
            font-size: 16px;
            font-weight: 500;
            color: #fff;
            margin: 0;
            line-height: 1.4;
            display: -webkit-box;
            -webkit-line-clamp: 2;
            -webkit-box-orient: vertical;
            overflow: hidden;
        }
        
        .video-meta {
            display: flex;
            gap: 16px;
            font-size: 14px;
            color: #aaaaaa;
            flex-wrap: wrap;
        }
        
        .video-actions {
            display: flex;
            gap: 8px;
            align-items: flex-start;
            flex-shrink: 0;
        }
        
        .video-player-embedded {
            width: 100%;
            border-radius: 8px;
            overflow: hidden;
            margin-top: 12px;
            background: #000;
        }
        
        .video-player-embedded iframe {
            width: 100%;
            aspect-ratio: 16 / 9;
            border: none;
        }
        
        .video-item-expanded {
            flex-direction: column;
        }
        
        .video-item-expanded .video-thumbnail-container {
            width: 100%;
            height: auto;
            aspect-ratio: 16 / 9;
        }
        
        .remove-video-btn {
            background: transparent;
            border: 1px solid #ef4444;
            color: #ef4444;
            padding: 6px 12px;
            border-radius: 6px;
            font-size: 12px;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .remove-video-btn:hover {
            background: #ef4444;
            color: #fff;
        }
        
        .empty-playlist {
            text-align: center;
            padding: 48px 24px;
            color: #666;
        }
        
        .empty-playlist i {
            font-size: 64px;
            margin-bottom: 16px;
            opacity: 0.3;
        }
        
        .empty-playlist h4 {
            color: #aaaaaa;
            margin-bottom: 8px;
        }
        
        .empty-playlist .text-muted {
            color: #888888;
            font-size: 0.9em;
        }
        
        /* Improved drag feedback */
        .video-list-item.dragging {
            box-shadow: 0 8px 24px rgba(62, 166, 255, 0.4);
        }
        
        /* Smooth transitions for video expansion */
        .video-player-embedded {
            animation: fadeIn 0.3s ease;
        }
        
        @keyframes fadeIn {
            from {
                opacity: 0;
                transform: translateY(-10px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }
    </style>
</head>
<body class="p-3 p-lg-4">
    <div class="container-fluid" style="max-width: 1200px;">
        <div class="d-flex justify-content-between align-items-center mb-4 pb-3 border-bottom border-secondary">
            <h1 class="h2 mb-0"><i class="bi bi-collection-play"></i> Mes Playlists</h1>
            <button class="btn btn-primary rounded-pill d-flex align-items-center gap-2" onclick="openCreatePlaylistModal()">
                <i class="bi bi-plus-circle"></i> Créer une playlist
            </button>
        </div>

        <div id="playlistsContainer" class="playlists-grid mb-4">
            <div class="text-center py-5 text-secondary">Chargement des playlists...</div>
        </div>
    </div>

    <!-- Create Playlist Modal (Bootstrap) -->
    <div class="modal fade" id="createPlaylistModal" tabindex="-1" aria-labelledby="createPlaylistModalLabel" aria-hidden="true">
        <div class="modal-dialog modal-dialog-centered">
            <div class="modal-content bg-dark text-white border-secondary">
                <div class="modal-header border-secondary">
                    <h5 class="modal-title" id="createPlaylistModalLabel">Créer une playlist</h5>
                    <button type="button" class="btn-close btn-close-white" data-bs-dismiss="modal" aria-label="Close"></button>
                </div>
                <div class="modal-body">
                    <form id="createPlaylistForm" onsubmit="handleCreatePlaylist(event)">
                        <div class="mb-3">
                            <label for="playlistName" class="form-label">Nom de la playlist *</label>
                            <input type="text" class="form-control bg-dark text-white border-secondary" id="playlistName" required placeholder="Ma super playlist" />
                        </div>
                        <div class="mb-3">
                            <label for="playlistDescription" class="form-label">Description (optionnel)</label>
                            <textarea class="form-control bg-dark text-white border-secondary" id="playlistDescription" rows="3" placeholder="Description de la playlist..."></textarea>
                        </div>
                        <div class="alert alert-danger d-none" id="createPlaylistError" role="alert"></div>
                        <div class="d-flex gap-2 justify-content-end">
                            <button type="button" class="btn btn-outline-secondary rounded-pill" data-bs-dismiss="modal">
                                Annuler
                            </button>
                            <button type="submit" class="btn btn-primary rounded-pill">
                                Créer
                            </button>
                        </div>
                    </form>
                </div>
            </div>
        </div>
    </div>

    <script>
        // ========================================
        // NOSTR PROXY FOR IFRAME MODE
        // ========================================
        
        // Detect if we're in an iframe
        const isInIframe = window.self !== window.top;
        
        // Proxy for NOSTR extension when in iframe
        // Create our own proxy that uses postMessage to communicate with parent
        // This ensures we have a working proxy regardless of what common.js does
        if (isInIframe && window.parent) {
            let requestIdCounter = 0;
            const pendingRequests = new Map();
            
            // Proxy function to send NOSTR requests to parent
            function proxyNostrRequest(method, params) {
                return new Promise((resolve, reject) => {
                    const requestId = `nostr-req-${Date.now()}-${requestIdCounter++}`;
                    pendingRequests.set(requestId, { resolve, reject });
                    
                    window.parent.postMessage({
                        type: 'nostr-request',
                        requestId: requestId,
                        method: method,
                        params: params
                    }, '*');
                    
                    // Timeout after 10 seconds
                    setTimeout(() => {
                        if (pendingRequests.has(requestId)) {
                            pendingRequests.delete(requestId);
                            reject(new Error('NOSTR request timeout'));
                        }
                    }, 10000);
                });
            }
            
            // Listen for responses from parent
            window.addEventListener('message', function(event) {
                if (event.data && event.data.type === 'nostr-response') {
                    const { requestId, success, data, error } = event.data;
                    
                    if (pendingRequests.has(requestId)) {
                        const { resolve, reject } = pendingRequests.get(requestId);
                        pendingRequests.delete(requestId);
                        
                        if (success) {
                            resolve(data);
                        } else {
                            reject(new Error(error || 'NOSTR request failed'));
                        }
                    }
                }
            });
            
            // Create a working proxy object that uses postMessage
            const nostrProxy = {
                    getPublicKey: async () => {
                        return await proxyNostrRequest('getPublicKey', []);
                    },
                    signEvent: async (event) => {
                        return await proxyNostrRequest('signEvent', [event]);
                    },
                    getRelays: async () => {
                        return await proxyNostrRequest('getRelays', []);
                    },
                    nip04: {
                        encrypt: async (pubkey, plaintext) => {
                            return await proxyNostrRequest('nip04.encrypt', [pubkey, plaintext]);
                        },
                        decrypt: async (pubkey, ciphertext) => {
                            return await proxyNostrRequest('nip04.decrypt', [pubkey, ciphertext]);
                        }
                    },
                    nip44: {
                        encrypt: async (pubkey, plaintext) => {
                            return await proxyNostrRequest('nip44.encrypt', [pubkey, plaintext]);
                        },
                        decrypt: async (pubkey, ciphertext) => {
                            return await proxyNostrRequest('nip44.decrypt', [pubkey, ciphertext]);
                        }
                    }
            };
            
            // Function to install/reinstall our proxy
            function installProxy() {
                try {
                    Object.defineProperty(window, 'nostr', {
                        value: nostrProxy,
                        writable: true,
                        configurable: true
                    });
                    console.log('✅ NOSTR proxy installed (playlist-manager)');
                } catch (e) {
                    // If defineProperty fails, try direct assignment
                    window.nostr = nostrProxy;
                    console.log('✅ NOSTR proxy installed via assignment (playlist-manager)');
                }
            }
            
            // Install proxy immediately
            installProxy();
            
            // Reinstall proxy after a delay to override any proxy from common.js
            setTimeout(installProxy, 1500);
            
            // Also reinstall if common.js tries to replace it
            const nostrDescriptor = Object.getOwnPropertyDescriptor(window, 'nostr');
            if (nostrDescriptor && nostrDescriptor.configurable) {
                // Monitor for changes
                let lastNostr = window.nostr;
                setInterval(() => {
                    if (window.nostr !== nostrProxy && window.nostr !== lastNostr) {
                        // Something replaced our proxy, reinstall it
                        console.warn('⚠️ window.nostr was replaced, reinstalling proxy');
                        installProxy();
                        lastNostr = window.nostr;
                    }
                }, 500);
            }
        }
        
        // ========================================
        // INITIALIZE CONNECTION VARIABLES FROM PARENT
        // ========================================
        
        async function initializeConnectionVars() {
            // Try to get connection variables from parent if in iframe
            if (isInIframe && window.parent) {
                try {
                    // Try multiple times with small delays
                    for (let i = 0; i < 5; i++) {
                        if (window.parent.userPubkey) {
                            // Use parent's connection
                            if (typeof window !== 'undefined') {
                                window.userPubkey = window.parent.userPubkey;
                                window.nostrRelay = window.parent.nostrRelay || null;
                                window.isNostrConnected = window.parent.isNostrConnected || false;
                            }
                            
                            // Set global variables for common.js compatibility
                            if (typeof userPubkey === 'undefined') {
                                var userPubkey = window.parent.userPubkey;
                            } else {
                                userPubkey = window.parent.userPubkey;
                            }
                            
                            if (typeof nostrRelay === 'undefined') {
                                var nostrRelay = window.parent.nostrRelay || null;
                            } else {
                                nostrRelay = window.parent.nostrRelay || null;
                            }
                            
                            if (typeof isNostrConnected === 'undefined') {
                                var isNostrConnected = window.parent.isNostrConnected || false;
                            } else {
                                isNostrConnected = window.parent.isNostrConnected || false;
                            }
                            
                            console.log('✅ Using connection from parent window:', window.parent.userPubkey ? window.parent.userPubkey.substring(0, 8) + '...' : 'none');
                            return;
                        } else if (i < 4) {
                            // Wait a bit before retrying
                            await new Promise(resolve => setTimeout(resolve, 200));
                        }
                    }
                } catch (error) {
                    console.warn('Could not access parent window variables:', error);
                }
            }
        }
        
        // ========================================
        // UTILITY FUNCTIONS
        // ========================================
        
        /**
         * Get playlist ID from URL or server template
         * Must be defined before DOMContentLoaded uses it
         */
        function getPlaylistIdFromUrl() {
            const urlParams = new URLSearchParams(window.location.search);
            let playlistId = urlParams.get('id');
            // Server template provides playlist_id if available
            {% if playlist_id %}
            if (!playlistId) {
                playlistId = '{{ playlist_id }}';
            }
            {% endif %}
            return playlistId;
        }
        
        // Expose globally
        window.getPlaylistIdFromUrl = getPlaylistIdFromUrl;
        
        // ========================================
        // MAIN INITIALIZATION
        // ========================================
        
        // Wait for dependencies to load
        document.addEventListener('DOMContentLoaded', async () => {
            // Initialize connection variables from parent if in iframe
            await initializeConnectionVars();
            
            // Wait for common.js and youtube.enhancements.js to be available
            if (typeof connectNostr === 'undefined' || typeof createPlaylist === 'undefined') {
                setTimeout(() => {
                    document.addEventListener('DOMContentLoaded', arguments.callee);
                }, 500);
                return;
            }

            // Check if a specific playlist ID is requested via URL parameter
            const playlistId = getPlaylistIdFromUrl();
            
            if (playlistId) {
                // If a playlist ID is provided, try to load it without requiring user connection
                // This allows sharing playlists with others who aren't connected
                await loadSpecificPlaylist(playlistId);
                return;
            }
            
            // Only require connection for viewing user's own playlists list
            const currentUserPubkey = userPubkey || (window.parent && window.parent.userPubkey) || null;
            if (!currentUserPubkey) {
                document.getElementById('playlistsContainer').innerHTML = `
                    <div class="text-center py-5">
                        <div class="display-1 mb-3 opacity-50"><i class="bi bi-key"></i></div>
                        <h3 class="h4 mb-2">Connexion requise</h3>
                        <p class="text-secondary mb-3">L'extension Nostr avec la clé de votre MULTIPASS est requise pour la connexion.</p>
                        <p class="text-muted small mb-4">Votre MULTIPASS contient votre identité NOSTR et vos playlists.</p>
                        <button class="btn btn-primary rounded-pill d-inline-flex align-items-center gap-2" onclick="connectAndLoadPlaylists()">
                            <i class="bi bi-box-arrow-in-right"></i> Se connecter avec MULTIPASS
                        </button>
                    </div>
                `;
                return;
            }

            // Ensure userPubkey is set
            if (!userPubkey && currentUserPubkey) {
                userPubkey = currentUserPubkey;
                window.userPubkey = currentUserPubkey;
            }

            // Load user's playlists list (already checked playlistId above)
            await loadUserPlaylists();
        });

        /**
         * Load user's playlists from NOSTR
         */
        async function loadUserPlaylists() {
            const container = document.getElementById('playlistsContainer');
            
            // Try to get relay from parent if in iframe
            if (isInIframe && window.parent) {
                if (window.parent.nostrRelay && !nostrRelay) {
                    nostrRelay = window.parent.nostrRelay;
                    window.nostrRelay = nostrRelay;
                }
                if (window.parent.isNostrConnected !== undefined && !isNostrConnected) {
                    isNostrConnected = window.parent.isNostrConnected;
                    window.isNostrConnected = isNostrConnected;
                }
                if (window.parent.userPubkey && !userPubkey) {
                    userPubkey = window.parent.userPubkey;
                    window.userPubkey = userPubkey;
                }
            }
            
            // If not in iframe or connection not available from parent, establish local connection
            if (!nostrRelay || !isNostrConnected || !userPubkey) {
                // First, try to connect via common.js if not connected
                if (!userPubkey && typeof connectNostr === 'function') {
                    const pubkey = await connectNostr();
                    if (pubkey) {
                        userPubkey = pubkey;
                        window.userPubkey = pubkey;
                    }
                }
                
                // Then, connect to relay
                if (!nostrRelay || !isNostrConnected) {
                    if (typeof connectToRelay === 'function') {
                        await connectToRelay();
                        // Update variables after connection
                        if (typeof nostrRelay !== 'undefined') {
                            window.nostrRelay = nostrRelay;
                        }
                        if (typeof isNostrConnected !== 'undefined') {
                            window.isNostrConnected = isNostrConnected;
                        }
                    } else if (isInIframe && window.parent && typeof window.parent.connectToRelay === 'function') {
                        await window.parent.connectToRelay();
                        nostrRelay = window.parent.nostrRelay || null;
                        isNostrConnected = window.parent.isNostrConnected || false;
                    }
                }
            }

            // Final check
            if (!userPubkey) {
                container.innerHTML = `
                    <div class="text-center py-5">
                        <div class="display-1 mb-3 opacity-50"><i class="bi bi-key"></i></div>
                        <h3 class="h4 mb-2">Connexion requise</h3>
                        <p class="text-secondary mb-3">L'extension Nostr avec la clé de votre MULTIPASS est requise pour la connexion.</p>
                        <p class="text-muted small mb-4">Votre MULTIPASS contient votre identité NOSTR et vos playlists.</p>
                        <button class="btn btn-primary rounded-pill d-inline-flex align-items-center gap-2" onclick="connectAndLoadPlaylists()">
                            <i class="bi bi-box-arrow-in-right"></i> Se connecter avec MULTIPASS
                        </button>
                    </div>
                `;
                return;
            }

            if (!nostrRelay || !isNostrConnected) {
                container.innerHTML = `
                    <div class="alert alert-danger d-flex align-items-center gap-2" role="alert">
                        <i class="bi bi-exclamation-triangle-fill"></i>
                        <div>Impossible de se connecter au relay NOSTR. Vérifiez votre connexion.</div>
                    </div>
                `;
                return;
            }

            try {
                container.innerHTML = '<div class="text-center py-5 text-secondary">Chargement des playlists...</div>';

                // Fetch playlists (kind 30005 for new playlists, 10001 for backward compatibility)
                const playlists = await fetchUserPlaylists();

                if (playlists.length === 0) {
                    container.innerHTML = `
                        <div class="text-center py-5">
                            <div class="display-1 mb-3 opacity-50"><i class="bi bi-collection-play"></i></div>
                            <h3 class="h4 mb-2">Aucune playlist</h3>
                            <p class="text-secondary">Créez votre première playlist pour organiser vos vidéos favorites</p>
                        </div>
                    `;
                    return;
                }

                // Render playlists
                container.innerHTML = playlists.map(playlist => renderPlaylistCard(playlist)).join('');

                // Attach click handlers
                document.querySelectorAll('.playlist-card').forEach(card => {
                    card.addEventListener('click', (e) => {
                        if (!e.target.closest('.d-flex.gap-1')) {
                            // Use d-tag if available, otherwise event ID
                            const playlistId = card.dataset.playlistDtag || card.dataset.playlistId;
                            viewPlaylist(playlistId);
                        }
                    });
                });
                
                // Initialize tooltips
                const tooltipTriggerList = [].slice.call(container.querySelectorAll('[data-bs-toggle="tooltip"]'));
                tooltipTriggerList.map(function (tooltipTriggerEl) {
                    return new bootstrap.Tooltip(tooltipTriggerEl);
                });

            } catch (error) {
                console.error('Error loading playlists:', error);
                container.innerHTML = `
                    <div class="alert alert-danger d-flex align-items-center gap-2" role="alert">
                        <i class="bi bi-exclamation-triangle-fill"></i>
                        <div>Erreur lors du chargement des playlists: ${error.message}</div>
                    </div>
                `;
            }
        }

        /**
         * Fetch user's playlists from NOSTR
         */
        async function fetchUserPlaylists() {
            // Ensure we have relay and userPubkey
            let currentRelay = nostrRelay;
            let currentUserPubkey = userPubkey;
            
            // Try parent if in iframe
            if (isInIframe && window.parent) {
                if (!currentRelay && window.parent.nostrRelay) {
                    currentRelay = window.parent.nostrRelay;
                }
                if (!currentUserPubkey && window.parent.userPubkey) {
                    currentUserPubkey = window.parent.userPubkey;
                }
            }
            
            if (!currentRelay || !currentUserPubkey) {
                console.error('No relay or userPubkey available');
                return [];
            }
            
            return new Promise(async (resolve) => {
                // First, fetch deletion events (kind 5) to know which playlists are deleted
                const deletions = await new Promise((resolveDeletions) => {
                    const deleteSub = currentRelay.sub([{
                        kinds: [5], // NIP-09 deletion events
                        authors: [currentUserPubkey],
                        limit: 1000
                    }]);
                    
                    const deletionSet = new Set();
                    const deleteTimeout = setTimeout(() => {
                        deleteSub.unsub();
                        resolveDeletions(deletionSet);
                    }, 3000);
                    
                    deleteSub.on('event', (event) => {
                        // Collect all deleted event IDs and coordinates
                        event.tags.forEach(tag => {
                            if (tag[0] === 'e') {
                                deletionSet.add(tag[1]); // Event ID
                            } else if (tag[0] === 'a') {
                                deletionSet.add(tag[1]); // Event coordinate (kind:pubkey:d-tag)
                            }
                        });
                    });
                    
                    deleteSub.on('eose', () => {
                        clearTimeout(deleteTimeout);
                        deleteSub.unsub();
                        resolveDeletions(deletionSet);
                    });
                });
                
                // Now fetch playlists
                const sub = currentRelay.sub([{
                    kinds: [30005, 10001],
                    authors: [currentUserPubkey],
                    limit: 100
                }]);

                const playlists = [];
                const timeout = setTimeout(() => {
                    sub.unsub();
                    resolve(playlists);
                }, 5000);

                sub.on('event', (event) => {
                    try {
                        // Check if this playlist is deleted
                        const dTag = event.tags.find(t => t[0] === 'd')?.[1];
                        const isDeleted = deletions.has(event.id) || 
                                         (dTag && deletions.has(`${event.kind}:${event.pubkey}:${dTag}`));
                        
                        if (isDeleted) {
                            // Skip deleted playlists
                            return;
                        }
                        
                        const playlistData = JSON.parse(event.content);
                        
                        playlists.push({
                            id: event.id,
                            dTag: dTag, // Store d-tag for parameterized events
                            name: playlistData.name || 'Untitled',
                            description: playlistData.description || '',
                            videos: playlistData.videos || [],
                            createdAt: event.created_at,
                            event: event
                        });
                    } catch (e) {
                        console.warn('Error parsing playlist:', e);
                    }
                });

                sub.on('eose', () => {
                    clearTimeout(timeout);
                    sub.unsub();
                    resolve(playlists);
                });
            });
        }

        /**
         * Render playlist card
         */
        function renderPlaylistCard(playlist) {
            const videoCount = playlist.videos.length;
            const createdDate = new Date(playlist.createdAt * 1000).toLocaleDateString('fr-FR');
            // Use d-tag if available (for kind 30005), otherwise use event ID
            const playlistIdentifier = playlist.dTag || playlist.id;

            return `
                <div class="playlist-card rounded-3 p-3" data-playlist-id="${playlist.id}" data-playlist-dtag="${playlist.dTag || ''}">
                    <div class="d-flex justify-content-between align-items-start mb-2">
                        <div class="flex-grow-1 me-2">
                            <h5 class="mb-1">${escapeHtmlText(playlist.name)}</h5>
                            <div class="d-flex gap-2 small text-secondary">
                                <span><i class="bi bi-collection-play"></i> ${videoCount} vidéo(s)</span>
                                <span>•</span>
                                <span><i class="bi bi-calendar3"></i> ${createdDate}</span>
                            </div>
                        </div>
                        <div class="d-flex gap-1" onclick="event.stopPropagation();">
                            <button class="btn btn-sm btn-outline-info rounded-circle" onclick="sharePlaylist('${playlistIdentifier}')" title="Partager" data-bs-toggle="tooltip">
                                <i class="bi bi-share"></i>
                            </button>
                            <button class="btn btn-sm btn-outline-primary rounded-circle" onclick="exportPlaylistUI('${playlist.id}')" title="Exporter" data-bs-toggle="tooltip">
                                <i class="bi bi-download"></i>
                            </button>
                            <button class="btn btn-sm btn-outline-danger rounded-circle" onclick="deletePlaylist('${playlist.id}')" title="Supprimer" data-bs-toggle="tooltip">
                                <i class="bi bi-trash"></i>
                            </button>
                        </div>
                    </div>
                    ${playlist.description ? `<p class="small text-secondary mb-2 lh-base">${escapeHtmlText(playlist.description)}</p>` : ''}
                    ${videoCount > 0 ? `
                        <div class="d-grid gap-2 mt-3" style="grid-template-columns: repeat(4, 1fr);">
                            ${Array(Math.min(videoCount, 4)).fill(0).map(() => `
                                <div class="playlist-video-thumbnail rounded-2">
                                    <i class="bi bi-film"></i>
                                </div>
                            `).join('')}
                        </div>
                    ` : ''}
                </div>
            `;
        }

        /**
         * Open create playlist modal
         */
        function openCreatePlaylistModal() {
            // Check both local and parent userPubkey
            const currentUserPubkey = userPubkey || (window.parent && window.parent.userPubkey) || null;
            
            if (!currentUserPubkey) {
                connectAndLoadPlaylists();
                return;
            }

            const modalEl = document.getElementById('createPlaylistModal');
            const modal = new bootstrap.Modal(modalEl);
            modal.show();
            
            // Focus on name input after modal is shown
            modalEl.addEventListener('shown.bs.modal', function () {
                document.getElementById('playlistName').focus();
            }, { once: true });
        }
        
        // Expose function globally for onclick handlers
        window.openCreatePlaylistModal = openCreatePlaylistModal;

        /**
         * Close create playlist modal
         */
        function closeCreatePlaylistModal() {
            const modalEl = document.getElementById('createPlaylistModal');
            const modal = bootstrap.Modal.getInstance(modalEl);
            if (modal) {
                modal.hide();
            }
            
            const form = document.getElementById('createPlaylistForm');
            const errorDiv = document.getElementById('createPlaylistError');
            
            if (form) {
                form.reset();
            }
            if (errorDiv) {
                errorDiv.classList.add('d-none');
            }
        }
        
        // Expose function globally
        window.closeCreatePlaylistModal = closeCreatePlaylistModal;

        /**
         * Show toast notification (Bootstrap Toast)
         */
        function showToast(message, type = 'success', duration = 4000) {
            // Remove existing custom toasts (non-Bootstrap)
            const existingToasts = document.querySelectorAll('.toast:not(.toast-bootstrap)');
            existingToasts.forEach(toast => toast.remove());
            
            // Create Bootstrap toast container if it doesn't exist
            let toastContainer = document.getElementById('toastContainer');
            if (!toastContainer) {
                toastContainer = document.createElement('div');
                toastContainer.id = 'toastContainer';
                toastContainer.className = 'toast-container position-fixed bottom-0 end-0 p-3';
                toastContainer.style.zIndex = '10001';
                document.body.appendChild(toastContainer);
            }
            
            const icons = {
                success: 'bi-check-circle-fill text-success',
                error: 'bi-x-circle-fill text-danger',
                warning: 'bi-exclamation-triangle-fill text-warning',
                info: 'bi-info-circle-fill text-info'
            };
            
            const bgColors = {
                success: 'bg-success',
                error: 'bg-danger',
                warning: 'bg-warning',
                info: 'bg-info'
            };
            
            const toastEl = document.createElement('div');
            toastEl.className = 'toast toast-bootstrap align-items-center text-white border-0';
            toastEl.classList.add(bgColors[type] || bgColors.info);
            toastEl.setAttribute('role', 'alert');
            toastEl.setAttribute('aria-live', 'assertive');
            toastEl.setAttribute('aria-atomic', 'true');
            
            toastEl.innerHTML = `
                <div class="d-flex">
                    <div class="toast-body d-flex align-items-center gap-2">
                        <i class="bi ${icons[type] || icons.info}"></i>
                        <span>${escapeHtmlText(message)}</span>
                    </div>
                    <button type="button" class="btn-close btn-close-white me-2 m-auto" data-bs-dismiss="toast" aria-label="Close"></button>
                </div>
            `;
            
            toastContainer.appendChild(toastEl);
            
            const bsToast = new bootstrap.Toast(toastEl, {
                delay: duration,
                autohide: true
            });
            bsToast.show();
            
            // Remove from DOM after hidden
            toastEl.addEventListener('hidden.bs.toast', () => {
                toastEl.remove();
            });
        }
        
        // Expose globally
        window.showToast = showToast;

        /**
         * Handle create playlist form submission
         */
        async function handleCreatePlaylist(event) {
            event.preventDefault();

            const name = document.getElementById('playlistName').value.trim();
            const description = document.getElementById('playlistDescription').value.trim();
            const errorDiv = document.getElementById('createPlaylistError');
            const submitBtn = event.target.querySelector('button[type="submit"]');

            if (!name) {
                errorDiv.textContent = 'Le nom de la playlist est requis';
                errorDiv.classList.remove('d-none');
                return;
            }

            try {
                errorDiv.classList.add('d-none');
                submitBtn.disabled = true;
                submitBtn.innerHTML = '<span class="spinner-border spinner-border-sm me-2" role="status" aria-hidden="true"></span>Création...';
                
                // Create playlist with empty videos array
                const playlist = await createPlaylist(name, description, []);

                if (playlist) {
                    showToast(`Playlist "${name}" créée avec succès !`, 'success');
                    closeCreatePlaylistModal();
                    
                    // Small delay for smoother UX
                    await new Promise(resolve => setTimeout(resolve, 300));
                    await loadUserPlaylists();
                } else {
                    throw new Error('Failed to create playlist');
                }
            } catch (error) {
                console.error('Error creating playlist:', error);
                errorDiv.textContent = `Erreur: ${error.message}`;
                errorDiv.classList.remove('d-none');
                showToast(`Erreur: ${error.message}`, 'error');
                submitBtn.disabled = false;
                submitBtn.textContent = 'Créer';
            }
        }
        
        // Expose function globally for onsubmit handler
        window.handleCreatePlaylist = handleCreatePlaylist;

        /**
         * Load and display a specific playlist by ID
         */
        async function loadSpecificPlaylist(playlistId) {
            const container = document.getElementById('playlistsContainer');
            
            // Try to get relay from parent if in iframe
            if (isInIframe && window.parent) {
                if (window.parent.nostrRelay && !nostrRelay) {
                    nostrRelay = window.parent.nostrRelay;
                    window.nostrRelay = nostrRelay;
                }
                if (window.parent.isNostrConnected !== undefined && !isNostrConnected) {
                    isNostrConnected = window.parent.isNostrConnected;
                    window.isNostrConnected = isNostrConnected;
                }
                if (window.parent.userPubkey && !userPubkey) {
                    userPubkey = window.parent.userPubkey;
                    window.userPubkey = userPubkey;
                }
            }
            
            // If not in iframe or connection not available from parent, establish local connection
            if (!nostrRelay || !isNostrConnected || !userPubkey) {
                // First, try to connect via common.js if not connected
                if (!userPubkey && typeof connectNostr === 'function') {
                    const pubkey = await connectNostr();
                    if (pubkey) {
                        userPubkey = pubkey;
                        window.userPubkey = pubkey;
                    }
                }
                
                // Then, connect to relay
                if (!nostrRelay || !isNostrConnected) {
                    if (typeof connectToRelay === 'function') {
                        await connectToRelay();
                        // Update variables after connection
                        if (typeof nostrRelay !== 'undefined') {
                            window.nostrRelay = nostrRelay;
                        }
                        if (typeof isNostrConnected !== 'undefined') {
                            window.isNostrConnected = isNostrConnected;
                        }
                    } else if (isInIframe && window.parent && typeof window.parent.connectToRelay === 'function') {
                        await window.parent.connectToRelay();
                        nostrRelay = window.parent.nostrRelay || null;
                        isNostrConnected = window.parent.isNostrConnected || false;
                    }
                }
            }

            // For viewing a specific playlist, we don't require user connection
            // We only need relay connection to fetch the playlist
            
            // Try to establish relay connection if not available
            if (!nostrRelay || !isNostrConnected) {
                // Try to connect to relay (this doesn't require user authentication for reading)
                if (typeof connectToRelay === 'function') {
                    try {
                        await connectToRelay();
                    } catch (e) {
                        console.warn('Could not connect to relay:', e);
                    }
                }
                
                // Try to get relay from parent if in iframe
                if (isInIframe && window.parent && window.parent.nostrRelay) {
                    nostrRelay = window.parent.nostrRelay;
                    window.nostrRelay = nostrRelay;
                    isNostrConnected = window.parent.isNostrConnected || false;
                }
            }
            
            // If still no relay, try to create a connection to default relay for reading
            if (!nostrRelay) {
                if (typeof DEFAULT_RELAYS !== 'undefined' && DEFAULT_RELAYS.length > 0) {
                    const relayUrl = DEFAULT_RELAYS[0];
                    if (typeof SimplePool !== 'undefined') {
                        const pool = new SimplePool();
                        try {
                            const relay = await pool.ensureRelay(relayUrl);
                            nostrRelay = relay;
                            window.nostrRelay = relay;
                            isNostrConnected = true;
                        } catch (e) {
                            console.error('Could not connect to default relay:', e);
                        }
                    } else if (typeof connect === 'function' && typeof relayInit === 'function') {
                        // Try using nostr-tools connect function
                        try {
                            const relay = await connect(relayUrl);
                            nostrRelay = relay;
                            window.nostrRelay = relay;
                            isNostrConnected = true;
                        } catch (e) {
                            console.error('Could not connect to default relay:', e);
                        }
                    }
                }
            }

            if (!nostrRelay || !isNostrConnected) {
                container.innerHTML = `
                    <div class="alert alert-danger d-flex align-items-center gap-2" role="alert">
                        <i class="bi bi-exclamation-triangle-fill"></i>
                        <div>Impossible de se connecter au relay NOSTR pour charger la playlist. Vérifiez votre connexion internet.</div>
                    </div>
                `;
                return;
            }

            try {
                container.innerHTML = '<div class="text-center py-5 text-secondary">Chargement de la playlist...</div>';

                // Check if this playlist is deleted (kind 5)
                // Note: For shared playlists, we may not know the author, so we check more broadly
                const isDeleted = await new Promise((resolve) => {
                    // Build filter - if we have playlist author info, we can filter by it
                    const filter = {
                        kinds: [5],
                        limit: 1000
                    };
                    
                    // If we know the playlist's author (from event), filter by it
                    // Otherwise, check all deletion events (might be slower but works for shared playlists)
                    
                    const deleteSub = nostrRelay.sub([filter]);
                    
                    let deleted = false;
                    const deleteTimeout = setTimeout(() => {
                        deleteSub.unsub();
                        resolve(deleted);
                    }, 2000);
                    
                    deleteSub.on('event', (event) => {
                        const isEventId = /^[0-9a-f]{64}$/i.test(playlistId);
                        event.tags.forEach(tag => {
                            if (tag[0] === 'e' && tag[1] === playlistId) {
                                deleted = true;
                            } else if (tag[0] === 'a' && !isEventId) {
                                // Check if the coordinate matches (for any author)
                                const dTag = playlistId;
                                if (tag[1].includes(`:${dTag}`)) {
                                    deleted = true;
                                }
                            }
                        });
                    });
                    
                    deleteSub.on('eose', () => {
                        clearTimeout(deleteTimeout);
                        deleteSub.unsub();
                        resolve(deleted);
                    });
                });
                
                if (isDeleted) {
                    container.innerHTML = `
                        <div class="alert alert-warning d-flex align-items-center gap-2 mb-3" role="alert">
                            <i class="bi bi-exclamation-triangle-fill"></i>
                            <div>Cette playlist a été supprimée</div>
                        </div>
                        <button class="btn btn-primary rounded-pill d-inline-flex align-items-center gap-2" onclick="window.location.href='/playlist'">
                            <i class="bi bi-arrow-left"></i> Retour aux playlists
                        </button>
                    `;
                    return;
                }

                // Fetch the specific playlist event (support both formats)
                    // Check if it's an event ID (64 hex) or d-tag identifier
                    const isEventId = /^[0-9a-f]{64}$/i.test(playlistId);
                    
                    const playlist = await new Promise((resolve) => {
                        let filter;
                        if (isEventId) {
                            // Fetch by event ID (works without knowing author)
                            filter = {
                                kinds: [30005, 10001],
                                ids: [playlistId],
                                limit: 1
                            };
                        } else {
                            // Fetch by d-tag identifier (parameterized replaceable event)
                            // For shared playlists, we don't know the author, so we need to search without author filter
                            // This might be slower but allows viewing shared playlists
                            // Try to get author from URL or try without author filter
                            const urlParams = new URLSearchParams(window.location.search);
                            const authorParam = urlParams.get('author');
                            
                            if (authorParam && /^[0-9a-f]{64}$/i.test(authorParam)) {
                                // We have an author, use it for faster lookup
                                filter = {
                                    kinds: [30005, 10001],
                                    authors: [authorParam],
                                    '#d': [playlistId],
                                    limit: 1
                                };
                            } else {
                                // No author provided, search more broadly (this will be slower)
                                // We'll need to fetch multiple events and filter
                                filter = {
                                    kinds: [30005, 10001],
                                    '#d': [playlistId],
                                    limit: 100 // Might return multiple if different authors have same d-tag
                                };
                            }
                        }
                    
                    const sub = nostrRelay.sub([filter]);

                    let playlistEvent = null;
                    sub.on('event', (event) => {
                        // If we searched without author filter, take the first match
                        if (!playlistEvent || !isEventId) {
                            playlistEvent = event;
                        }
                    });

                    sub.on('eose', () => {
                        sub.unsub();
                        resolve(playlistEvent);
                    });

                    setTimeout(() => {
                        sub.unsub();
                        resolve(playlistEvent);
                    }, 5000);
                });

                if (!playlist) {
                    container.innerHTML = `
                        <div class="alert alert-danger d-flex align-items-center gap-2" role="alert">
                            <i class="bi bi-exclamation-triangle-fill"></i>
                            <div>Playlist non trouvée</div>
                        </div>
                    `;
                    return;
                }

                // Parse playlist data
                let playlistData;
                try {
                    playlistData = JSON.parse(playlist.content);
                } catch (e) {
                    container.innerHTML = `
                        <div class="alert alert-danger d-flex align-items-center gap-2" role="alert">
                            <i class="bi bi-exclamation-triangle-fill"></i>
                            <div>Erreur lors du parsing de la playlist</div>
                        </div>
                    `;
                    return;
                }

                // Update header to show playlist name
                const header = document.querySelector('.playlist-manager-header h1');
                if (header) {
                    header.textContent = `📋 ${escapeHtmlText(playlistData.name || 'Playlist')}`;
                }

                // Hide create button when viewing specific playlist
                const createBtn = document.querySelector('.btn.btn-primary.rounded-pill');
                if (createBtn) {
                    createBtn.style.display = 'none';
                }

                // Add back button first
                const backBtn = document.createElement('button');
                backBtn.innerHTML = '<i class="bi bi-arrow-left me-2"></i>Retour aux playlists';
                backBtn.className = 'btn btn-secondary rounded-pill mb-4';
                backBtn.onclick = () => {
                    window.location.href = '/playlist';
                };
                container.innerHTML = '';
                container.appendChild(backBtn);
                
                // Add description if available
                if (playlistData.description) {
                    const descDiv = document.createElement('div');
                    descDiv.className = 'alert alert-secondary mb-4';
                    descDiv.textContent = playlistData.description;
                    container.appendChild(descDiv);
                }
                
                // Check if current user is the playlist owner (enable edit mode)
                // userPubkey might be undefined if viewing shared playlist without connection
                const isPlaylistOwner = userPubkey && playlist.pubkey === userPubkey;
                
                // Add playlist management header with actions
                if (isPlaylistOwner) {
                    const actionsHeader = document.createElement('div');
                    actionsHeader.className = 'd-flex gap-2 mb-4 flex-wrap';
                    actionsHeader.innerHTML = `
                        <button class="btn btn-sm btn-outline-primary rounded-pill d-flex align-items-center gap-2 playlist-manage-btn" onclick="exportPlaylistUI('${playlist.id}')" title="Exporter la playlist" data-bs-toggle="tooltip">
                            <i class="bi bi-download"></i> Exporter
                        </button>
                        <button class="btn btn-sm btn-outline-warning rounded-pill d-flex align-items-center gap-2 playlist-manage-btn" onclick="editPlaylistMetadataUI('${playlist.id}')" title="Modifier les informations" data-bs-toggle="tooltip">
                            <i class="bi bi-pencil"></i> Modifier
                        </button>
                        <button class="btn btn-sm btn-outline-danger rounded-pill d-flex align-items-center gap-2 playlist-manage-btn" onclick="deletePlaylistUI('${playlist.id}')" title="Supprimer la playlist" data-bs-toggle="tooltip">
                            <i class="bi bi-trash"></i> Supprimer
                        </button>
                    `;
                    container.appendChild(actionsHeader);
                    
                    // Initialize tooltips
                    const tooltipTriggerList = [].slice.call(actionsHeader.querySelectorAll('[data-bs-toggle="tooltip"]'));
                    tooltipTriggerList.map(function (tooltipTriggerEl) {
                        return new bootstrap.Tooltip(tooltipTriggerEl);
                    });
                }
                
                // Load and display playlist videos in a draggable list with embedded player
                const videosContainer = document.createElement('div');
                videosContainer.id = 'playlistVideosList';
                videosContainer.className = 'video-list-container';
                videosContainer.dataset.playlistId = playlist.id;
                videosContainer.dataset.isEditMode = isPlaylistOwner ? 'true' : 'false';
                container.appendChild(videosContainer);
                
                // Render videos in list format
                await renderPlaylistVideosList(playlistData.videos || [], videosContainer, playlist.id, isPlaylistOwner);

            } catch (error) {
                console.error('Error loading playlist:', error);
                container.innerHTML = `
                    <div class="alert alert-danger d-flex align-items-center gap-2" role="alert">
                        <i class="bi bi-exclamation-triangle-fill"></i>
                        <div>Erreur lors du chargement de la playlist: ${error.message}</div>
                    </div>
                `;
            }
        }

        /**
         * Render playlist videos in a draggable list with embedded player
         */
        async function renderPlaylistVideosList(videos, container, playlistId, isEditMode) {
            if (!videos || videos.length === 0) {
                container.innerHTML = `
                    <div class="empty-playlist">
                        <i class="bi bi-play-circle"></i>
                        <h4>Aucune vidéo dans cette playlist</h4>
                        <p class="text-muted">Ajoutez des vidéos depuis YouTube pour commencer</p>
                    </div>
                `;
                return;
            }

            // Clear container
            container.innerHTML = '';
            
            // Store currently playing video
            let currentPlayingVideo = null;
            
            // Helper function to extract YouTube video ID
            function extractYouTubeId(url) {
                if (!url) return null;
                const match = url.match(/(?:youtube\.com\/(?:[^\/]+\/.+\/|(?:v|e(?:mbed)?)\/|.*[?&]v=)|youtu\.be\/)([^"&?\/\s]{11})/);
                return match ? match[1] : null;
            }
            
            // Helper function to get YouTube embed URL
            function getYouTubeEmbedUrl(videoId) {
                return `https://www.youtube.com/embed/${videoId}?autoplay=1&rel=0`;
            }
            
            // Helper function to format duration
            function formatDuration(seconds) {
                if (!seconds) return '';
                const mins = Math.floor(seconds / 60);
                const secs = seconds % 60;
                return `${mins}:${secs.toString().padStart(2, '0')}`;
            }
            
            // Create video items
            videos.forEach((video, index) => {
                const videoItem = document.createElement('div');
                videoItem.className = 'video-list-item';
                videoItem.dataset.videoIndex = index;
                videoItem.dataset.videoId = video.id || video.eventId || index;
                
                const videoUrl = video.url || video.youtubeUrl || '';
                const videoId = extractYouTubeId(videoUrl);
                const thumbnailUrl = video.thumbnail || (videoId ? `https://i.ytimg.com/vi/${videoId}/mqdefault.jpg` : '');
                const title = video.title || 'Sans titre';
                const duration = formatDuration(video.duration || video.length);
                const channel = video.channel || video.channelName || '';
                
                videoItem.innerHTML = `
                    ${isEditMode ? `
                        <div class="video-drag-handle" draggable="true">
                            <i class="bi bi-grip-vertical"></i>
                        </div>
                    ` : ''}
                    <div class="video-thumbnail-container" data-video-url="${escapeHtmlText(videoUrl)}" data-video-id="${videoId || ''}">
                        ${thumbnailUrl ? `<img src="${escapeHtmlText(thumbnailUrl)}" alt="${escapeHtmlText(title)}" loading="lazy">` : `
                            <div style="width: 100%; height: 100%; display: flex; align-items: center; justify-content: center; color: #666;">
                                <i class="bi bi-film" style="font-size: 48px;"></i>
                            </div>
                        `}
                        <div class="play-overlay">
                            <i class="bi bi-play-circle-fill"></i>
                        </div>
                    </div>
                    <div class="video-info">
                        <h4 class="video-title">${escapeHtmlText(title)}</h4>
                        <div class="video-meta">
                            ${channel ? `<span><i class="bi bi-person"></i> ${escapeHtmlText(channel)}</span>` : ''}
                            ${duration ? `<span><i class="bi bi-clock"></i> ${duration}</span>` : ''}
                        </div>
                    </div>
                    ${isEditMode ? `
                        <div class="video-actions">
                            <button class="remove-video-btn" onclick="removeVideoFromPlaylistUI('${playlistId}', '${videoItem.dataset.videoId}', this)">
                                <i class="bi bi-trash"></i> Retirer
                            </button>
                        </div>
                    ` : ''}
                `;
                
                container.appendChild(videoItem);
                
                // Handle click on thumbnail to play video
                const thumbnail = videoItem.querySelector('.video-thumbnail-container');
                thumbnail.addEventListener('click', () => {
                    if (!videoId) {
                        showToast('URL vidéo invalide', 'error');
                        return;
                    }
                    
                    // Close any currently playing video
                    if (currentPlayingVideo && currentPlayingVideo !== videoItem) {
                        const existingPlayer = currentPlayingVideo.querySelector('.video-player-embedded');
                        if (existingPlayer) {
                            existingPlayer.remove();
                            currentPlayingVideo.classList.remove('video-item-expanded');
                        }
                    }
                    
                    // Toggle current video
                    const existingPlayer = videoItem.querySelector('.video-player-embedded');
                    if (existingPlayer) {
                        // Already playing, close it
                        existingPlayer.remove();
                        videoItem.classList.remove('video-item-expanded');
                        currentPlayingVideo = null;
                    } else {
                        // Not playing, open it
                        const playerDiv = document.createElement('div');
                        playerDiv.className = 'video-player-embedded';
                        playerDiv.innerHTML = `<iframe src="${getYouTubeEmbedUrl(videoId)}" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>`;
                        
                        videoItem.classList.add('video-item-expanded');
                        videoItem.appendChild(playerDiv);
                        currentPlayingVideo = videoItem;
                        
                        // Scroll to video
                        videoItem.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
                    }
                });
            });
            
            // Setup drag and drop for reordering (only in edit mode)
            if (isEditMode) {
                setupDragAndDrop(container, playlistId);
            }
        }
        
        /**
         * Setup drag and drop for video reordering
         */
        function setupDragAndDrop(container, playlistId) {
            let draggedElement = null;
            let draggedIndex = null;
            let originalOrder = [];
            
            const updateIndices = () => {
                const items = container.querySelectorAll('.video-list-item');
                items.forEach((item, index) => {
                    item.dataset.videoIndex = index;
                });
            };
            
            const getItems = () => {
                return container.querySelectorAll('.video-list-item');
            };
            
            container.addEventListener('dragstart', (e) => {
                if (!e.target.closest('.video-drag-handle')) return;
                
                draggedElement = e.target.closest('.video-list-item');
                if (!draggedElement) return;
                
                const items = getItems();
                draggedIndex = Array.from(items).indexOf(draggedElement);
                originalOrder = Array.from(items);
                
                draggedElement.classList.add('dragging');
                e.dataTransfer.effectAllowed = 'move';
                e.dataTransfer.setData('text/plain', draggedIndex.toString());
            });
            
            container.addEventListener('dragend', () => {
                if (draggedElement) {
                    draggedElement.classList.remove('dragging');
                }
                getItems().forEach(i => i.classList.remove('drag-over'));
                updateIndices();
            });
            
            container.addEventListener('dragover', (e) => {
                e.preventDefault();
                e.dataTransfer.dropEffect = 'move';
                
                if (!draggedElement) return;
                
                const afterElement = getDragAfterElement(container, e.clientY);
                const items = getItems();
                
                items.forEach(i => i.classList.remove('drag-over'));
                
                if (afterElement == null) {
                    container.appendChild(draggedElement);
                } else {
                    container.insertBefore(draggedElement, afterElement);
                }
                
                // Highlight drop target
                const currentItem = e.target.closest('.video-list-item');
                if (currentItem && currentItem !== draggedElement) {
                    currentItem.classList.add('drag-over');
                }
            });
            
            container.addEventListener('drop', async (e) => {
                e.preventDefault();
                
                if (!draggedElement || draggedIndex === null) return;
                
                const items = getItems();
                const newIndex = Array.from(items).indexOf(draggedElement);
                
                if (newIndex !== draggedIndex && newIndex >= 0) {
                    // Save original index before reordering
                    const videoId = draggedElement.dataset.videoId;
                    
                    // Show loading state
                    showToast('Mise à jour de l\'ordre...', 'info', 2000);
                    
                    // Reorder videos in playlist
                    try {
                        await moveVideoInPlaylistUI(playlistId, draggedIndex, newIndex);
                    } catch (error) {
                        console.error('Error reordering:', error);
                        // Revert visual order on error
                        if (originalOrder.length > 0) {
                            container.innerHTML = '';
                            originalOrder.forEach(item => container.appendChild(item));
                            updateIndices();
                        }
                    }
                }
                
                items.forEach(i => i.classList.remove('drag-over'));
                draggedElement = null;
                draggedIndex = null;
            });
        }
        
        /**
         * Get the element after which to insert the dragged element
         */
        function getDragAfterElement(container, y) {
            const draggableElements = [...container.querySelectorAll('.video-list-item:not(.dragging)')];
            
            return draggableElements.reduce((closest, child) => {
                const box = child.getBoundingClientRect();
                const offset = y - box.top - box.height / 2;
                
                if (offset < 0 && offset > closest.offset) {
                    return { offset: offset, element: child };
                } else {
                    return closest;
                }
            }, { offset: Number.NEGATIVE_INFINITY }).element;
        }
        
        // Expose function globally
        window.renderPlaylistVideosList = renderPlaylistVideosList;

        /**
         * View playlist details
         */
        function viewPlaylist(playlistId) {
            // Redirect to playlist view with ID parameter
            window.location.href = `/playlist?id=${playlistId}`;
        }
        
        // Expose function globally
        window.viewPlaylist = viewPlaylist;
        window.loadSpecificPlaylist = loadSpecificPlaylist;

        /**
         * Share playlist
         */
        async function sharePlaylist(playlistId) {
            // Use d-tag or event ID for sharing
            const playlistUrl = `${window.location.origin}/playlist?id=${playlistId}`;
            
            try {
                await navigator.clipboard.writeText(playlistUrl);
                showToast('Lien copié dans le presse-papiers !', 'success');
            } catch (error) {
                console.error('Error copying link:', error);
                showToast('Erreur lors de la copie du lien', 'error');
            }
        }
        
        // Expose function globally
        window.sharePlaylist = sharePlaylist;

        /**
         * Delete playlist (from playlist list view)
         */
        async function deletePlaylist(playlistId) {
            await deletePlaylistUI(playlistId);
        }
        
        /**
         * Remove video from playlist (UI handler)
         */
        async function removeVideoFromPlaylistUI(playlistId, videoEventId, buttonElement) {
            if (!confirm('Êtes-vous sûr de vouloir retirer cette vidéo de la playlist ?')) {
                return;
            }
            
            const originalText = buttonElement.textContent;
            buttonElement.disabled = true;
            buttonElement.textContent = '⏳';
            
            try {
                if (typeof window.removeVideoFromPlaylist === 'function') {
                    const success = await window.removeVideoFromPlaylist(playlistId, videoEventId);
                    if (success) {
                        showToast('Vidéo retirée de la playlist', 'success');
                        // Reload playlist
                        await new Promise(resolve => setTimeout(resolve, 300));
                        await loadSpecificPlaylist(playlistId);
                    } else {
                        showToast('Erreur lors de la suppression de la vidéo', 'error');
                        buttonElement.disabled = false;
                        buttonElement.textContent = originalText;
                    }
                } else {
                    throw new Error('removeVideoFromPlaylist function not available');
                }
            } catch (error) {
                console.error('Error removing video:', error);
                alert('❌ Erreur: ' + error.message);
                buttonElement.disabled = false;
                buttonElement.textContent = originalText;
            }
        }
        
        /**
         * Move video in playlist (UI handler)
         */
        async function moveVideoInPlaylistUI(playlistId, oldIndex, newIndex) {
            if (typeof window.reorderPlaylistVideos === 'function') {
                try {
                    const success = await window.reorderPlaylistVideos(playlistId, oldIndex, newIndex);
                    if (success) {
                        showToast('Ordre de la playlist mis à jour', 'success');
                        // Reload playlist to show new order
                        await new Promise(resolve => setTimeout(resolve, 300));
                        await loadSpecificPlaylist(playlistId);
                    } else {
                        showToast('Erreur lors du déplacement de la vidéo', 'error');
                    }
                } catch (error) {
                    console.error('Error moving video:', error);
                    showToast(`Erreur: ${error.message}`, 'error');
                }
            } else {
                alert('❌ Fonction de réorganisation non disponible');
            }
        }
        
        /**
         * Export playlist (UI handler)
         */
        async function exportPlaylistUI(playlistId) {
            if (typeof window.exportPlaylist === 'function') {
                try {
                    await window.exportPlaylist(playlistId);
                    showToast('Playlist exportée avec succès !', 'success');
                } catch (error) {
                    console.error('Error exporting playlist:', error);
                    showToast(`Erreur lors de l'export: ${error.message}`, 'error');
                }
            } else {
                showToast('Fonction d\'export non disponible', 'error');
            }
        }
        
        /**
         * Edit playlist metadata (UI handler)
         */
        async function editPlaylistMetadataUI(playlistId) {
            // Fetch playlist to get current data
            if (typeof window.fetchPlaylistEvent !== 'function') {
                showToast('Fonction de récupération non disponible', 'error');
                return;
            }
            
            try {
                const playlistEvent = await window.fetchPlaylistEvent(playlistId);
                if (!playlistEvent) {
                    showToast('Playlist non trouvée', 'error');
                    return;
                }
                
                const playlistData = JSON.parse(playlistEvent.content);
                
                // Show edit modal (reuse create modal structure)
                const modalEl = document.getElementById('createPlaylistModal');
                const form = document.getElementById('createPlaylistForm');
                const nameInput = document.getElementById('playlistName');
                const descInput = document.getElementById('playlistDescription');
                const title = document.getElementById('createPlaylistModalLabel');
                const errorDiv = document.getElementById('createPlaylistError');
                
                // Update modal title
                if (title) title.textContent = 'Modifier la playlist';
                
                // Pre-fill form
                nameInput.value = playlistData.name || '';
                descInput.value = playlistData.description || '';
                errorDiv.classList.add('d-none');
                
                // Show modal
                const modal = new bootstrap.Modal(modalEl);
                modal.show();
                
                // Focus and select name input after modal is shown
                modalEl.addEventListener('shown.bs.modal', function () {
                    nameInput.focus();
                    nameInput.select();
                }, { once: true });
                
                // Replace form handler temporarily
                const originalHandler = form.onsubmit;
                form.onsubmit = async (e) => {
                    e.preventDefault();
                    
                    const newName = nameInput.value.trim();
                    const newDescription = descInput.value.trim();
                    
                    if (!newName) {
                        errorDiv.textContent = 'Le nom ne peut pas être vide';
                        errorDiv.classList.remove('d-none');
                        return;
                    }
                    
                    const submitBtn = form.querySelector('button[type="submit"]');
                    submitBtn.disabled = true;
                    submitBtn.innerHTML = '<span class="spinner-border spinner-border-sm me-2" role="status" aria-hidden="true"></span>Mise à jour...';
                    
                    try {
                        if (typeof window.updatePlaylistMetadata === 'function') {
                            const success = await window.updatePlaylistMetadata(playlistId, newName, newDescription);
                            if (success) {
                                showToast(`Playlist "${newName}" mise à jour avec succès !`, 'success');
                                closeCreatePlaylistModal();
                                
                                // Restore original handler
                                form.onsubmit = originalHandler;
                                
                                // Reload playlist
                                await new Promise(resolve => setTimeout(resolve, 300));
                                await loadSpecificPlaylist(playlistId);
                            } else {
                                throw new Error('Erreur lors de la mise à jour');
                            }
                        } else {
                            throw new Error('Fonction de mise à jour non disponible');
                        }
                    } catch (error) {
                        console.error('Error updating playlist:', error);
                        errorDiv.textContent = `Erreur: ${error.message}`;
                        errorDiv.classList.remove('d-none');
                        showToast(`Erreur: ${error.message}`, 'error');
                        submitBtn.disabled = false;
                        submitBtn.textContent = 'Enregistrer';
                    }
                };
                
            } catch (error) {
                console.error('Error editing playlist:', error);
                showToast(`Erreur: ${error.message}`, 'error');
            }
        }
        
        /**
         * Delete playlist (UI handler)
         * Uses NIP-09 kind 5 (Event Deletion Request)
         */
        async function deletePlaylistUI(playlistId) {
            // Show custom confirmation dialog instead of browser confirm
            const confirmed = await new Promise((resolve) => {
                const overlay = document.createElement('div');
                overlay.style.cssText = 'position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0, 0, 0, 0.8); z-index: 10002; display: flex; align-items: center; justify-content: center;';
                
                const dialog = document.createElement('div');
                dialog.style.cssText = 'background: #181818; border: 1px solid #3f3f3f; border-radius: 16px; padding: 32px; max-width: 400px; width: 90%; box-shadow: 0 20px 60px rgba(0, 0, 0, 0.8);';
                dialog.innerHTML = `
                    <div style="margin-bottom: 24px;">
                        <div style="font-size: 48px; text-align: center; margin-bottom: 16px;">⚠️</div>
                        <h3 style="font-size: 1.3em; margin-bottom: 12px; color: #f1f1f1;">Supprimer la playlist ?</h3>
                        <p style="color: #aaaaaa; line-height: 1.6;">Cette action est irréversible. La playlist sera supprimée définitivement.</p>
                    </div>
                    <div style="display: flex; gap: 12px;">
                        <button id="confirm-delete-cancel" style="flex: 1; background: transparent; border: 1px solid #3f3f3f; color: #f1f1f1; padding: 12px 24px; border-radius: 20px; font-size: 0.9em; cursor: pointer; transition: all 0.2s;">Annuler</button>
                        <button id="confirm-delete-ok" style="flex: 1; background: #ef4444; border: none; color: #ffffff; padding: 12px 24px; border-radius: 20px; font-size: 0.9em; font-weight: 500; cursor: pointer; transition: all 0.2s;">Supprimer</button>
                    </div>
                `;
                
                overlay.appendChild(dialog);
                document.body.appendChild(overlay);
                
                dialog.querySelector('#confirm-delete-cancel').onclick = () => {
                    overlay.remove();
                    resolve(false);
                };
                
                dialog.querySelector('#confirm-delete-ok').onclick = () => {
                    overlay.remove();
                    resolve(true);
                };
                
                overlay.onclick = (e) => {
                    if (e.target === overlay) {
                        overlay.remove();
                        resolve(false);
                    }
                };
            });
            
            if (!confirmed) {
                return;
            }
            
            try {
                // Fetch playlist to get event ID and metadata
                const playlistEvent = await window.fetchPlaylistEvent(playlistId);
                if (!playlistEvent) {
                    alert('❌ Playlist non trouvée');
                    return;
                }
                
                // Verify user is the owner
                if (playlistEvent.pubkey !== userPubkey) {
                    alert('❌ Vous ne pouvez supprimer que vos propres playlists');
                    return;
                }
                
                // Create kind 5 deletion event (NIP-09)
                const dTag = playlistEvent.tags.find(t => t[0] === 'd')?.[1];
                const playlistKind = playlistEvent.kind;
                
                const tags = [
                    ['e', playlistEvent.id], // Event ID reference
                    ['k', String(playlistKind)] // Kind of the event being deleted
                ];
                
                // For parameterized replaceable events (kind 30005), also add 'a' tag with coordinate
                // This ensures all versions of the playlist are deleted
                if (dTag && playlistKind === 30005) {
                    tags.push([
                        'a',
                        `${playlistKind}:${playlistEvent.pubkey}:${dTag}`
                    ]);
                }
                
                const eventTemplate = {
                    kind: 5, // NIP-09: Event Deletion Request
                    created_at: Math.floor(Date.now() / 1000),
                    tags: tags,
                    content: 'Playlist supprimée' // Optional reason
                };
                
                let signedEvent;
                if (window.nostr && typeof window.nostr.signEvent === 'function') {
                    signedEvent = await window.nostr.signEvent(eventTemplate);
                } else {
                    throw new Error("Nostr extension required");
                }
                
                if (!nostrRelay || !isNostrConnected) {
                    if (typeof connectToRelay === 'function') {
                        await connectToRelay();
                    } else {
                        throw new Error("Relay connection required");
                    }
                }
                
                const publishPromise = nostrRelay.publish(signedEvent);
                const timeoutPromise = new Promise((_, reject) => {
                    setTimeout(() => reject(new Error('Publish timeout')), 10000);
                });
                
                await Promise.race([publishPromise, timeoutPromise]);
                
                console.log('✅ Playlist deletion event published (kind 5):', signedEvent.id);
                
                showToast('Playlist supprimée avec succès', 'success');
                
                // Redirect to playlist list after a short delay
                setTimeout(() => {
                    window.location.href = '/playlist';
                }, 1000);
                
            } catch (error) {
                console.error('Error deleting playlist:', error);
                showToast(`Erreur lors de la suppression: ${error.message}`, 'error');
            }
        }
        
        // Expose functions globally
        window.deletePlaylist = deletePlaylist;
        window.removeVideoFromPlaylistUI = removeVideoFromPlaylistUI;
        window.moveVideoInPlaylistUI = moveVideoInPlaylistUI;
        window.exportPlaylistUI = exportPlaylistUI;
        window.editPlaylistMetadataUI = editPlaylistMetadataUI;
        window.deletePlaylistUI = deletePlaylistUI;

        /**
         * Connect and load playlists
         */
        async function connectAndLoadPlaylists() {
            // Try to use parent's connection if in iframe
            if (isInIframe && window.parent && window.parent.userPubkey) {
                userPubkey = window.parent.userPubkey;
                window.userPubkey = userPubkey;
                nostrRelay = window.parent.nostrRelay || null;
                isNostrConnected = window.parent.isNostrConnected || false;
                
                // Ensure relay is connected
                if (!nostrRelay || !isNostrConnected) {
                    if (typeof connectToRelay === 'function') {
                        await connectToRelay();
                        // Update variables after connection
                        if (typeof nostrRelay !== 'undefined') {
                            window.nostrRelay = nostrRelay;
                        }
                        if (typeof isNostrConnected !== 'undefined') {
                            window.isNostrConnected = isNostrConnected;
                        }
                    } else if (window.parent && typeof window.parent.connectToRelay === 'function') {
                        await window.parent.connectToRelay();
                        nostrRelay = window.parent.nostrRelay || null;
                        isNostrConnected = window.parent.isNostrConnected || false;
                    }
                }
                
                // Load appropriate content based on URL
                const targetPlaylistId = getPlaylistIdFromUrl();
                if (targetPlaylistId) {
                    await loadSpecificPlaylist(targetPlaylistId);
                } else {
                    await loadUserPlaylists();
                }
            } else if (typeof connectNostr === 'function') {
                // Not in iframe or no parent connection: use local connection
                const pubkey = await connectNostr();
                if (pubkey) {
                    userPubkey = pubkey;
                    window.userPubkey = pubkey;
                    
                    // Connect to relay
                    if (typeof connectToRelay === 'function') {
                        await connectToRelay();
                        // Update variables after connection
                        if (typeof nostrRelay !== 'undefined') {
                            window.nostrRelay = nostrRelay;
                        }
                        if (typeof isNostrConnected !== 'undefined') {
                            window.isNostrConnected = isNostrConnected;
                        }
                    }
                    
                    // Load appropriate content based on URL
                    const targetPlaylistId = getPlaylistIdFromUrl();
                    if (targetPlaylistId) {
                        await loadSpecificPlaylist(targetPlaylistId);
                    } else {
                        await loadUserPlaylists();
                    }
                } else {
                    alert('❌ Connexion NOSTR échouée. Vérifiez votre extension NOSTR.');
                }
            } else {
                alert('❌ Impossible de se connecter à NOSTR. Assurez-vous que common.js est chargé.');
            }
        }
        
        // Expose function globally
        window.connectAndLoadPlaylists = connectAndLoadPlaylists;

        // Use escapeHtml from youtube.enhancements.js (already globally available)
        // Create a helper function that uses the global escapeHtml
        function escapeHtmlText(text) {
            // Use global escapeHtml if available, otherwise fallback
            if (typeof window.escapeHtml === 'function') {
                return window.escapeHtml(text);
            }
            // Fallback if not available
            if (typeof text !== 'string') return '';
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }
        
        // For compatibility, create alias if escapeHtml is not already defined
        if (typeof window.escapeHtml === 'undefined' || typeof escapeHtml === 'undefined') {
            // Only define if it doesn't exist yet
            try {
                window.escapeHtml = escapeHtmlText;
            } catch (e) {
                // Ignore if already defined as non-configurable
                console.warn('Could not set window.escapeHtml, using fallback:', e);
            }
        }

        // Bootstrap Modal handles closing on backdrop click and ESC key automatically
        // No need for manual event listeners
    </script>
</body>
</html>

