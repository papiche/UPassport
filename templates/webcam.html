<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>üé• Webcam Recorder with NOSTR Publishing</title>
    
    <!-- Nostr integration -->
    <script src="{{ myIPFS }}/ipns/copylaradio.com/nostr.bundle.js"></script>

    <!-- Common.js with enhanced UPlanet NOSTR functions -->
    <script src="{{ myIPFS }}/ipns/copylaradio.com/common.js"></script>
    
    <!-- Leaflet CSS -->
    <link rel="stylesheet" href="{{ myIPFS }}/ipns/copylaradio.com/leaflet.css"/>
    <!-- Leaflet JavaScript -->
    <script src="{{ myIPFS }}/ipns/copylaradio.com/leaflet.js"></script>
    
    <style>
        * {
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Roboto', 'Arial', sans-serif;
            background: #0f0f0f;
            color: #ffffff;
            min-height: 100vh;
            margin: 0;
            padding: 0;
            overflow-x: hidden;
        }
        
        /* Compact Header - YouTube Style */
        .header {
            background: #212121;
            backdrop-filter: blur(10px);
            border-bottom: 1px solid #3f3f3f;
            padding: 12px 24px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
            gap: 16px;
            position: sticky;
            top: 0;
            z-index: 100;
        }
        
        .header-left {
            display: flex;
            align-items: center;
            gap: 16px;
        }
        
        .header h1 {
            color: #ffffff;
            margin: 0;
            font-size: 1.3em;
            font-weight: 400;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .youtube-link {
            padding: 8px 16px;
            background: transparent;
            border: 1px solid #3f3f3f;
            color: #f1f1f1;
            border-radius: 18px;
            font-size: 0.85em;
            cursor: pointer;
            transition: all 0.2s ease;
            text-decoration: none;
            display: inline-flex;
            align-items: center;
            gap: 6px;
            font-weight: 500;
        }
        
        .youtube-link:hover {
            background: #3f3f3f;
            border-color: #ff0000;
            color: #ffffff;
        }
        
        /* Compact NOSTR Auth in Header */
        .nostr-header {
            display: flex;
            align-items: center;
            gap: 6px;
            flex-wrap: wrap;
        }
        
        .nostr-header .auth-status {
            font-size: 0.75em;
            color: #94a3b8;
            padding: 3px 6px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 4px;
            white-space: nowrap;
        }
        
        .nostr-header button {
            padding: 5px 10px;
            font-size: 0.75em;
            margin: 0;
            border-radius: 4px;
        }
        
        /* Main Container - Full viewport */
        .main-container {
            max-width: 100%;
            padding: 24px;
            height: 100vh;
            overflow-y: auto;
            background: #0f0f0f;
        }
        
        /* Webcam Section - YouTube Style */
        .webcam-section {
            background: #181818;
            backdrop-filter: blur(10px);
            border: 1px solid #3f3f3f;
            padding: 24px;
            border-radius: 12px;
            text-align: center;
            box-shadow: 0 4px 16px rgba(0, 0, 0, 0.5);
            max-width: 900px;
            margin: 0 auto;
        }
        
        .webcam-title {
            color: #ffffff;
            font-size: 1.5em;
            margin-bottom: 20px;
            font-weight: 500;
        }
        
        #video-preview {
            width: 100%;
            max-width: 100%;
            height: auto;
            aspect-ratio: 16/9;
            max-height: 40vh;
            border: 2px solid #3f3f3f;
            border-radius: 12px;
            margin: 10px auto;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
            background: #000;
            object-fit: cover;
        }
        
        #timer {
            font-size: 2.5em;
            margin: 10px 0;
            color: #ff0000;
            text-shadow: 0 0 10px rgba(255, 0, 0, 0.5);
            font-weight: bold;
        }
        
        .controls {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 12px;
            margin: 15px 0;
        }
        
        .duration-control {
            display: flex;
            align-items: center;
            gap: 10px;
            margin: 8px 0;
            flex-wrap: wrap;
            justify-content: center;
        }
        
        input[type="range"] {
            width: 180px;
            height: 6px;
            border-radius: 5px;
            background: rgba(255, 255, 255, 0.2);
            outline: none;
        }
        
        input[type="range"]::-webkit-slider-thumb {
            appearance: none;
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: #4ade80;
            cursor: pointer;
            box-shadow: 0 0 8px rgba(74, 222, 128, 0.5);
        }
        
        #duration-display {
            font-size: 1em;
            color: #4ade80;
            font-weight: 600;
            min-width: 100px;
        }
        
        button {
            padding: 10px 20px;
            border: none;
            border-radius: 18px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        .btn-primary {
            background: #065fd4;
            color: white;
        }
        
        .btn-primary:hover {
            background: #0556c2;
            transform: translateY(-1px);
            box-shadow: 0 3px 10px rgba(6, 95, 212, 0.3);
        }
        
        .btn-secondary {
            background: #3f3f3f;
            color: white;
        }
        
        .btn-secondary:hover {
            background: #606060;
            transform: translateY(-1px);
            box-shadow: 0 3px 10px rgba(255, 255, 255, 0.1);
        }
        
        .btn-danger {
            background: #ff0000;
            color: white;
        }
        
        .btn-danger:hover {
            background: #cc0000;
            transform: translateY(-1px);
            box-shadow: 0 3px 10px rgba(255, 0, 0, 0.3);
        }
        
        button:disabled {
            background: rgba(148, 163, 184, 0.5);
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }
        
        .hidden {
            display: none;
        }
        
        /* Video upload section - YouTube style */
        .video-upload-section {
            margin: 10px 0;
            padding: 16px;
            background: rgba(63, 63, 63, 0.3);
            border-radius: 12px;
            border: 1px solid #3f3f3f;
        }
        
        .video-upload-section label {
            display: block;
            margin-bottom: 8px;
            color: #e2e8f0;
            font-weight: 600;
            font-size: 0.9em;
        }
        
        .video-upload-section input[type="file"] {
            width: 100%;
            padding: 6px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 6px;
            background: rgba(255, 255, 255, 0.05);
            color: #e2e8f0;
            cursor: pointer;
            font-size: 0.85em;
        }
        
        .video-upload-section small {
            color: #94a3b8;
            font-size: 0.75em;
            display: block;
            margin-top: 4px;
        }
        
        .or-separator {
            text-align: center;
            margin: 10px 0;
            color: #94a3b8;
            font-size: 0.85em;
        }
        
        /* Modal Styles - YouTube theme */
        .modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.95);
            backdrop-filter: blur(5px);
            overflow-y: auto;
        }
        
        .modal.active {
            display: flex;
            align-items: flex-start;
            justify-content: center;
            padding: 10px;
        }
        
        .modal-content {
            background: #181818;
            border: 1px solid #3f3f3f;
            border-radius: 12px;
            padding: 24px;
            max-width: 800px;
            width: 100%;
            max-height: 90vh;
            overflow-y: auto;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.8);
            position: relative;
            margin-top: 10px;
        }
        
        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .modal-header h2 {
            color: #ffffff;
            margin: 0;
            font-size: 1.5em;
            font-weight: 500;
        }
        
        .close-modal {
            background: none;
            border: none;
            color: #94a3b8;
            font-size: 1.5em;
            cursor: pointer;
            padding: 0;
            width: 35px;
            height: 35px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 50%;
            transition: all 0.3s ease;
        }
        
        .close-modal:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #ef4444;
        }
        
        .modal-video-preview {
            width: 100%;
            max-height: 35vh;
            border-radius: 10px;
            margin: 10px auto;
            display: block;
        }
        
        .form-group {
            margin: 12px 0;
        }
        
        .form-group label {
            display: block;
            margin-bottom: 5px;
            font-weight: 600;
            color: #e2e8f0;
            font-size: 0.9em;
        }
        
        .form-group input, .form-group textarea {
            width: 100%;
            padding: 8px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 6px;
            font-size: 14px;
            background: rgba(255, 255, 255, 0.05);
            color: #e2e8f0;
            transition: all 0.3s ease;
        }
        
        .form-group input:focus, .form-group textarea:focus {
            outline: none;
            border-color: #4ade80;
            box-shadow: 0 0 0 2px rgba(74, 222, 128, 0.1);
        }
        
        .form-group textarea {
            resize: vertical;
            min-height: 60px;
        }
        
        .location-section {
            background: rgba(63, 63, 63, 0.3);
            border: 1px solid #3f3f3f;
            padding: 16px;
            border-radius: 12px;
            margin: 12px 0;
        }
        
        .location-section > label {
            display: block;
            margin-bottom: 8px;
            color: #ffffff;
            font-weight: 600;
            font-size: 0.9em;
        }
        
        .location-controls {
            display: flex;
            gap: 8px;
            align-items: center;
            flex-wrap: wrap;
            margin-top: 10px;
        }
        
        .coord-input {
            display: flex;
            align-items: center;
            gap: 4px;
            flex: 1;
            min-width: 120px;
        }
        
        .coord-input label {
            font-weight: bold;
            color: #e2e8f0;
            margin: 0;
            min-width: 28px;
            font-size: 0.85em;
        }
        
        .coord-input input {
            flex: 1;
            padding: 6px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 4px;
            font-size: 0.85em;
        }
        
        .modal-map {
            height: 200px;
            width: 100%;
            border-radius: 8px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            margin-top: 10px;
        }
        
        .modal-actions {
            display: flex;
            gap: 10px;
            justify-content: flex-end;
            margin-top: 15px;
            padding-top: 12px;
            border-top: 1px solid rgba(255, 255, 255, 0.1);
            flex-wrap: wrap;
        }
        
        .modal-actions button {
            flex: 1;
            min-width: 120px;
        }
        
        /* Expanded NOSTR Section (when clicking expand) */
        .nostr-section {
            background: rgba(255, 255, 255, 0.08);
            border: 1px solid rgba(255, 255, 255, 0.1);
            padding: 15px;
            border-radius: 10px;
            margin-bottom: 15px;
            display: none;
            position: absolute;
            top: 100%;
            right: 0;
            min-width: 300px;
            z-index: 200;
            margin-top: 10px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
        }
        
        .nostr-section.expanded {
            display: block;
        }
        
        .auth-mode {
            margin: 10px 0;
        }
        
        .kind-options {
            display: flex;
            gap: 15px;
            margin-top: 10px;
        }
        
        .kind-option {
            display: flex;
            align-items: center;
                gap: 5px;
            }
            
        .kind-option input[type="radio"] {
            width: auto;
            margin: 0;
        }
        
        .nsec-input {
            display: none;
            margin-top: 10px;
        }
        
        .nsec-input.visible {
            display: block;
        }
        
        /* Notification Modal */
        .notification-modal {
            display: none;
            position: fixed;
            z-index: 2000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7);
            backdrop-filter: blur(8px);
            animation: fadeIn 0.3s ease;
        }
        
        .notification-modal.active {
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
        }
        
        .notification-content {
            background: #181818;
            border-radius: 12px;
            padding: 25px;
            max-width: 450px;
            width: 100%;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.8);
            border: 2px solid;
            animation: slideIn 0.3s ease;
            position: relative;
        }
        
        .notification-content.success {
            border-color: #065fd4;
        }
        
        .notification-content.error {
            border-color: #ff0000;
        }
        
        .notification-content.info {
            border-color: #3f3f3f;
        }
        
        .notification-content.warning {
            border-color: #f59e0b;
        }
        
        .notification-icon {
            font-size: 3em;
            text-align: center;
            margin-bottom: 15px;
            animation: bounce 0.6s ease;
        }
        
        .notification-title {
            font-size: 1.4em;
            font-weight: 700;
            text-align: center;
            margin-bottom: 10px;
            color: #e8e8e8;
        }
        
        .notification-message {
            font-size: 1em;
            text-align: center;
            margin-bottom: 20px;
            color: #cbd5e1;
            line-height: 1.5;
            word-wrap: break-word;
        }
        
        .notification-actions {
            display: flex;
            gap: 10px;
            justify-content: center;
        }
        
        .notification-btn {
            padding: 10px 25px;
            border: none;
            border-radius: 8px;
            font-size: 0.95em;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            min-width: 100px;
        }
        
        .notification-btn.primary {
            background: #065fd4;
            color: white;
        }
        
        .notification-btn.primary:hover {
            background: #0556c2;
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(6, 95, 212, 0.4);
        }
        
        .notification-btn.secondary {
            background: #3f3f3f;
            color: white;
        }
        
        .notification-btn.secondary:hover {
            background: #606060;
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(255, 255, 255, 0.2);
        }
        
        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }
        
        @keyframes slideIn {
            from {
                opacity: 0;
                transform: translateY(-30px) scale(0.9);
            }
            to {
                opacity: 1;
                transform: translateY(0) scale(1);
            }
        }
        
        @keyframes bounce {
            0%, 100% { transform: scale(1); }
            25% { transform: scale(0.9); }
            50% { transform: scale(1.1); }
            75% { transform: scale(0.95); }
        }
        
        /* Responsive */
        @media screen and (max-width: 768px) {
            .header {
                padding: 6px 10px;
            }
            
            .header h1 {
                font-size: 1em;
            }
            
            .nostr-header .auth-status {
                font-size: 0.7em;
                padding: 2px 4px;
            }
            
            .nostr-header button {
                padding: 4px 8px;
                font-size: 0.7em;
            }
            
            .main-container {
                padding: 5px;
                height: 100vh;
            }
            
            .webcam-section {
                padding: 10px;
                border-radius: 10px;
            }
            
            .webcam-title {
                font-size: 1.1em;
                margin-bottom: 10px;
            }
            
            #video-preview {
                max-height: 35vh;
                border-width: 2px;
                border-radius: 8px;
                margin: 8px auto;
            }
            
            #timer {
                font-size: 2em;
                margin: 8px 0;
            }
            
            .controls {
                gap: 8px;
                margin: 10px 0;
            }
            
            .duration-control {
                gap: 6px;
                margin: 6px 0;
            }
            
            .duration-control label {
                font-size: 0.85em;
            }
            
            input[type="range"] {
                width: 140px;
                height: 5px;
            }
            
            input[type="range"]::-webkit-slider-thumb {
                width: 14px;
                height: 14px;
            }
            
            #duration-display {
                font-size: 0.9em;
                min-width: 80px;
            }
            
            button {
                padding: 8px 16px;
                font-size: 12px;
            }
            
            .video-upload-section {
                padding: 8px;
                margin: 8px 0;
            }
            
            .video-upload-section label {
                font-size: 0.85em;
                margin-bottom: 6px;
            }
            
            .video-upload-section input[type="file"] {
                padding: 5px;
                font-size: 0.8em;
            }
            
            .video-upload-section small {
                font-size: 0.7em;
            }
            
            .or-separator {
                margin: 8px 0;
                font-size: 0.8em;
            }
            
            /* Modal responsive */
            .modal.active {
                padding: 5px;
                align-items: flex-start;
            }
            
            .modal-content {
                padding: 12px;
                border-radius: 10px;
                max-height: 95vh;
                margin-top: 5px;
            }
            
            .modal-header {
                margin-bottom: 10px;
                padding-bottom: 8px;
            }
            
            .modal-header h2 {
                font-size: 1.1em;
            }
            
            .close-modal {
                font-size: 1.3em;
                width: 30px;
                height: 30px;
            }
            
            .modal-video-preview {
                max-height: 30vh;
                border-radius: 8px;
                margin: 8px auto;
            }
            
            .form-group {
                margin: 10px 0;
            }
            
            .form-group label {
                margin-bottom: 4px;
                font-size: 0.85em;
            }
            
            .form-group input, .form-group textarea {
                padding: 6px;
                font-size: 13px;
                border-radius: 5px;
            }
            
            .form-group textarea {
                min-height: 50px;
            }
            
            .location-section {
                padding: 10px;
                border-radius: 8px;
                margin: 10px 0;
            }
            
            .location-section > label {
                font-size: 0.85em;
                margin-bottom: 6px;
            }
            
            .location-controls {
                gap: 6px;
                margin-top: 8px;
            }
            
            .coord-input {
                min-width: 100px;
            }
            
            .coord-input label {
                font-size: 0.8em;
                min-width: 24px;
            }
            
            .coord-input input {
                padding: 5px;
                font-size: 0.8em;
            }
            
            .location-controls .btn-secondary {
                width: 100%;
                padding: 6px 12px;
                font-size: 0.8em;
            }
            
            .modal-map {
                height: 180px;
                border-radius: 6px;
                margin-top: 8px;
            }
            
            .modal-actions {
                gap: 8px;
                margin-top: 12px;
                padding-top: 10px;
            }
            
            .modal-actions button {
                min-width: 100px;
                padding: 8px 12px;
                font-size: 12px;
            }
            
            /* NOSTR expanded section mobile */
            .nostr-section {
                min-width: 250px;
                padding: 12px;
                font-size: 0.9em;
            }
            
            .nostr-section h3 {
                font-size: 0.95em;
            }
            
            .kind-options {
                gap: 10px;
            }
            
            .kind-option label {
                font-size: 0.8em;
            }
            
            #nsec-input-container input {
                padding: 6px;
                font-size: 0.8em;
            }
            
            #nsec-input-container small {
                font-size: 0.7em;
            }
            
            /* Notification modal responsive */
            .notification-content {
                padding: 20px;
                max-width: 90%;
            }
            
            .notification-icon {
                font-size: 2.5em;
                margin-bottom: 12px;
            }
            
            .notification-title {
                font-size: 1.2em;
                margin-bottom: 8px;
            }
            
            .notification-message {
                font-size: 0.9em;
                margin-bottom: 15px;
            }
            
            .notification-btn {
                padding: 8px 20px;
                font-size: 0.85em;
                min-width: 90px;
            }
        }
        
        /* Central Connection Button */
        .central-connection {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 70vh;
            padding: 40px;
            text-align: center;
        }
        
        .central-connection.hidden {
            display: none;
        }
        
        .central-connection-title {
            font-size: 2.5em;
            font-weight: 600;
            margin-bottom: 20px;
            color: #ffffff;
        }
        
        .central-connection-subtitle {
            font-size: 1.2em;
            color: #94a3b8;
            margin-bottom: 40px;
            max-width: 600px;
        }
        
        .central-connect-btn {
            padding: 20px 40px;
            font-size: 1.3em;
            font-weight: 700;
            background: #065fd4;
            color: white;
            border: none;
            border-radius: 30px;
            cursor: pointer;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 1px;
            box-shadow: 0 4px 20px rgba(6, 95, 212, 0.4);
            min-width: 300px;
        }
        
        .central-connect-btn:hover {
            background: #0556c2;
            transform: translateY(-3px);
            box-shadow: 0 6px 30px rgba(6, 95, 212, 0.6);
        }
        
        .central-connect-btn:active {
            transform: translateY(-1px);
        }
        
        @media screen and (max-width: 768px) {
            .central-connection-title {
                font-size: 2em;
            }
            
            .central-connection-subtitle {
                font-size: 1em;
                margin-bottom: 30px;
            }
            
            .central-connect-btn {
                padding: 16px 32px;
                font-size: 1.1em;
                min-width: 250px;
            }
        }
        
        /* Extra small mobile devices */
        @media screen and (max-width: 480px) {
            .header h1 {
                font-size: 0.9em;
            }
            
            .webcam-title {
                font-size: 1em;
            }
            
            #video-preview {
                max-height: 30vh;
            }
            
            #timer {
                font-size: 1.8em;
            }
            
            input[type="range"] {
                width: 120px;
            }
            
            #duration-display {
                font-size: 0.85em;
                min-width: 70px;
            }
            
            button {
                padding: 7px 14px;
                font-size: 11px;
            }
            
            .modal-video-preview {
                max-height: 25vh;
            }
            
            .modal-map {
                height: 150px;
            }
            
            .coord-input {
                min-width: 90px;
            }
            
            /* Notification modal extra small */
            .notification-content {
                padding: 18px;
                max-width: 95%;
            }
            
            .notification-icon {
                font-size: 2.2em;
                margin-bottom: 10px;
            }
            
            .notification-title {
                font-size: 1.1em;
                margin-bottom: 8px;
            }
            
            .notification-message {
                font-size: 0.85em;
                margin-bottom: 12px;
            }
            
            .notification-btn {
                padding: 7px 18px;
                font-size: 0.8em;
                min-width: 80px;
            }
        }
    </style>
</head>
<body>
    <!-- Main Container - Centered -->
    <div class="main-container">
        <!-- Central Connection Button (hidden by default, shown only if needed) -->
        <div class="central-connection hidden" id="central-connection">
            <h2 class="central-connection-title">üé• Video Recorder</h2>
            <p class="central-connection-subtitle">
                Connect to NOSTR to start recording and publishing your videos on UPlanet
            </p>
            <button class="central-connect-btn" onclick="handleNostrConnect()">
                üîå Connect to NOSTR
            </button>
        </div>
        
        <!-- Webcam Recording Section (shown by default) -->
        <div class="webcam-section" id="webcam-section">
            <h2 class="webcam-title">üé• Record Video</h2>
            

    <video id="video-preview" autoplay muted></video>

    <div id="timer" class="hidden">16</div>

            <div class="controls">
                               
                <!-- Recording Option -->
                <div class="duration-control">
                    <label for="duration-slider">Duration:</label>
                    <input type="range" id="duration-slider" min="3" max="30" value="10">
                    <div id="duration-display">10 seconds</div>
                </div>
                
                <input type="hidden" id="player" name="player" value="">
                
                <button id="start-recording" class="btn-primary">üé¨ Start Recording</button>
                <button id="stop-recording" class="btn-danger hidden">‚èπÔ∏è Stop Recording</button>

                <div class="or-separator">
                    ‚Äî <span title="Upload a video file" style="vertical-align: middle; font-size: 1.15em;">üì§</span> ‚Äî 
                </div>

                <!-- Video Upload Option -->
                <div class="video-upload-section">
                    <label for="video-upload">
                        üìÅ Upload Video File (.mp4, .webm, .mov)
                    </label>
                    <input type="file" id="video-upload" accept="video/*,.mp4,.webm,.mov">
                    <small>
                        Supported formats: MP4, WebM, MOV (max 500MB)
                    </small>
                </div>
            </div>
        </div>
                </div>
                
    <!-- Modal for Video Preview and Publishing -->
    <div id="video-modal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h2>üìπ Video Preview & Publish</h2>
                <button class="close-modal" onclick="closeModal()">&times;</button>
                    </div>
            
            <video id="modal-video-preview" class="modal-video-preview" controls></video>
            
            <form id="publish-form">
                <div class="form-group">
                    <label for="video-title">Title:</label>
                    <input type="text" id="video-title" name="title" 
                           placeholder="Enter video title..." required>
                </div>
                
                <div class="form-group">
                    <label for="video-description">Description (optional):</label>
                    <textarea id="video-description" name="description" 
                              placeholder="Describe your video..." rows="3"></textarea>
                </div>
                
                <div class="location-section">
                    <label>
                        üìç Geographic Location (for UMAP anchoring)
                    </label>
                    <div class="location-controls">
                            <div class="coord-input">
                                <label>Lat:</label>
                            <input type="number" id="modal-lat" step="0.01" min="-90" max="90" value="0.00">
                            </div>
                            <div class="coord-input">
                                <label>Lon:</label>
                            <input type="number" id="modal-lon" step="0.01" min="-180" max="180" value="0.00">
                            </div>
                        <button type="button" class="btn-secondary" onclick="getCurrentLocationForModal()">üìç My Location</button>
                        </div>
                    <div id="modal-map" class="modal-map"></div>
                        </div>
                
                <div class="form-group">
                    <label style="display: flex; align-items: center; gap: 8px; cursor: pointer;">
                        <input type="checkbox" id="publish-nostr" name="publish_nostr" checked style="width: auto; margin: 0;">
                        <span>
                            Publish to UPlanet (geo localized 
                            <a href="/youtube?html=1" target="_blank" style="color:#4ade80; text-decoration:underline;">/youtube</a>
                            )
                        </span>
                    </label>
                </div>
                
                <div class="modal-actions">
                    <button type="button" class="btn-secondary" onclick="closeModal()">Cancel</button>
                    <button type="submit" class="btn-primary" id="publish-btn">
                        üì° Publish Video
                    </button>
                </div>
            </form>
            </div>
        </div>
        
    <!-- Hidden Container for old code compatibility -->
        <div id="webcam-container"></div>

    <!-- Notification Modal -->
    <div id="notification-modal" class="notification-modal">
        <div class="notification-content" id="notification-content">
            <div class="notification-icon" id="notification-icon"></div>
            <div class="notification-title" id="notification-title"></div>
            <div class="notification-message" id="notification-message"></div>
            <div class="notification-actions">
                <button class="notification-btn primary" id="notification-btn-ok">OK</button>
            </div>
        </div>
    </div>

    <script>
        // NOSTR Extension Proxy for iframes (communicate with parent window)
        (function() {
            let nostrProxyReady = false;
            const pendingRequests = new Map();
            let requestIdCounter = 0;
            
            // Check if we're in an iframe
            const isInIframe = window.self !== window.top;
            
            // Only create proxy if we're in an iframe AND window.nostr doesn't exist
            // Wait a bit for NOSTR extension to initialize first
            if (isInIframe) {
                // Wait a moment for NOSTR extension to load (extensions usually load at document_end)
                setTimeout(() => {
                    // Check if real extension exists and is functional
                    if (typeof window.nostr !== 'undefined' && 
                        window.nostr && 
                        typeof window.nostr.getPublicKey === 'function') {
                        // Try to test if it's actually working (not just a stub)
                        // We need to catch synchronous errors (like _call is not a function)
                        try {
                            // Quick test call to verify extension works
                            const testPromise = window.nostr.getPublicKey();
                            
                            // Check if it returned a promise
                            if (!testPromise || typeof testPromise.then !== 'function') {
                                // Doesn't return a promise, probably not working
                                console.warn('‚ö†Ô∏è window.nostr.getPublicKey() does not return a Promise, creating proxy');
                                createNostrProxy();
                                return;
                            }
                            
                            // Save extension reference before testing (we might replace window.nostr with proxy)
                            const savedExtension = window.nostr;
                            
                            // Test if the promise actually resolves (with timeout)
                            // If test fails, we'll create proxy
                            Promise.race([
                                testPromise,
                                new Promise((_, reject) => setTimeout(() => reject(new Error('timeout')), 2000))
                            ]).then(() => {
                                // Extension works! Don't create proxy
                                console.log('‚úÖ NOSTR extension detected in iframe and working, using real extension');
                            }).catch((testError) => {
                                // Extension doesn't work properly, create proxy
                                if (testError.message && testError.message.includes('_call')) {
                                    console.warn('‚ö†Ô∏è NOSTR extension detected but not functional (', testError.message, '), creating proxy');
                                } else {
                                    console.warn('‚ö†Ô∏è NOSTR extension detected but test failed, creating proxy as fallback');
                                }
                                // Only create proxy if window.nostr is still the extension (not already replaced)
                                if (window.nostr === savedExtension) {
                                    createNostrProxy();
                                }
                            });
                            
                            return;
                            
                        } catch (e) {
                            // Extension exists but throws a synchronous error when called (e.g., _call is not a function)
                            console.warn('‚ö†Ô∏è NOSTR extension detected but throws synchronous error:', e.message);
                            console.warn('‚ö†Ô∏è This usually means extension is not fully initialized in iframe context');
                            console.warn('‚ö†Ô∏è Creating proxy as fallback');
                            createNostrProxy();
                            return;
                        }
                    }
                    
                    // Extension not available, create proxy
                    createNostrProxy();
                }, 500); // Increased delay to give extension more time to initialize
            }
            
            function createNostrProxy() {
                // Create a proxy for window.nostr that communicates with parent
                const nostrProxy = {
                    getPublicKey: async function() {
                        return await proxyNostrMethod('getPublicKey', []);
                    },
                    signEvent: async function(event) {
                        return await proxyNostrMethod('signEvent', [event]);
                    }
                };
                
                // NIP-44 (Recommended): Modern encryption using ChaCha20-Poly1305
                // This is the replacement for NIP-04 and should be preferred for new implementations
                Object.defineProperty(nostrProxy, 'nip44', {
                    value: {
                        encrypt: async function(pubkey, plaintext) {
                            return await proxyNostrMethod('nip44.encrypt', [pubkey, plaintext]);
                        },
                        decrypt: async function(pubkey, ciphertext) {
                            return await proxyNostrMethod('nip44.decrypt', [pubkey, ciphertext]);
                        }
                    },
                    writable: false,
                    configurable: false
                });
                
                // NIP-04 (Deprecated): Legacy encryption - use NIP-44 instead
                // Kept for backward compatibility only
                Object.defineProperty(nostrProxy, 'nip04', {
                    value: {
                        encrypt: async function(pubkey, plaintext) {
                            console.warn('‚ö†Ô∏è NIP-04 is deprecated. Please use NIP-44 (window.nostr.nip44.encrypt) instead.');
                            return await proxyNostrMethod('nip04.encrypt', [pubkey, plaintext]);
                        },
                        decrypt: async function(pubkey, ciphertext) {
                            console.warn('‚ö†Ô∏è NIP-04 is deprecated. Please use NIP-44 (window.nostr.nip44.decrypt) instead.');
                            return await proxyNostrMethod('nip04.decrypt', [pubkey, ciphertext]);
                        }
                    },
                    writable: false,
                    configurable: false
                });
                
                function proxyNostrMethod(method, params) {
                    return new Promise((resolve, reject) => {
                        const requestId = ++requestIdCounter;
                        pendingRequests.set(requestId, { resolve, reject });
                        
                        // Send request to parent
                        window.parent.postMessage({
                            type: 'nostr-request',
                            requestId: requestId,
                            method: method,
                            params: params
                        }, '*');
                        
                        // Timeout after 10 seconds
                        setTimeout(() => {
                            if (pendingRequests.has(requestId)) {
                                pendingRequests.delete(requestId);
                                reject(new Error('NOSTR request timeout'));
                            }
                        }, 10000);
                    });
                }
                
                // Listen for responses from parent
                window.addEventListener('message', function(event) {
                    if (event.data && event.data.type === 'nostr-response') {
                        const { requestId, success, data, error } = event.data;
                        
                        if (pendingRequests.has(requestId)) {
                            const { resolve, reject } = pendingRequests.get(requestId);
                            pendingRequests.delete(requestId);
                            
                            if (success) {
                                resolve(data);
                            } else {
                                reject(new Error(error || 'NOSTR request failed'));
                            }
                        }
                    }
                });
                
                // Only set window.nostr if it doesn't exist or is not functional
                // Double-check that extension still isn't available before overwriting
                if (typeof window.nostr === 'undefined' || !window.nostr) {
                    // window.nostr doesn't exist, safe to set our proxy
                    Object.defineProperty(window, 'nostr', {
                        value: nostrProxy,
                        writable: true,  // Allow overwriting if extension loads later
                        configurable: true
                    });
                    
                    nostrProxyReady = true;
                    console.log('‚úÖ NOSTR proxy initialized for iframe');
                } else if (typeof window.nostr.getPublicKey !== 'function') {
                    // window.nostr exists but doesn't have required methods, replace with proxy
                    console.warn('‚ö†Ô∏è window.nostr exists but getPublicKey is not a function, replacing with proxy');
                    Object.defineProperty(window, 'nostr', {
                        value: nostrProxy,
                        writable: true,
                        configurable: true
                    });
                    
                    nostrProxyReady = true;
                    console.log('‚úÖ NOSTR proxy initialized for iframe - replaced non-functional window.nostr');
                } else {
                    // window.nostr exists and has getPublicKey, but it might not be functional in iframe
                    // Try to test it quickly - if it throws _call error, replace it
                    try {
                        // Quick test: try to call getPublicKey and catch synchronous errors
                        const testCall = window.nostr.getPublicKey();
                        // If it returns a Promise, check if it will fail
                        if (testCall && typeof testCall.then === 'function') {
                            testCall.catch(err => {
                                // If it fails with _call error, replace with proxy
                                if (err.message && err.message.includes('_call')) {
                                    console.warn('‚ö†Ô∏è window.nostr.getPublicKey() failed with _call error, replacing with proxy');
                                    Object.defineProperty(window, 'nostr', {
                                        value: nostrProxy,
                                        writable: true,
                                        configurable: true
                                    });
                                    nostrProxyReady = true;
                                    console.log('‚úÖ NOSTR proxy initialized (replaced non-functional extension)');
                                }
                            });
                        }
                        // If no immediate error, assume extension works (but proxy creation might still happen in catch handler above)
                        // Don't log "functional" yet - wait for async test result
                    } catch (syncError) {
                        // Synchronous error (like _call is not a function thrown immediately)
                        if (syncError.message && syncError.message.includes('_call')) {
                            console.warn('‚ö†Ô∏è window.nostr throws synchronous _call error, replacing with proxy');
                            Object.defineProperty(window, 'nostr', {
                                value: nostrProxy,
                                writable: true,
                                configurable: true
                            });
                            nostrProxyReady = true;
                            console.log('‚úÖ NOSTR proxy initialized (replaced non-functional extension)');
                        } else {
                            // Different error, assume extension works
                            console.log('‚úÖ NOSTR extension already present, skipping proxy creation');
                        }
                    }
                }
            }
        })();
        
        // Global variables (non-conflicting with common.js)
        let mediaRecorder;
        let recordedChunks = [];
        let currentStream = null;
        let authMode = 'extension';
        let userEmail = null;
        // userPubkey and userPrivateKey are declared in common.js
        
        // Mobile detection
        let isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
        let isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent);
        let isAndroid = /Android/.test(navigator.userAgent);
        
        // Location and map variables
        let currentLocation = null;
        let miniMap = null;
        let miniMarker = null;
        let modalMap = null;
        let modalMarker = null;
        let userHasInteractedWithMap = false;
        
        // Auto-connect nsec (injected by upassport.sh when scanning SSSS with code 1111)
        const AUTO_CONNECT_NSEC = null;
        
        // Notification system
        function showNotification(options) {
            const {
                type = 'info',  // 'success', 'error', 'warning', 'info'
                title = '',
                message = '',
                icon = null,
                onConfirm = null,
                confirmText = 'OK'
            } = options;
            
            const modal = document.getElementById('notification-modal');
            const content = document.getElementById('notification-content');
            const iconElement = document.getElementById('notification-icon');
            const titleElement = document.getElementById('notification-title');
            const messageElement = document.getElementById('notification-message');
            const btnOk = document.getElementById('notification-btn-ok');
            
            // Set icon based on type or custom icon
            const icons = {
                success: '‚úÖ',
                error: '‚ùå',
                warning: '‚ö†Ô∏è',
                info: '‚ÑπÔ∏è'
            };
            iconElement.textContent = icon || icons[type] || icons.info;
            
            // Set content class for styling
            content.className = 'notification-content ' + type;
            
            // Set title and message
            titleElement.textContent = title;
            messageElement.textContent = message;
            
            // Set button text
            btnOk.textContent = confirmText;
            
            // Show modal with animation
            modal.classList.add('active');
            
            // Handle confirmation
            const handleConfirm = () => {
                modal.classList.remove('active');
                btnOk.removeEventListener('click', handleConfirm);
                if (onConfirm) {
                    onConfirm();
                }
            };
            
            btnOk.addEventListener('click', handleConfirm);
            
            // Allow closing with ESC key
            const handleEscape = (e) => {
                if (e.key === 'Escape') {
                    handleConfirm();
                    document.removeEventListener('keydown', handleEscape);
                }
            };
            document.addEventListener('keydown', handleEscape);
            
            // Close modal when clicking outside content
            modal.onclick = (event) => {
                if (event.target === modal) {
                    handleConfirm();
                }
            };
        }
        
        // Convenience functions
        function showSuccess(message, title = 'Success', onConfirm = null) {
            showNotification({ type: 'success', title, message, onConfirm });
        }
        
        function showError(message, title = 'Error', onConfirm = null) {
            showNotification({ type: 'error', title, message, onConfirm });
        }
        
        function showWarning(message, title = 'Warning', onConfirm = null) {
            showNotification({ type: 'warning', title, message, onConfirm });
        }
        
        function showInfo(message, title = 'Information', onConfirm = null) {
            showNotification({ type: 'info', title, message, onConfirm });
        }
        
        
        // Close modal
        function closeModal() {
            document.getElementById('video-modal').classList.remove('active');
            if (currentStream) {
                currentStream.getTracks().forEach(track => track.stop());
                currentStream = null;
            }
            
            // Reset recording UI when closing modal
            const startButton = document.getElementById('start-recording');
            const stopButton = document.getElementById('stop-recording');
            const timerDisplay = document.getElementById('timer');
            const durationSlider = document.getElementById('duration-slider');
            
            if (startButton) {
                startButton.disabled = false;
                startButton.classList.remove('hidden');
            }
            
            if (stopButton) {
                stopButton.classList.add('hidden');
                stopButton.disabled = false;
                stopButton.textContent = '‚èπÔ∏è Stop Recording';
            }
            
            if (timerDisplay) {
                timerDisplay.classList.add('hidden');
                timerDisplay.textContent = durationSlider ? durationSlider.value : '10';
            }
            
            // Reset form
            document.getElementById('publish-form').reset();
        }
        
        // Show modal with video
        function showVideoModal(videoBlob, filename = null) {
            const modal = document.getElementById('video-modal');
            const videoPreview = document.getElementById('modal-video-preview');
            const videoUrl = URL.createObjectURL(videoBlob);
            
            videoPreview.src = videoUrl;
            modal.classList.add('active');
            
            // Store filename for later use
            videoPreview.dataset.filename = filename || `webcam_${Date.now()}.webm`;
            
            // Initialize modal map
            setTimeout(() => {
                initializeModalMap();
            }, 100);
            
            // Handle form submission
            document.getElementById('publish-form').onsubmit = async (e) => {
                e.preventDefault();
                const filename = videoPreview.dataset.filename;
                await publishVideo(videoBlob, filename);
            };
        }
        
        // Initialize modal map
        function initializeModalMap() {
            if (typeof L === 'undefined') {
                console.error('Leaflet library not loaded');
                return;
            }
            
            const lat = parseFloat(document.getElementById('modal-lat').value) || 0.00;
            const lon = parseFloat(document.getElementById('modal-lon').value) || 0.00;
            
            if (modalMap) {
                modalMap.remove();
            }
            
            const mapContainer = document.getElementById('modal-map');
            if (!mapContainer) return;
            
            modalMap = L.map('modal-map').setView([lat, lon], 10);
            
            L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                attribution: '¬© OpenStreetMap contributors'
            }).addTo(modalMap);
            
            modalMarker = L.marker([lat, lon], {
                draggable: true
            }).addTo(modalMap);
            
            modalMap.on('click', function(e) {
                updateModalCoordinates(e.latlng.lat, e.latlng.lng);
            });
            
            modalMarker.on('dragend', function(e) {
                updateModalCoordinates(e.target.getLatLng().lat, e.target.getLatLng().lng);
            });
            
            setTimeout(() => {
                if (modalMap) {
                    modalMap.invalidateSize();
                }
            }, 100);
        }
        
        function updateModalCoordinates(lat, lon) {
            const roundedLat = Math.round(lat * 100) / 100;
            const roundedLon = Math.round(lon * 100) / 100;
            
            document.getElementById('modal-lat').value = roundedLat.toFixed(2);
            document.getElementById('modal-lon').value = roundedLon.toFixed(2);
            
            if (modalMarker) {
                modalMarker.setLatLng([roundedLat, roundedLon]);
            }
        }
        
        function getCurrentLocationForModal() {
            if (navigator.geolocation) {
                const btn = event.target;
                btn.textContent = 'Getting...';
                btn.disabled = true;
                
                navigator.geolocation.getCurrentPosition(
                    function(position) {
                        const lat = Math.round(position.coords.latitude * 100) / 100;
                        const lon = Math.round(position.coords.longitude * 100) / 100;
                        
                        updateModalCoordinates(lat, lon);
                        if (modalMap) {
                            modalMap.setView([lat, lon], 13);
                        }
                        
                        btn.textContent = 'üìç My Location';
                        btn.disabled = false;
                    },
                    function(error) {
                        console.error('Geolocation error:', error);
                        btn.textContent = 'üìç My Location';
                        btn.disabled = false;
                        showError('Failed to get your location. Please ensure location services are enabled.', 'Location Error');
                    }
                );
            }
        }

        // Initialize webcam recording functionality
        function initWebcamFeatures() {
        const startButton = document.getElementById('start-recording');
            const stopButton = document.getElementById('stop-recording');
        const videoPreview = document.getElementById('video-preview');
        const timerDisplay = document.getElementById('timer');
        const durationSlider = document.getElementById('duration-slider');
        const durationDisplay = document.getElementById('duration-display');

            // Mobile optimization
        if (isMobile) {
                const defaultDuration = isIOS ? 10 : 15;
            durationSlider.value = defaultDuration;
            durationDisplay.textContent = `${defaultDuration} seconds`;
                durationSlider.max = 30;
        }

        durationSlider.addEventListener('input', () => {
                durationDisplay.textContent = `${durationSlider.value} seconds`;
        });

        startButton.addEventListener('click', async () => {
                try {
                    const videoConstraints = isMobile ? {
                        width: { ideal: 640, max: 1280 },
                        height: { ideal: 480, max: 720 },
                        frameRate: { ideal: 24, max: 30 }
                    } : {
                        width: { ideal: 1280 },
                        height: { ideal: 720 },
                        frameRate: { ideal: 30 }
                    };
                    
                    const stream = await navigator.mediaDevices.getUserMedia({ 
                        video: videoConstraints,
                        audio: true 
                    });
                    
                    currentStream = stream;
            videoPreview.srcObject = stream;

                    let mimeType = 'video/webm;codecs=vp9,opus';
                    if (isIOS) {
                        mimeType = 'video/mp4;codecs=h264,aac';
                    } else if (isAndroid) {
                        mimeType = 'video/webm;codecs=vp8,opus';
                    }
                    
                    if (!MediaRecorder.isTypeSupported(mimeType)) {
                        mimeType = 'video/webm';
                    }

                    mediaRecorder = new MediaRecorder(stream, {
                        mimeType: mimeType
                    });
                    
                    recordedChunks = [];
                    
            mediaRecorder.ondataavailable = (event) => {
                if (event.data.size > 0) {
                    recordedChunks.push(event.data);
                }
            };

            mediaRecorder.onstop = () => {
                const blob = new Blob(recordedChunks, { type: 'video/webm' });
                        showVideoModal(blob);
                        if (currentStream) {
                            currentStream.getTracks().forEach(track => track.stop());
                            currentStream = null;
                        }
            };

            mediaRecorder.start();
            startTimer(parseInt(durationSlider.value));
            startButton.disabled = true;
                    startButton.classList.add('hidden');
                    stopButton.classList.remove('hidden');
            timerDisplay.classList.remove('hidden');
                    
                } catch (error) {
                    console.error('Error starting recording:', error);
                    showError('Could not access your webcam. Please ensure camera permissions are granted and your camera is not in use by another application.', 'Camera Access Error');
                }
            });

            stopButton.addEventListener('click', () => {
                if (mediaRecorder && mediaRecorder.state === 'recording') {
                    mediaRecorder.stop();
                }
                if (currentStream) {
                    currentStream.getTracks().forEach(track => track.stop());
                }
                stopButton.disabled = true;
                stopButton.textContent = 'Processing...';
            });
        }

        // Timer function
        function startTimer(duration) {
            let timer = duration;
            const timerDisplay = document.getElementById('timer');
            const countdown = setInterval(() => {
                timerDisplay.textContent = timer;
                if (--timer < 0) {
                    clearInterval(countdown);
                    if (mediaRecorder && mediaRecorder.state === 'recording') {
                        mediaRecorder.stop();
                    }
                    if (currentStream) {
                        currentStream.getTracks().forEach(track => track.stop());
                        currentStream = null;
                    }
                    timerDisplay.textContent = "Done! üåü";
                }
            }, 1000);
        }
        
        // Publish video
        async function publishVideo(videoBlob, filename = null) {
            try {
                // Get userPubkey from current window or parent window (assume connection exists)
                const isInIframe = window.self !== window.top;
                let currentPubkey = null;
                
                // Try current window first (check both window.userPubkey and global userPubkey)
                if (typeof window !== 'undefined' && window.userPubkey) {
                    currentPubkey = window.userPubkey;
                    console.log('‚úÖ Using userPubkey from current window:', currentPubkey.substring(0, 8) + '...');
                } else if (typeof userPubkey !== 'undefined' && userPubkey) {
                    currentPubkey = userPubkey;
                    console.log('‚úÖ Using userPubkey from global scope:', currentPubkey.substring(0, 8) + '...');
                }
                
                // If not found and in iframe, try parent window (with retry)
                if (!currentPubkey && isInIframe && window.parent) {
                    // Try multiple times with small delays
                    for (let i = 0; i < 5 && !currentPubkey; i++) {
                        try {
                            if (window.parent.userPubkey) {
                                currentPubkey = window.parent.userPubkey;
                                userPubkey = currentPubkey;
                                if (typeof window !== 'undefined') {
                                    window.userPubkey = currentPubkey;
                                }
                                console.log('‚úÖ Using userPubkey from parent window for publishing:', currentPubkey.substring(0, 8) + '...');
                                break;
                            } else if (i < 4) {
                                // Wait a bit before retrying
                                await new Promise(resolve => setTimeout(resolve, 200));
                            }
                        } catch (e) {
                            if (i >= 4) {
                                console.warn('‚ö†Ô∏è Cannot access parent.userPubkey:', e.message);
                            }
                            await new Promise(resolve => setTimeout(resolve, 200));
                        }
                    }
                }
                
                // If still not found, throw error
                if (!currentPubkey) {
                    const errorMsg = 'Vous devez √™tre connect√© √† NOSTR pour publier une vid√©o. Veuillez vous connecter depuis la page principale et r√©essayer.';
                    showError(errorMsg, 'Connexion requise');
                    throw new Error(errorMsg);
                }
                
                const publishBtn = document.getElementById('publish-btn');
                publishBtn.disabled = true;
                publishBtn.textContent = 'Uploading to IPFS...';
                
                // Step 1: Upload video to IPFS via /api/fileupload
                const finalFilename = filename || document.getElementById('modal-video-preview').dataset.filename || `webcam_${Date.now()}.webm`;
                const videoFile = new File([videoBlob], finalFilename, { type: videoBlob.type || 'video/webm' });
                
                const uploadFormData = new FormData();
                uploadFormData.append('file', videoFile);
                if (currentPubkey) {
                    uploadFormData.append('npub', currentPubkey);
                }
                
                console.log('üì§ Uploading video to IPFS via /api/fileupload...');
                console.log('üì§ userPubkey for upload:', currentPubkey ? currentPubkey.substring(0, 8) + '...' : 'MISSING');
                
                const uploadResponse = await fetch('/api/fileupload', {
                    method: 'POST',
                    body: uploadFormData
                });
                
                if (!uploadResponse.ok) {
                    let errorMessage = `Upload failed: ${uploadResponse.statusText}`;
                    try {
                        const errorData = await uploadResponse.json();
                        if (errorData.detail) {
                            errorMessage = errorData.detail;
                        } else if (errorData.message) {
                            errorMessage = errorData.message;
                        } else if (typeof errorData === 'string') {
                            errorMessage = errorData;
                        } else {
                            errorMessage = JSON.stringify(errorData);
                        }
                    } catch (e) {
                        // Already have default error message
                    }
                    throw new Error(errorMessage);
                }
                
                const uploadResult = await uploadResponse.json();
                
                if (!uploadResult.success || !uploadResult.new_cid) {
                    throw new Error(uploadResult.message || 'IPFS upload failed - no CID returned');
                }
                
                console.log('‚úÖ Video uploaded to IPFS:', uploadResult.new_cid);
                
                // Step 2: Publish to NOSTR with IPFS CID
                publishBtn.textContent = 'Retrieving email from profile...';
                
                // Ensure we have a valid email address for player field (required by server)
                // Try to get email from profile if we only have a pubkey
                const playerField = document.getElementById('player');
                let playerValue = '';
                
                // Check if playerField has a valid email already
                if (playerField && playerField.value) {
                    const fieldValue = playerField.value.trim();
                    // Check if it's a valid email (contains @)
                    if (fieldValue.includes('@')) {
                        playerValue = fieldValue;
                    }
                }
                
                // If we don't have a valid email yet, try to get it from profile
                // Note: If email is not found, we can still send the pubkey - the backend will resolve it to email
                if (!playerValue || !playerValue.includes('@')) {
                    const pubkeyToUse = currentPubkey || userPubkey;
                    
                    if (pubkeyToUse) {
                        console.log('üìß Fetching email from NOSTR profile for:', pubkeyToUse.substring(0, 8) + '...');
                        
                        try {
                            // Try to get email from profile using fetchUserEmailWithFallback
                            let fetchedEmail = null;
                            if (typeof fetchUserEmailWithFallback === 'function') {
                                fetchedEmail = await fetchUserEmailWithFallback(pubkeyToUse);
                            } else if (typeof window !== 'undefined' && typeof window.fetchUserEmailWithFallback === 'function') {
                                fetchedEmail = await window.fetchUserEmailWithFallback(pubkeyToUse);
                            }
                            
                            // Check if we got a valid email (not a pubkey)
                            if (fetchedEmail && fetchedEmail.includes('@') && fetchedEmail.length > 5) {
                                playerValue = fetchedEmail;
                                userEmail = fetchedEmail;
                                console.log('‚úÖ Email retrieved from profile:', fetchedEmail);
                            } else if (userEmail && userEmail.includes('@')) {
                                // Use cached userEmail if valid
                                playerValue = userEmail;
                                console.log('‚úÖ Using cached email:', userEmail);
                            } else {
                                // No email found in profile, but we have a pubkey
                                // Backend will resolve pubkey to email via user directory lookup
                                console.log('‚ö†Ô∏è No email found in profile, backend will resolve pubkey to email via directory lookup');
                                // Send empty string - backend will use npub to find email from directory
                                playerValue = '';
                            }
                        } catch (emailError) {
                            console.warn('‚ö†Ô∏è Error fetching email, backend will resolve from directory:', emailError);
                            // Don't throw error - let backend resolve email from directory
                            playerValue = '';
                        }
                    } else {
                        throw new Error('No public key available. Please connect to NOSTR first.');
                    }
                }
                
                // Note: We allow empty playerValue if npub is provided - backend will resolve email from directory
                // Only require email if we don't have npub either
                
                // Update the field value for next time
                if (playerField) {
                    playerField.value = playerValue;
                }
                
                console.log('üì§ Using player email:', playerValue);
                
                const formData = new FormData();
                formData.append('player', playerValue);
                formData.append('ipfs_cid', uploadResult.new_cid);  // Send CID instead of video_blob
                // Pass thumbnail_ipfs from upload2ipfs.sh (centralized thumbnail generation)
                if (uploadResult.thumbnail_ipfs) {
                    formData.append('thumbnail_ipfs', uploadResult.thumbnail_ipfs);
                    console.log('‚úÖ Using thumbnail from upload2ipfs.sh:', uploadResult.thumbnail_ipfs);
                }
                // Pass gifanim_ipfs from upload2ipfs.sh (centralized animated GIF generation)
                if (uploadResult.gifanim_ipfs) {
                    formData.append('gifanim_ipfs', uploadResult.gifanim_ipfs);
                    console.log('‚úÖ Using animated GIF from upload2ipfs.sh:', uploadResult.gifanim_ipfs);
                }
                // Pass metadata from upload2ipfs.sh (centralized extraction)
                if (uploadResult.info) {
                    formData.append('info_cid', uploadResult.info);
                }
                // Pass duration and dimensions from upload result if available
                // Check direct fields first (from JSON response of upload2ipfs.sh)
                if (uploadResult.duration !== undefined && uploadResult.duration !== null) {
                    formData.append('duration', uploadResult.duration.toString());
                    console.log('‚úÖ Using duration from upload2ipfs.sh:', uploadResult.duration);
                }
                // Get dimensions from direct field or metadata
                if (uploadResult.dimensions) {
                    formData.append('video_dimensions', uploadResult.dimensions);
                    console.log('‚úÖ Using dimensions from upload2ipfs.sh:', uploadResult.dimensions);
                } else if (uploadResult.metadata && uploadResult.metadata.media && uploadResult.metadata.media.dimensions) {
                    formData.append('video_dimensions', uploadResult.metadata.media.dimensions);
                    console.log('‚úÖ Using dimensions from metadata:', uploadResult.metadata.media.dimensions);
                }
                // Fallback: duration from metadata if not in direct field
                if (!uploadResult.duration && uploadResult.metadata && uploadResult.metadata.media && uploadResult.metadata.media.duration) {
                    formData.append('duration', uploadResult.metadata.media.duration.toString());
                    console.log('‚úÖ Using duration from metadata:', uploadResult.metadata.media.duration);
                }
                formData.append('title', document.getElementById('video-title').value);
                formData.append('description', document.getElementById('video-description').value);
                formData.append('publish_nostr', document.getElementById('publish-nostr').checked ? 'true' : 'false');
                
                // Get location from modal
                const lat = parseFloat(document.getElementById('modal-lat').value) || 0.00;
                const lon = parseFloat(document.getElementById('modal-lon').value) || 0.00;
                    formData.append('latitude', lat.toString());
                    formData.append('longitude', lon.toString());
                
                if (document.getElementById('publish-nostr').checked && currentPubkey) {
                    formData.append('npub', currentPubkey);
                }
                
                const response = await fetch('/webcam', {
                    method: 'POST',
                    body: formData
                });
                
                if (response.ok) {
                    const result = await response.text();
                    // Re-enable button before showing success modal
                    document.getElementById('publish-btn').disabled = false;
                    document.getElementById('publish-btn').textContent = 'üì° Publish Video';
                    
                    showSuccess(`Video published successfully to IPFS!\n\nCID: ${uploadResult.new_cid}\n\nYour video is now available on UPlanet.`, 'Video Published! üéâ', () => {
                        closeModal();
                        // Reset form and prepare for next recording
                        document.getElementById('publish-form').reset();
                        document.getElementById('start-recording').disabled = false;
                        document.getElementById('start-recording').classList.remove('hidden');
                        document.getElementById('stop-recording').classList.add('hidden');
                        document.getElementById('stop-recording').disabled = false;
                        document.getElementById('stop-recording').textContent = '‚èπÔ∏è Stop Recording';
                        document.getElementById('timer').classList.add('hidden');
                        document.getElementById('timer').textContent = document.getElementById('duration-slider').value;
                    });
                } else {
                    let errorMessage = `Publication failed: ${response.statusText}`;
                    try {
                        const errorData = await response.json();
                        if (errorData.detail) {
                            errorMessage = errorData.detail;
                        } else if (errorData.message) {
                            errorMessage = errorData.message;
                        } else if (typeof errorData === 'string') {
                            errorMessage = errorData;
                        } else {
                            errorMessage = JSON.stringify(errorData);
                        }
                    } catch (e) {
                        try {
                            const text = await response.text();
                            if (text && text.trim()) {
                                errorMessage = text.trim();
                            }
                        } catch (e2) {
                            // Keep default error message
                        }
                    }
                    throw new Error(errorMessage);
                }
                
            } catch (error) {
                console.error('‚ùå Error publishing video:', error);
                const errorMsg = error.message || 'Une erreur est survenue lors de la publication';
                showError(errorMsg, '√âchec de la publication');
                document.getElementById('publish-btn').disabled = false;
                document.getElementById('publish-btn').textContent = 'üì° Publish Video';
            }
        }

        // Utility function to convert blob to base64
        function blobToBase64(blob) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = () => resolve(reader.result.split(',')[1]);
                reader.onerror = reject;
                reader.readAsDataURL(blob);
            });
        }

        // Handle video file upload
        function handleVideoUpload(event) {
            const file = event.target.files[0];
            if (!file) return;
            
            // Validate file type
            const validTypes = ['video/mp4', 'video/webm', 'video/quicktime', 'video/x-msvideo'];
            const validExtensions = ['.mp4', '.webm', '.mov', '.avi'];
            const fileExtension = '.' + file.name.split('.').pop().toLowerCase();
            
            if (!validTypes.includes(file.type) && !validExtensions.includes(fileExtension)) {
                showError('Invalid file type. Please upload a video file in one of these formats: MP4, WebM, MOV, AVI', 'Invalid File Type');
                return;
            }
            
            // Validate file size (max 500MB)
            const maxSize = 500 * 1024 * 1024; // 500MB
            if (file.size > maxSize) {
                showError('File is too large. Maximum allowed size is 500MB. Please compress your video or choose a smaller file.', 'File Too Large');
                return;
            }
            
            // Create blob from file and show in modal
            const videoBlob = new Blob([file], { type: file.type });
            showVideoModal(videoBlob, file.name);
            
            // Auto-fill title with filename (without extension)
            const filenameWithoutExt = file.name.replace(/\.[^/.]+$/, '');
            document.getElementById('video-title').value = filenameWithoutExt;
            
            // Reset file input
            event.target.value = '';
        }

        // Helper function to fill player field and fetch email (reused in multiple places)
        async function fillPlayerFieldAndFetchEmail(pubkey, logPrefix = '') {
            if (!pubkey) return;
            
            const playerField = document.getElementById('player');
            if (!playerField) return;
            
            // First, set pubkey as temporary value
            playerField.value = pubkey;
            
            // Try to fetch email asynchronously (prefer email over pubkey)
            try {
                let fetchedEmail = null;
                
                // Try fetchUserEmail (local function) first
                if (typeof fetchUserEmail === 'function') {
                    await fetchUserEmail();
                    // fetchUserEmail will update userEmail and playerField
                    return;
                }
                
                // Fallback: try fetchUserEmailWithFallback from common.js
                if (typeof fetchUserEmailWithFallback === 'function') {
                    fetchedEmail = await fetchUserEmailWithFallback(pubkey);
                } else if (typeof window !== 'undefined' && typeof window.fetchUserEmailWithFallback === 'function') {
                    fetchedEmail = await window.fetchUserEmailWithFallback(pubkey);
                }
                
                // Check if we got a valid email (not a pubkey)
                if (fetchedEmail && fetchedEmail.includes('@') && fetchedEmail.length > 5 && fetchedEmail !== pubkey) {
                    playerField.value = fetchedEmail;
                    userEmail = fetchedEmail;
                    console.log('‚úÖ Email retrieved and set in player field:', fetchedEmail);
                } else {
                    console.warn('‚ö†Ô∏è No email found in profile, player field contains pubkey (server may reject)');
                }
            } catch (err) {
                console.warn('‚ö†Ô∏è Could not fetch user email, player field contains pubkey:', err);
            }
        }
        
        // Initialize connection variables from parent window if in iframe
        function initializeConnectionVars() {
            const isInIframe = window.self !== window.top;
            
            // Try multiple times to get userPubkey (parent might not be ready immediately)
            let attempts = 0;
            const maxAttempts = 10;
            
            const tryGetConnection = () => {
                attempts++;
                let foundPubkey = null;
                
                // Strategy 1: Try to get from current window (check both global and window scope)
                if (typeof window !== 'undefined' && window.userPubkey) {
                    foundPubkey = window.userPubkey;
                    userPubkey = foundPubkey;
                    if (window.nostrRelay) nostrRelay = window.nostrRelay;
                    if (typeof window.isNostrConnected !== 'undefined') isNostrConnected = window.isNostrConnected;
                    console.log('‚úÖ Using connection from current window.userPubkey:', foundPubkey.substring(0, 8) + '...');
                } else if (typeof userPubkey !== 'undefined' && userPubkey) {
                    foundPubkey = userPubkey;
                    // Set in window for easier access
                    if (typeof window !== 'undefined') {
                        window.userPubkey = foundPubkey;
                    }
                    console.log('‚úÖ Using connection from current window global scope:', foundPubkey.substring(0, 8) + '...');
                }
                // Strategy 2: If in iframe, try to get from parent window
                else if (isInIframe && window.parent) {
                    try {
                        if (window.parent.userPubkey) {
                            foundPubkey = window.parent.userPubkey;
                            userPubkey = foundPubkey;
                            nostrRelay = window.parent.nostrRelay || null;
                            isNostrConnected = window.parent.isNostrConnected || false;
                            
                            // Set in current window for easier access
                            if (typeof window !== 'undefined') {
                                window.userPubkey = foundPubkey;
                                window.nostrRelay = nostrRelay;
                                window.isNostrConnected = isNostrConnected;
                            }
                            
                            console.log('‚úÖ Using connection from parent window:', foundPubkey ? foundPubkey.substring(0, 8) + '...' : 'none');
                        } else {
                            if (attempts >= maxAttempts) {
                                console.warn('‚ö†Ô∏è Parent window has no userPubkey after', maxAttempts, 'attempts');
                            }
                            return false;
                        }
                    } catch (e) {
                        // Cross-origin or other error
                        if (attempts >= maxAttempts) {
                            console.warn('‚ö†Ô∏è Cannot access parent window variables:', e.message);
                        }
                        return false;
                    }
                } else {
                    return false;
                }
                
                // If we found a pubkey, fill player field and fetch email
                if (foundPubkey) {
                    // fillPlayerFieldAndFetchEmail is async but we call it without await (non-blocking)
                    fillPlayerFieldAndFetchEmail(foundPubkey).catch(err => {
                        console.warn('‚ö†Ô∏è Error filling player field:', err);
                    });
                    return true;
                }
                
                return false;
            };
            
            // Try immediately
            if (tryGetConnection()) {
                return;
            }
            
            // Retry with intervals if not found
            const retryInterval = setInterval(() => {
                if (tryGetConnection() || attempts >= maxAttempts) {
                    clearInterval(retryInterval);
                }
            }, 500);
        }
        
        // Called when connection is successful (simplified - no UI updates needed without header)
        async function onConnectionSuccess() {
            if (!userPubkey) return;
            
            // Ensure webcam section is visible
            document.getElementById('webcam-section').style.display = 'block';
            document.getElementById('central-connection').classList.add('hidden');
            
            console.log('‚úÖ Connection successful:', userPubkey.substring(0, 8) + '...');
        }
        
        // Connect to NOSTR (simplified - assumes connection exists from parent, no UI)
        async function handleNostrConnect() {
            try {
                const isInIframe = window.self !== window.top;
                
                // Always try parent window first if in iframe
                if (isInIframe && window.parent && window.parent.userPubkey) {
                    console.log('‚úÖ Using existing connection from parent window');
                    userPubkey = window.parent.userPubkey;
                    if (window.parent.nostrRelay) {
                        nostrRelay = window.parent.nostrRelay;
                    }
                    if (window.parent.isNostrConnected) {
                        isNostrConnected = window.parent.isNostrConnected;
                    }
                } else if (typeof connectNostr === 'function') {
                    // Fallback to connectNostr from common.js
                    const pubkey = await connectNostr();
                    if (pubkey) {
                        userPubkey = pubkey;
                    } else {
                        throw new Error("Connection failed");
                    }
                } else {
                    throw new Error("NOSTR connection not available");
                }
                
                // Try to connect to relay if not already connected
                if (!nostrRelay || !isNostrConnected) {
                    if (typeof connectToRelay === 'function') {
                        await connectToRelay();
                    }
                }
                
                // Fetch user email if available
                if (typeof fetchUserEmail === 'function') {
                    await fetchUserEmail();
                }
                
                // Update UI
                await onConnectionSuccess();
                
            } catch (error) {
                console.error("Connection error:", error);
                throw error;
            }
        }

        // Fetch user email from NOSTR DID document
        async function fetchUserEmail() {
            if (!userPubkey) return;
            
            try {
                // Use fetchUserEmailWithFallback from common.js if available
                if (typeof fetchUserEmailWithFallback === 'function') {
                    userEmail = await fetchUserEmailWithFallback(userPubkey);
                } else {
                    // Fallback: try to get from window if available
                    if (typeof window !== 'undefined' && typeof window.fetchUserEmailWithFallback === 'function') {
                        userEmail = await window.fetchUserEmailWithFallback(userPubkey);
                    } else {
                        console.warn('‚ö†Ô∏è fetchUserEmailWithFallback not available, using pubkey');
                        userEmail = null;
                    }
                }
                
                if (userEmail === userPubkey) {
                    userEmail = null;
                }
                
                const playerField = document.getElementById('player');
                if (playerField) {
                    playerField.value = userEmail || userPubkey;
                }
            } catch (error) {
                console.error('Error fetching user email:', error);
                userEmail = null;
                const playerField = document.getElementById('player');
                if (playerField) {
                    playerField.value = userPubkey;
                }
            }
        }


        // Initialize on page load
        document.addEventListener('DOMContentLoaded', function() {
            // Initialize connection variables from parent if in iframe
            initializeConnectionVars();
            
            // Auto-connect with nsec if provided
            if (AUTO_CONNECT_NSEC && AUTO_CONNECT_NSEC !== null && AUTO_CONNECT_NSEC.trim() !== '') {
                const nsecRadio = document.getElementById('auth-nsec');
                const nsecInput = document.getElementById('nsec-key');
                const nsecContainer = document.getElementById('nsec-input-container');
                
                if (nsecRadio && nsecInput && nsecContainer) {
                    nsecRadio.checked = true;
                    nsecContainer.classList.add('visible');
                    authMode = 'nsec';
                    nsecInput.value = AUTO_CONNECT_NSEC;
                    
                    setTimeout(() => {
                        handleNostrConnect();
                    }, 700);
                }
            }
            
            // Handle auth mode change
            const authRadios = document.querySelectorAll('input[name="auth-mode"]');
            authRadios.forEach(radio => {
                radio.addEventListener('change', function() {
                    authMode = this.value;
                    const nsecContainer = document.getElementById('nsec-input-container');
                    if (authMode === 'nsec') {
                        nsecContainer.classList.add('visible');
                    } else {
                        nsecContainer.classList.remove('visible');
                    }
                });
            });
            
            // Handle video file upload
            const videoUpload = document.getElementById('video-upload');
            if (videoUpload) {
                videoUpload.addEventListener('change', handleVideoUpload);
            }
            
            // Initialize webcam features (always initialize, even if hidden)
            initWebcamFeatures();
        });
        
        // Close modal when clicking outside
        window.onclick = function(event) {
            const modal = document.getElementById('video-modal');
            if (event.target === modal) {
                closeModal();
            }
        }
    </script>
</body>
</html>
