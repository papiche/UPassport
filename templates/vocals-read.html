<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, user-scalable=yes, viewport-fit=cover">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <title>üéß Voice Messages Reader - Decrypt & Play</title>
    
    <!-- Bootstrap 5 CSS -->
    <link href="{{ myIPFS }}/ipns/copylaradio.com/bootstrap.min.css" rel="stylesheet">
    <!-- Bootstrap Icons -->
    <link rel="stylesheet" href="{{ myIPFS }}/ipns/copylaradio.com/fonts/bootstrap-icons.css">
    <!-- Bootstrap 5 JS Bundle -->
    <script src="{{ myIPFS }}/ipns/copylaradio.com/bootstrap.bundle.min.js"></script>
    
    <!-- Nostr integration -->
    <script src="{{ myIPFS }}/ipns/copylaradio.com/nostr.bundle.js"></script>

    <!-- Common.js with enhanced UPlanet NOSTR functions -->
    <script src="{{ myIPFS }}/ipns/copylaradio.com/common.js"></script>
    
    <style>
        * {
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Roboto', 'Arial', sans-serif;
            background: #0f0f0f;
            color: #ffffff;
            min-height: 100vh;
            margin: 0;
            padding: 0;
            overflow-x: hidden;
        }
        
        .header {
            background: #212121;
            backdrop-filter: blur(10px);
            border-bottom: 1px solid #3f3f3f;
            padding: 0.75rem 1.5rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
            gap: 1rem;
            position: sticky;
            top: 0;
            z-index: 100;
        }
        
        .header h1 {
            color: #ffffff;
            margin: 0;
            font-size: 1.3em;
            font-weight: 400;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .main-container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 1.5rem;
        }
        
        .voice-message-card {
            background: #181818;
            border: 1px solid #3f3f3f;
            border-radius: 12px;
            padding: 1.5rem;
            margin-bottom: 1rem;
            transition: all 0.3s ease;
        }
        
        .voice-message-card:hover {
            border-color: #065fd4;
            box-shadow: 0 4px 12px rgba(6, 95, 212, 0.2);
        }
        
        .voice-message-card.encrypted {
            border-color: #f59e0b;
            background: rgba(245, 158, 11, 0.05);
        }
        
        /* Threading styles */
        .thread-container {
            margin-bottom: 1.5rem;
        }
        
        .thread-root {
            border-left: 3px solid #065fd4;
        }
        
        .thread-reply {
            margin-left: 2rem;
            margin-top: 0.75rem;
            border-left: 2px solid #3f3f3f;
            padding-left: 1rem;
            background: rgba(63, 63, 63, 0.2);
            border-radius: 8px;
        }
        
        .thread-reply-nested {
            margin-left: 2rem;
        }
        
        .reply-count {
            display: inline-flex;
            align-items: center;
            gap: 4px;
            padding: 4px 8px;
            background: rgba(6, 95, 212, 0.1);
            border: 1px solid rgba(6, 95, 212, 0.3);
            border-radius: 12px;
            font-size: 0.75em;
            color: #60a5fa;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        
        .reply-count:hover {
            background: rgba(6, 95, 212, 0.2);
            border-color: #065fd4;
        }
        
        .replies-container {
            margin-top: 1rem;
            padding-top: 1rem;
            border-top: 1px solid rgba(63, 63, 63, 0.5);
        }
        
        .replies-container.collapsed {
            display: none;
        }
        
        .thread-line {
            position: absolute;
            left: 0;
            top: 0;
            bottom: 0;
            width: 2px;
            background: #3f3f3f;
        }
        
        .reply-button {
            background: transparent;
            border: 1px solid #3f3f3f;
            color: #94a3b8;
            padding: 0.375rem 0.75rem;
            border-radius: 6px;
            font-size: 0.85em;
            cursor: pointer;
            transition: all 0.2s ease;
            display: inline-flex;
            align-items: center;
            gap: 4px;
        }
        
        .reply-button:hover {
            border-color: #065fd4;
            color: #60a5fa;
            background: rgba(6, 95, 212, 0.1);
        }
        
        .voice-message-header {
            display: flex;
            justify-content: space-between;
            align-items: start;
            margin-bottom: 1rem;
            flex-wrap: wrap;
            gap: 1rem;
        }
        
        .voice-message-info {
            flex: 1;
            min-width: 200px;
        }
        
        .voice-message-title {
            font-size: 1.2em;
            font-weight: 600;
            color: #ffffff;
            margin-bottom: 0.5rem;
        }
        
        .voice-message-meta {
            font-size: 0.85em;
            color: #94a3b8;
            display: flex;
            gap: 1rem;
            flex-wrap: wrap;
        }
        
        .voice-message-actions {
            display: flex;
            gap: 0.5rem;
            flex-wrap: wrap;
        }
        
        .encryption-badge {
            display: inline-flex;
            align-items: center;
            gap: 4px;
            padding: 4px 8px;
            background: rgba(245, 158, 11, 0.2);
            border: 1px solid #f59e0b;
            border-radius: 4px;
            font-size: 0.75em;
            color: #fbbf24;
        }
        
        .audio-player-container {
            margin: 1rem 0;
            padding: 1rem;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
        }
        
        .audio-player {
            width: 100%;
            height: 60px;
        }
        
        .waveform-container {
            height: 80px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 4px;
            margin: 1rem 0;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #94a3b8;
            font-size: 0.85em;
        }
        
        .loading-spinner {
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 3px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            border-top-color: #065fd4;
            animation: spin 1s ease-in-out infinite;
        }
        
        @keyframes spin {
            to { transform: rotate(360deg); }
        }
        
        .error-message {
            color: #ef4444;
            padding: 0.5rem;
            background: rgba(239, 68, 68, 0.1);
            border-radius: 4px;
            margin: 0.5rem 0;
        }
        
        .decrypt-button {
            background: #f59e0b;
            color: #000;
            border: none;
            padding: 0.5rem 1rem;
            border-radius: 6px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        .decrypt-button:hover {
            background: #fbbf24;
            transform: translateY(-1px);
        }
        
        .decrypt-button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        
        .filters-section {
            background: #181818;
            border: 1px solid #3f3f3f;
            border-radius: 12px;
            padding: 1.5rem;
            margin-bottom: 1.5rem;
        }
        
        .filters-section h3 {
            font-size: 1.1em;
            margin-bottom: 1rem;
            color: #ffffff;
        }
        
        .filter-group {
            display: flex;
            gap: 1rem;
            flex-wrap: wrap;
            align-items: center;
        }
        
        .filter-group label {
            font-size: 0.9em;
            color: #e2e8f0;
        }
        
        .filter-group select,
        .filter-group input {
            padding: 0.5rem;
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid #3f3f3f;
            border-radius: 6px;
            color: #ffffff;
            font-size: 0.9em;
        }
        
        .empty-state {
            text-align: center;
            padding: 3rem;
            color: #94a3b8;
        }
        
        .empty-state-icon {
            font-size: 4em;
            margin-bottom: 1rem;
        }
        
        @media (max-width: 767.98px) {
            .main-container {
                padding: 1rem;
            }
            
            .voice-message-card {
                padding: 1rem;
            }
            
            .voice-message-header {
                flex-direction: column;
            }
        }
    </style>
</head>
<body class="bg-dark text-white">
    <!-- Header -->
    <header class="header bg-dark border-bottom border-secondary sticky-top">
        <div class="container-fluid">
            <div class="d-flex flex-wrap justify-content-between align-items-center gap-3 py-2">
                <div class="d-flex align-items-center gap-3 flex-wrap">
                    <h1 class="mb-0">üéß Voice Messages Reader</h1>
                </div>
                
                <!-- NOSTR Connection Status -->
                <div class="d-flex align-items-center gap-2 flex-wrap" id="nostr-header">
                    <button id="connect-btn" class="btn btn-primary btn-sm" onclick="handleNostrConnect()">
                        üîå Connect
                    </button>
                    <span id="connection-status" class="text-secondary small d-none">Connected</span>
                </div>
            </div>
        </div>
    </header>
    
    <!-- Main Container -->
    <main class="main-container">
        <!-- Filters Section -->
        <div class="filters-section">
            <h3>üîç Filters</h3>
            <div class="filter-group">
                <label for="filter-type">Type:</label>
                <select id="filter-type" class="form-select form-select-sm bg-dark text-white border-secondary">
                    <option value="all">All Messages</option>
                    <option value="public">Public Only</option>
                    <option value="encrypted">Encrypted Only</option>
                    <option value="sent">Sent by Me</option>
                    <option value="received">Received by Me</option>
                </select>
                
                <label for="filter-since">Since:</label>
                <select id="filter-since" class="form-select form-select-sm bg-dark text-white border-secondary">
                    <option value="1h">Last Hour</option>
                    <option value="24h" selected>Last 24 Hours</option>
                    <option value="7d">Last 7 Days</option>
                    <option value="30d">Last 30 Days</option>
                    <option value="all">All Time</option>
                </select>
                
                <button id="refresh-btn" class="btn btn-primary btn-sm" onclick="loadVoiceMessages()">
                    üîÑ Refresh
                </button>
            </div>
        </div>
        
        <!-- Voice Messages List -->
        <div id="voice-messages-container">
            <div class="empty-state">
                <div class="empty-state-icon">üé§</div>
                <p>Connect to NOSTR to load voice messages</p>
            </div>
        </div>
    </main>
    
    <!-- Reply Recording Modal -->
    <div class="modal fade" id="reply-modal" tabindex="-1" aria-labelledby="reply-modal-title" aria-hidden="true" data-bs-backdrop="true" data-bs-keyboard="true">
        <div class="modal-dialog modal-dialog-centered modal-lg">
            <div class="modal-content bg-dark border-secondary">
                <div class="modal-header border-secondary">
                    <h5 class="modal-title text-white" id="reply-modal-title">üé§ Reply with Voice Message</h5>
                    <button type="button" class="btn-close btn-close-white" data-bs-dismiss="modal" aria-label="Close"></button>
                </div>
                <div class="modal-body">
                    <div class="mb-3">
                        <p class="text-secondary small mb-2">Replying to:</p>
                        <div id="reply-to-preview" class="p-2 bg-dark border border-secondary rounded"></div>
                    </div>
                    
                    <div class="alert alert-info d-none" id="reply-recording-status">
                        <span class="spinner-border spinner-border-sm me-2" role="status"></span>
                        <span id="reply-status-text">Preparing recording...</span>
                    </div>
                    
                    <div id="reply-recording-controls" class="d-none">
                        <div class="text-center mb-3">
                            <div id="reply-timer" class="fs-2 fw-bold text-danger mb-3">30</div>
                            <div class="d-flex gap-2 justify-content-center">
                                <button id="reply-start-recording" class="btn btn-primary">
                                    üé§ Start Recording
                                </button>
                                <button id="reply-stop-recording" class="btn btn-danger d-none">
                                    ‚èπÔ∏è Stop
                                </button>
                            </div>
                        </div>
                        
                        <div class="mb-3">
                            <label class="form-label text-white small">Or upload audio file:</label>
                            <input type="file" class="form-control form-control-sm bg-dark text-white border-secondary" 
                                   id="reply-audio-upload" accept="audio/*,.mp3,.wav,.ogg,.flac,.aac,.m4a">
                        </div>
                    </div>
                    
                    <div id="reply-preview-section" class="d-none">
                        <div class="text-center mb-3">
                            <audio id="reply-audio-preview" class="w-100" controls style="max-height: 60px;"></audio>
                        </div>
                        
                        <div class="mb-3">
                            <label for="reply-title" class="form-label text-white">Title (optional):</label>
                            <input type="text" class="form-control bg-dark text-white border-secondary" 
                                   id="reply-title" placeholder="Reply title...">
                        </div>
                        
                        <div class="mb-3">
                            <label for="reply-description" class="form-label text-white">Description (optional):</label>
                            <textarea class="form-control bg-dark text-white border-secondary" 
                                      id="reply-description" rows="2" placeholder="Reply description..."></textarea>
                        </div>
                    </div>
                </div>
                <div class="modal-footer border-secondary">
                    <button type="button" class="btn btn-outline-secondary" data-bs-dismiss="modal">Cancel</button>
                    <button type="button" class="btn btn-primary" id="reply-publish-btn" disabled>
                        üì° Publish Reply
                    </button>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Global variables
        let userPubkey = null;
        let userPrivateKey = null;
        let nostrPool = null;
        let isNostrConnected = false;
        let nostrRelay = null;
        
        // Default relays
        const DEFAULT_RELAYS = ['wss://astroport.com', 'wss://relay.damus.io', 'wss://nos.lol'];
        
        // Voice messages cache
        let voiceMessagesCache = [];
        
        // Connect to NOSTR
        async function handleNostrConnect() {
            try {
                const connectBtn = document.getElementById('connect-btn');
                connectBtn.disabled = true;
                connectBtn.textContent = 'üîÑ Connecting...';
                
                // Check if window.nostr is available
                if (typeof window.nostr === 'undefined' || !window.nostr) {
                    throw new Error('NOSTR extension not detected. Please install a NOSTR extension like Alby, nos2x, or Flamingo.');
                }
                
                // Get public key
                userPubkey = await window.nostr.getPublicKey();
                if (!userPubkey) {
                    throw new Error('No public key returned from NOSTR extension');
                }
                
                console.log('‚úÖ Connected to NOSTR, pubkey:', userPubkey.substring(0, 8) + '...');
                
                // Initialize NOSTR pool
                if (typeof NostrTools !== 'undefined' && NostrTools.SimplePool) {
                    nostrPool = new NostrTools.SimplePool();
                } else {
                    throw new Error('NostrTools.SimplePool not available');
                }
                
                isNostrConnected = true;
                
                // Update UI
                connectBtn.textContent = '‚úÖ Connected';
                connectBtn.disabled = true;
                connectBtn.classList.remove('btn-primary');
                connectBtn.classList.add('btn-secondary');
                
                const statusEl = document.getElementById('connection-status');
                if (statusEl) {
                    statusEl.textContent = `Connected: ${userPubkey.substring(0, 8)}...`;
                    statusEl.classList.remove('d-none');
                }
                
                // Load voice messages
                await loadVoiceMessages();
                
            } catch (error) {
                console.error('‚ùå Connection error:', error);
                const connectBtn = document.getElementById('connect-btn');
                connectBtn.disabled = false;
                connectBtn.textContent = 'üîå Retry';
                alert(`Connection failed: ${error.message}`);
            }
        }
        
        // Load voice messages from NOSTR
        async function loadVoiceMessages() {
            if (!userPubkey || !nostrPool) {
                console.warn('‚ö†Ô∏è Not connected to NOSTR');
                return;
            }
            
            const container = document.getElementById('voice-messages-container');
            const refreshBtn = document.getElementById('refresh-btn');
            
            try {
                refreshBtn.disabled = true;
                refreshBtn.innerHTML = '<span class="loading-spinner"></span> Loading...';
                container.innerHTML = '<div class="text-center p-4"><div class="loading-spinner"></div><p class="mt-2">Loading voice messages...</p></div>';
                
                // Get filter values
                const filterType = document.getElementById('filter-type').value;
                const filterSince = document.getElementById('filter-since').value;
                
                // Calculate since timestamp
                let since = 0;
                const now = Math.floor(Date.now() / 1000);
                switch (filterSince) {
                    case '1h':
                        since = now - 3600;
                        break;
                    case '24h':
                        since = now - 86400;
                        break;
                    case '7d':
                        since = now - 604800;
                        break;
                    case '30d':
                        since = now - 2592000;
                        break;
                    case 'all':
                        since = 0;
                        break;
                }
                
                // Build filter
                const filter = {
                    kinds: [1222, 1244], // Voice message kinds
                    since: since,
                    limit: 100
                };
                
                // Adjust filter based on type
                if (filterType === 'sent') {
                    filter.authors = [userPubkey];
                } else if (filterType === 'received') {
                    // For received, we need to check p tags
                    // This is handled in post-processing
                }
                
                console.log('üì° Fetching voice messages with filter:', filter);
                
                // Fetch events from relays
                const events = await nostrPool.list(DEFAULT_RELAYS, [filter]);
                
                console.log(`‚úÖ Fetched ${events.length} voice message events`);
                
                // Process events
                const processedMessages = await processVoiceMessageEvents(events, filterType);
                
                // Organize messages into threads
                const threads = organizeIntoThreads(processedMessages);
                
                // Update cache (flat list for decryption)
                voiceMessagesCache = processedMessages;
                
                // Render threads
                renderThreads(threads);
                
            } catch (error) {
                console.error('‚ùå Error loading voice messages:', error);
                container.innerHTML = `<div class="error-message">Error loading voice messages: ${error.message}</div>`;
            } finally {
                refreshBtn.disabled = false;
                refreshBtn.innerHTML = 'üîÑ Refresh';
            }
        }
        
        // Process voice message events
        async function processVoiceMessageEvents(events, filterType) {
            const processed = [];
            
            for (const event of events) {
                try {
                    // Check if encrypted
                    const isEncrypted = event.tags.some(tag => tag[0] === 'encrypted' && tag[1] === 'true');
                    const encryptionMethod = event.tags.find(tag => tag[0] === 'encryption')?.[1] || 'nip44';
                    
                    // Check expiration date (NIP-40: Expiration Timestamp)
                    // Relays supporting NIP-40 will delete the event after this timestamp
                    const expirationTag = event.tags.find(tag => tag[0] === 'expiration');
                    let expirationTimestamp = null;
                    let isExpired = false;
                    
                    if (expirationTag && expirationTag[1]) {
                        expirationTimestamp = parseInt(expirationTag[1]);
                        const now = Math.floor(Date.now() / 1000);
                        
                        if (expirationTimestamp < now) {
                            isExpired = true; // Message has expired (relay should have deleted it, but may still be visible)
                        }
                    }
                    
                    // Check if received (for filterType === 'received')
                    if (filterType === 'received') {
                        const recipientTags = event.tags.filter(tag => tag[0] === 'p');
                        const isRecipient = recipientTags.some(tag => {
                            // Convert npub to hex for comparison
                            try {
                                const hexPubkey = npubToHex(tag[1]);
                                return hexPubkey && hexPubkey.toLowerCase() === userPubkey.toLowerCase();
                            } catch (e) {
                                return false;
                            }
                        });
                        
                        if (!isRecipient && event.pubkey !== userPubkey) {
                            continue; // Skip if not a recipient and not sent by user
                        }
                    }
                    
                    // Check if public (for filterType === 'public')
                    if (filterType === 'public' && isEncrypted) {
                        continue; // Skip encrypted messages
                    }
                    
                    // Check if encrypted (for filterType === 'encrypted')
                    if (filterType === 'encrypted' && !isEncrypted) {
                        continue; // Skip public messages
                    }
                    
                    // Parse imeta tags for metadata
                    const imetaTags = event.tags.filter(tag => tag[0] === 'imeta');
                    let metadata = {};
                    imetaTags.forEach(tag => {
                        if (tag.length > 1) {
                            const imetaContent = tag.slice(1).join(' ');
                            // Parse imeta format: "url https://... duration 45 waveform ... title ... description ..."
                            const parts = imetaContent.split(/\s+/);
                            for (let i = 0; i < parts.length; i += 2) {
                                if (i + 1 < parts.length) {
                                    const key = parts[i];
                                    let value = parts[i + 1];
                                    // Handle multi-word values (e.g., descriptions with spaces)
                                    if (key === 'description' || key === 'title') {
                                        // Collect remaining parts for description/title
                                        value = parts.slice(i + 1).join(' ');
                                        i = parts.length; // Skip remaining iterations
                                    }
                                    if (key === 'duration') {
                                        metadata.duration = parseFloat(value);
                                    } else if (key === 'waveform') {
                                        metadata.waveform = value;
                                    } else if (key === 'url') {
                                        metadata.url = value;
                                    } else if (key === 'title') {
                                        metadata.title = value;
                                    } else if (key === 'description') {
                                        metadata.description = value;
                                    }
                                }
                            }
                        }
                    });
                    
                    // Also check for title and description in separate tags (if present)
                    const titleTag = event.tags.find(tag => tag[0] === 'title');
                    if (titleTag && titleTag[1]) {
                        metadata.title = titleTag[1];
                    }
                    const descriptionTag = event.tags.find(tag => tag[0] === 'description');
                    if (descriptionTag && descriptionTag[1]) {
                        metadata.description = descriptionTag[1];
                    }
                    
                    // Get sender profile
                    let senderProfile = null;
                    try {
                        const profileEvents = await nostrPool.list(DEFAULT_RELAYS, [
                            { kinds: [0], authors: [event.pubkey], limit: 1 }
                        ]);
                        if (profileEvents.length > 0) {
                            senderProfile = JSON.parse(profileEvents[0].content);
                        }
                    } catch (e) {
                        console.warn('‚ö†Ô∏è Could not fetch sender profile:', e);
                    }
                    
                    // Detect if this is a reply (kind 1244) and extract thread info
                    const isReply = event.kind === 1244;
                    let rootEventId = null;
                    let parentEventId = null;
                    let replyToPubkey = null;
                    
                    if (isReply) {
                        // NIP-22: Extract e tags for root and parent
                        const eTags = event.tags.filter(tag => tag[0] === 'e');
                        // Find root (usually first e tag or marked with "root")
                        const rootTag = eTags.find(tag => tag.length > 3 && tag[3] === 'root') || 
                                       eTags.find(tag => tag.length === 2 || tag.length === 3);
                        if (rootTag) {
                            rootEventId = rootTag[1];
                        }
                        // Find parent (marked with "reply" or second e tag)
                        const parentTag = eTags.find(tag => tag.length > 3 && tag[3] === 'reply') ||
                                         (eTags.length > 1 ? eTags[1] : null);
                        if (parentTag) {
                            parentEventId = parentTag[1];
                        }
                        // Extract p tag for the original sender
                        const pTags = event.tags.filter(tag => tag[0] === 'p');
                        if (pTags.length > 0) {
                            replyToPubkey = pTags[0][1];
                        }
                    }
                    
                    processed.push({
                        event: event,
                        id: event.id,
                        kind: event.kind,
                        pubkey: event.pubkey,
                        created_at: event.created_at,
                        content: event.content,
                        isEncrypted: isEncrypted,
                        encryptionMethod: encryptionMethod,
                        metadata: metadata,
                        senderProfile: senderProfile,
                        tags: event.tags,
                        expirationTimestamp: expirationTimestamp,
                        isExpired: isExpired,
                        isReply: isReply,
                        rootEventId: rootEventId,
                        parentEventId: parentEventId || rootEventId,
                        replyToPubkey: replyToPubkey
                    });
                    
                } catch (error) {
                    console.error('‚ùå Error processing event:', error);
                }
            }
            
            return processed;
        }
        
        // Organize messages into threads
        function organizeIntoThreads(messages) {
            const threads = new Map(); // rootEventId -> { root: message, replies: [] }
            const replyMap = new Map(); // replyId -> reply message
            
            // First pass: identify roots and replies
            for (const msg of messages) {
                if (msg.isReply) {
                    replyMap.set(msg.id, msg);
                } else {
                    // Root message (kind 1222)
                    threads.set(msg.id, {
                        root: msg,
                        replies: [],
                        allReplies: new Map() // For nested replies
                    });
                }
            }
            
            // Second pass: attach replies to threads
            for (const [replyId, reply] of replyMap) {
                const rootId = reply.rootEventId || reply.parentEventId;
                if (rootId && threads.has(rootId)) {
                    const thread = threads.get(rootId);
                    // Build reply tree
                    attachReplyToThread(reply, thread, replyMap);
                } else {
                    // Orphan reply - create a thread for it
                    threads.set(replyId, {
                        root: reply,
                        replies: [],
                        allReplies: new Map()
                    });
                }
            }
            
            // Convert to array and sort by root created_at (newest first)
            return Array.from(threads.values()).sort((a, b) => 
                b.root.created_at - a.root.created_at
            );
        }
        
        // Recursively attach replies to thread
        function attachReplyToThread(reply, thread, replyMap) {
            thread.allReplies.set(reply.id, reply);
            
            const parentId = reply.parentEventId;
            if (parentId === thread.root.id) {
                // Direct reply to root
                thread.replies.push(reply);
            } else if (thread.allReplies.has(parentId)) {
                // Nested reply - attach to parent reply
                const parentReply = thread.allReplies.get(parentId);
                if (!parentReply.replies) {
                    parentReply.replies = [];
                }
                parentReply.replies.push(reply);
            } else {
                // Fallback: attach to root
                thread.replies.push(reply);
            }
        }
        
        // Render threads
        function renderThreads(threads) {
            const container = document.getElementById('voice-messages-container');
            
            if (threads.length === 0) {
                container.innerHTML = `
                    <div class="empty-state">
                        <div class="empty-state-icon">üé§</div>
                        <p>No voice messages found</p>
                    </div>
                `;
                return;
            }
            
            container.innerHTML = threads.map(thread => {
                return renderThread(thread);
            }).join('');
            
            // Attach event listeners for reply buttons and expand/collapse
            attachThreadEventListeners();
        }
        
        // Render a single thread (root + replies)
        function renderThread(thread) {
            const root = thread.root;
            const replyCount = thread.allReplies.size;
            const hasReplies = replyCount > 0;
            
            return `
                <div class="thread-container">
                    ${renderMessageCard(root, 'root', hasReplies, replyCount)}
                    ${hasReplies ? `
                        <div class="replies-container" id="replies-${root.id}">
                            ${thread.replies.map(reply => renderReplyTree(reply, 0)).join('')}
                        </div>
                    ` : ''}
                </div>
            `;
        }
        
        // Render reply tree recursively
        function renderReplyTree(reply, depth) {
            const hasNestedReplies = reply.replies && reply.replies.length > 0;
            const nestedCount = hasNestedReplies ? reply.replies.length : 0;
            
            return `
                <div class="thread-reply ${depth > 0 ? 'thread-reply-nested' : ''}" style="margin-left: ${depth * 2}rem;" data-event-id="${reply.id}">
                    ${renderMessageCard(reply, 'reply', hasNestedReplies, nestedCount)}
                    ${hasNestedReplies ? `
                        <div class="replies-container" id="replies-${reply.id}">
                            ${reply.replies.map(nestedReply => renderReplyTree(nestedReply, depth + 1)).join('')}
                        </div>
                    ` : ''}
                </div>
            `;
        }
        
        // Render a single message card
        function renderMessageCard(msg, type, hasReplies, replyCount) {
            const date = new Date(msg.created_at * 1000);
            const dateStr = date.toLocaleString();
            const senderName = msg.senderProfile?.name || msg.senderProfile?.display_name || msg.pubkey.substring(0, 8) + '...';
            const senderPicture = msg.senderProfile?.picture || '';
            const isRoot = type === 'root';
            const cardClass = isRoot ? 'thread-root' : '';
            
            return `
                <div class="voice-message-card ${msg.isEncrypted ? 'encrypted' : ''} ${cardClass}" data-event-id="${msg.id}" data-kind="${msg.kind}">
                    <div class="voice-message-header">
                        <div class="voice-message-info">
                            <div class="voice-message-title">
                                ${msg.metadata.title || 'Voice Message'}
                                ${msg.isEncrypted ? '<span class="encryption-badge">üîê Encrypted</span>' : ''}
                                ${msg.isExpired ? '<span class="encryption-badge" style="background: rgba(239, 68, 68, 0.2); border-color: #ef4444; color: #fca5a5;">‚è∞ Expired (NIP-40)</span>' : ''}
                                ${msg.expirationTimestamp && !msg.isExpired ? `<span class="encryption-badge" style="background: rgba(59, 130, 246, 0.2); border-color: #3b82f6; color: #93c5fd;">‚è∞ Expires: ${new Date(msg.expirationTimestamp * 1000).toLocaleString()} (NIP-40)</span>` : ''}
                            </div>
                            <div class="voice-message-meta">
                                <span>üë§ ${senderName}</span>
                                <span>üìÖ ${dateStr}</span>
                                ${msg.metadata.duration ? `<span>‚è±Ô∏è ${Math.round(msg.metadata.duration)}s</span>` : ''}
                                ${msg.isReply ? '<span class="text-secondary">‚Ü©Ô∏è Reply</span>' : ''}
                            </div>
                        </div>
                        <div class="voice-message-actions">
                            ${msg.isEncrypted ? `
                                <button class="decrypt-button btn btn-sm" onclick="decryptAndPlayMessage('${msg.id}', this)">
                                    üîì Decrypt & Play
                                </button>
                            ` : `
                                <button class="btn btn-primary btn-sm" onclick="playMessage('${msg.id}')">
                                    ‚ñ∂Ô∏è Play
                                </button>
                            `}
                            <button class="reply-button btn btn-sm" onclick="openReplyModal('${msg.id}')" title="Reply to this message">
                                üí¨ Reply
                            </button>
                        </div>
                    </div>
                    ${msg.metadata.description ? `<p class="text-secondary small mb-2">${msg.metadata.description}</p>` : ''}
                    ${hasReplies ? `
                        <div class="mt-2">
                            <span class="reply-count" onclick="toggleReplies('${msg.id}')" id="reply-toggle-${msg.id}">
                                üí¨ ${replyCount} ${replyCount === 1 ? 'reply' : 'replies'}
                            </span>
                        </div>
                    ` : ''}
                    ${msg.isEncrypted ? `
                        <div id="decrypt-status-${msg.id}" class="d-none"></div>
                        <div id="audio-container-${msg.id}" class="d-none">
                            <div class="audio-player-container">
                                <audio id="audio-player-${msg.id}" class="audio-player" controls></audio>
                            </div>
                        </div>
                    ` : `
                        <div class="audio-player-container">
                            <audio id="audio-player-${msg.id}" class="audio-player" controls src="${msg.content}"></audio>
                        </div>
                    `}
                    ${msg.metadata.waveform ? `
                        <div class="waveform-container" id="waveform-${msg.id}">
                            Waveform visualization (${msg.metadata.waveform.split(' ').length} points)
                        </div>
                    ` : ''}
                </div>
            `;
        }
        
        // Render voice messages (legacy - kept for compatibility)
        function renderVoiceMessages(messages) {
            const container = document.getElementById('voice-messages-container');
            
            if (messages.length === 0) {
                container.innerHTML = `
                    <div class="empty-state">
                        <div class="empty-state-icon">üé§</div>
                        <p>No voice messages found</p>
                    </div>
                `;
                return;
            }
            
            container.innerHTML = messages.map(msg => {
                const date = new Date(msg.created_at * 1000);
                const dateStr = date.toLocaleString();
                const senderName = msg.senderProfile?.name || msg.senderProfile?.display_name || msg.pubkey.substring(0, 8) + '...';
                const senderPicture = msg.senderProfile?.picture || '';
                
                return `
                    <div class="voice-message-card ${msg.isEncrypted ? 'encrypted' : ''}" data-event-id="${msg.id}">
                        <div class="voice-message-header">
                            <div class="voice-message-info">
                                <div class="voice-message-title">
                                    ${msg.metadata.title || 'Voice Message'}
                                    ${msg.isEncrypted ? '<span class="encryption-badge">üîê Encrypted</span>' : ''}
                                    ${msg.isExpired ? '<span class="encryption-badge" style="background: rgba(239, 68, 68, 0.2); border-color: #ef4444; color: #fca5a5;">‚è∞ Expired (NIP-40)</span>' : ''}
                                    ${msg.expirationTimestamp && !msg.isExpired ? `<span class="encryption-badge" style="background: rgba(59, 130, 246, 0.2); border-color: #3b82f6; color: #93c5fd;">‚è∞ Expires: ${new Date(msg.expirationTimestamp * 1000).toLocaleString()} (NIP-40)</span>` : ''}
                                </div>
                                <div class="voice-message-meta">
                                    <span>üë§ ${senderName}</span>
                                    <span>üìÖ ${dateStr}</span>
                                    ${msg.metadata.duration ? `<span>‚è±Ô∏è ${Math.round(msg.metadata.duration)}s</span>` : ''}
                                </div>
                            </div>
                            <div class="voice-message-actions">
                                ${msg.isEncrypted ? `
                                    <button class="decrypt-button" onclick="decryptAndPlayMessage('${msg.id}', this)">
                                        üîì Decrypt & Play
                                    </button>
                                ` : `
                                    <button class="btn btn-primary btn-sm" onclick="playMessage('${msg.id}')">
                                        ‚ñ∂Ô∏è Play
                                    </button>
                                `}
                            </div>
                        </div>
                        ${msg.metadata.description ? `<p class="text-secondary small mb-2">${msg.metadata.description}</p>` : ''}
                        ${msg.isEncrypted ? `
                            <div id="decrypt-status-${msg.id}" class="d-none"></div>
                            <div id="audio-container-${msg.id}" class="d-none">
                                <div class="audio-player-container">
                                    <audio id="audio-player-${msg.id}" class="audio-player" controls></audio>
                                </div>
                            </div>
                        ` : `
                            <div class="audio-player-container">
                                <audio id="audio-player-${msg.id}" class="audio-player" controls src="${msg.content}"></audio>
                            </div>
                        `}
                        ${msg.metadata.waveform ? `
                            <div class="waveform-container" id="waveform-${msg.id}">
                                Waveform visualization (${msg.metadata.waveform.split(' ').length} points)
                            </div>
                        ` : ''}
                    </div>
                `;
            }).join('');
        }
        
        // Play public message
        function playMessage(messageId) {
            const audioPlayer = document.getElementById(`audio-player-${messageId}`);
            if (audioPlayer) {
                audioPlayer.play();
            }
        }
        
        // Decrypt and play encrypted message
        async function decryptAndPlayMessage(messageId, buttonElement) {
            const message = voiceMessagesCache.find(msg => msg.id === messageId);
            if (!message || !message.isEncrypted) {
                console.error('Message not found or not encrypted');
                return;
            }
            
            const decryptBtn = buttonElement || document.querySelector(`[data-event-id="${messageId}"] .decrypt-button`);
            const statusDiv = document.getElementById(`decrypt-status-${messageId}`);
            const audioContainer = document.getElementById(`audio-container-${messageId}`);
            
            try {
                decryptBtn.disabled = true;
                decryptBtn.textContent = 'üîì Decrypting...';
                statusDiv.classList.remove('d-none');
                statusDiv.innerHTML = '<div class="loading-spinner"></div> Decrypting message...';
                
                // Helper function to decrypt using NostrTools (preferred - more reliable)
                async function decryptWithNostrTools(method, senderPubkey, ciphertext) {
                    if (typeof NostrTools === 'undefined') {
                        throw new Error('NostrTools library not loaded');
                    }
                    
                    // Check if we have private key (required for NostrTools decryption)
                    let privkey = userPrivateKey || window.userPrivateKey;
                    if (!privkey) {
                        throw new Error('Private key not available for decryption');
                    }
                    
                    // Convert nsec to hex if needed
                    if (typeof privkey === 'string' && privkey.startsWith('nsec1')) {
                        if (typeof NostrTools.nip19 !== 'undefined' && NostrTools.nip19.decode) {
                            const decoded = NostrTools.nip19.decode(privkey);
                            if (decoded.type === 'nsec') {
                                // decoded.data is Uint8Array, convert to hex
                                privkey = Array.from(decoded.data)
                                    .map(b => b.toString(16).padStart(2, '0'))
                                    .join('');
                            }
                        } else {
                            throw new Error('Cannot decode nsec - NostrTools.nip19 not available');
                        }
                    }
                    
                    // Ensure privkey is hex string (not Uint8Array)
                    if (privkey instanceof Uint8Array) {
                        privkey = Array.from(privkey)
                            .map(b => b.toString(16).padStart(2, '0'))
                            .join('');
                    }
                    
                    // Convert sender npub to hex if needed
                    let senderHex = senderPubkey;
                    if (senderPubkey.startsWith('npub1')) {
                        if (typeof NostrTools.nip19 !== 'undefined' && NostrTools.nip19.decode) {
                            const decoded = NostrTools.nip19.decode(senderPubkey);
                            if (decoded.type === 'npub') {
                                // decoded.data is Uint8Array, convert to hex
                                senderHex = Array.from(decoded.data)
                                    .map(b => b.toString(16).padStart(2, '0'))
                                    .join('');
                            }
                        } else {
                            throw new Error('Cannot decode npub - NostrTools.nip19 not available');
                        }
                    }
                    
                    // Ensure senderHex is hex string (not Uint8Array)
                    if (senderHex instanceof Uint8Array) {
                        senderHex = Array.from(senderHex)
                            .map(b => b.toString(16).padStart(2, '0'))
                            .join('');
                    }
                    
                    if (method === 'nip44') {
                        // NIP-44: Get conversation key first, then decrypt
                        if (!NostrTools.nip44 || !NostrTools.nip44.v2) {
                            throw new Error('NostrTools.nip44.v2 not available');
                        }
                        const conversationKey = NostrTools.nip44.v2.getConversationKey(privkey, senderHex);
                        return NostrTools.nip44.decrypt(conversationKey, ciphertext);
                    } else if (method === 'nip04') {
                        // NIP-04: Direct decryption
                        if (!NostrTools.nip04) {
                            throw new Error('NostrTools.nip04 not available');
                        }
                        return await NostrTools.nip04.decrypt(privkey, senderHex, ciphertext);
                    } else {
                        throw new Error(`Unknown encryption method: ${method}`);
                    }
                }
                
                // Decrypt content - prefer NostrTools (more reliable) over extension
                let decryptedContent = null;
                let decryptionSuccess = false;
                
                // Strategy 1: Try NostrTools first (if we have private key)
                try {
                    const privkey = userPrivateKey || window.userPrivateKey;
                    if (privkey && typeof NostrTools !== 'undefined') {
                        decryptedContent = await decryptWithNostrTools(message.encryptionMethod, message.pubkey, message.content);
                        console.log(`‚úÖ Content decrypted with ${message.encryptionMethod.toUpperCase()} using NostrTools`);
                        decryptionSuccess = true;
                    }
                } catch (nostrToolsError) {
                    console.warn('‚ö†Ô∏è NostrTools decryption failed:', nostrToolsError.message);
                    // Fall through to try extension
                }
                
                // Strategy 2: Try extension if NostrTools failed or no private key
                if (!decryptionSuccess) {
                    if (typeof window.nostr === 'undefined' || !window.nostr) {
                        throw new Error('NOSTR extension not available and private key not available for NostrTools decryption');
                    }
                    
                    if (message.encryptionMethod === 'nip44' && window.nostr.nip44 && typeof window.nostr.nip44.decrypt === 'function') {
                        decryptedContent = await window.nostr.nip44.decrypt(message.pubkey, message.content);
                        console.log('‚úÖ Content decrypted with NIP-44 using extension');
                        decryptionSuccess = true;
                    } else if (message.encryptionMethod === 'nip04' && window.nostr.nip04 && typeof window.nostr.nip04.decrypt === 'function') {
                        decryptedContent = await window.nostr.nip04.decrypt(message.pubkey, message.content);
                        console.log('‚úÖ Content decrypted with NIP-04 using extension');
                        decryptionSuccess = true;
                    }
                }
                
                if (!decryptionSuccess) {
                    const privkey = userPrivateKey || window.userPrivateKey;
                    let errorMsg = `Decryption method ${message.encryptionMethod} is not available. `;
                    
                    if (!privkey && typeof NostrTools !== 'undefined') {
                        errorMsg += 'Private key not available for NostrTools decryption. ';
                    }
                    
                    errorMsg += 'Please ensure your NOSTR extension supports decryption, or provide your private key for NostrTools decryption.';
                    
                    throw new Error(errorMsg);
                }
                
                // Parse decrypted JSON
                const decryptedData = JSON.parse(decryptedContent);
                
                console.log('‚úÖ Decrypted voice message:', decryptedData);
                
                // Update message in cache with decrypted metadata
                const messageIndex = voiceMessagesCache.findIndex(msg => msg.id === messageId);
                if (messageIndex !== -1) {
                    voiceMessagesCache[messageIndex].decryptedMetadata = decryptedData;
                    if (decryptedData.title) {
                        voiceMessagesCache[messageIndex].metadata.title = decryptedData.title;
                    }
                    if (decryptedData.description) {
                        voiceMessagesCache[messageIndex].metadata.description = decryptedData.description;
                    }
                    if (decryptedData.duration) {
                        voiceMessagesCache[messageIndex].metadata.duration = decryptedData.duration;
                    }
                    if (decryptedData.waveform) {
                        voiceMessagesCache[messageIndex].metadata.waveform = decryptedData.waveform;
                    }
                }
                
                // Show audio player with decrypted URL
                audioContainer.classList.remove('d-none');
                const audioPlayer = document.getElementById(`audio-player-${messageId}`);
                if (audioPlayer && decryptedData.url) {
                    audioPlayer.src = decryptedData.url;
                    audioPlayer.play();
                } else {
                    throw new Error('No audio URL found in decrypted data');
                }
                
                // Update status
                statusDiv.innerHTML = '<span class="text-success">‚úÖ Decrypted successfully</span>';
                decryptBtn.textContent = '‚úÖ Decrypted';
                
                // Update UI with decrypted metadata
                const cardEl = document.querySelector(`[data-event-id="${messageId}"]`);
                if (cardEl) {
                    // Update title
                    const titleEl = cardEl.querySelector('.voice-message-title');
                    if (titleEl && decryptedData.title) {
                        titleEl.innerHTML = `${decryptedData.title} <span class="encryption-badge">üîê Decrypted</span>`;
                    }
                    
                    // Update description if present
                    if (decryptedData.description) {
                        let descEl = cardEl.querySelector('.voice-message-description');
                        if (!descEl) {
                            descEl = document.createElement('p');
                            descEl.className = 'text-secondary small mb-2 voice-message-description';
                            const headerEl = cardEl.querySelector('.voice-message-header');
                            if (headerEl && headerEl.nextSibling) {
                                headerEl.parentNode.insertBefore(descEl, headerEl.nextSibling);
                            } else {
                                headerEl.parentNode.appendChild(descEl);
                            }
                        }
                        descEl.textContent = decryptedData.description;
                    }
                    
                    // Update duration if present
                    if (decryptedData.duration) {
                        const metaEl = cardEl.querySelector('.voice-message-meta');
                        if (metaEl) {
                            const durationSpan = metaEl.querySelector('span:contains("‚è±Ô∏è")');
                            if (!durationSpan || !metaEl.textContent.includes('‚è±Ô∏è')) {
                                const durationSpan = document.createElement('span');
                                durationSpan.innerHTML = `‚è±Ô∏è ${Math.round(decryptedData.duration)}s`;
                                metaEl.appendChild(durationSpan);
                            }
                        }
                    }
                }
                
            } catch (error) {
                console.error('‚ùå Decryption error:', error);
                statusDiv.innerHTML = `<div class="error-message">Decryption failed: ${error.message}</div>`;
                decryptBtn.disabled = false;
                decryptBtn.textContent = 'üîì Retry Decrypt';
            }
        }
        
        // Convert npub to hex (helper function)
        function npubToHex(npub) {
            try {
                if (typeof NostrTools !== 'undefined' && NostrTools.nip19) {
                    const decoded = NostrTools.nip19.decode(npub);
                    if (decoded.type === 'npub') {
                        // decoded.data is Uint8Array, convert to hex string
                        if (decoded.data instanceof Uint8Array) {
                            return Array.from(decoded.data)
                                .map(b => b.toString(16).padStart(2, '0'))
                                .join('');
                        } else if (typeof decoded.data === 'string') {
                            return decoded.data;
                        }
                    }
                }
                return null;
            } catch (e) {
                console.warn('‚ö†Ô∏è Error converting npub to hex:', e);
                return null;
            }
        }
        
        // Toggle replies visibility
        function toggleReplies(messageId) {
            const repliesContainer = document.getElementById(`replies-${messageId}`);
            const toggleBtn = document.getElementById(`reply-toggle-${messageId}`);
            
            if (repliesContainer) {
                const isCollapsed = repliesContainer.classList.contains('collapsed');
                if (isCollapsed) {
                    repliesContainer.classList.remove('collapsed');
                    if (toggleBtn) {
                        toggleBtn.innerHTML = toggleBtn.innerHTML.replace('‚ñ∂Ô∏è', '‚ñº');
                    }
                } else {
                    repliesContainer.classList.add('collapsed');
                    if (toggleBtn) {
                        toggleBtn.innerHTML = toggleBtn.innerHTML.replace('‚ñº', '‚ñ∂Ô∏è');
                    }
                }
            }
        }
        
        // Make toggleReplies available globally
        window.toggleReplies = toggleReplies;
        
        // Reply recording variables
        let replyMediaRecorder = null;
        let replyRecordedChunks = [];
        let replyCurrentStream = null;
        let replyTargetMessageId = null;
        let replyTargetMessage = null;
        let replyTimerInterval = null;
        
        // Open reply modal
        function openReplyModal(messageId) {
            if (!userPubkey || !isNostrConnected) {
                alert('Please connect to NOSTR first to reply.');
                return;
            }
            
            const message = voiceMessagesCache.find(msg => msg.id === messageId);
            if (!message) {
                console.error('Message not found:', messageId);
                return;
            }
            
            replyTargetMessageId = messageId;
            replyTargetMessage = message;
            
            // Show preview of message being replied to
            const previewDiv = document.getElementById('reply-to-preview');
            const senderName = message.senderProfile?.name || message.senderProfile?.display_name || message.pubkey.substring(0, 8) + '...';
            const date = new Date(message.created_at * 1000).toLocaleString();
            previewDiv.innerHTML = `
                <div class="d-flex align-items-start gap-2">
                    <div class="flex-grow-1">
                        <div class="fw-semibold text-white">${message.metadata.title || 'Voice Message'}</div>
                        <div class="text-secondary small">üë§ ${senderName} ‚Ä¢ üìÖ ${date}</div>
                        ${message.metadata.description ? `<div class="text-secondary small mt-1">${message.metadata.description}</div>` : ''}
                    </div>
                </div>
            `;
            
            // Reset modal state
            document.getElementById('reply-recording-status').classList.add('d-none');
            document.getElementById('reply-recording-controls').classList.add('d-none');
            document.getElementById('reply-preview-section').classList.add('d-none');
            document.getElementById('reply-publish-btn').disabled = true;
            document.getElementById('reply-title').value = '';
            document.getElementById('reply-description').value = '';
            document.getElementById('reply-audio-upload').value = '';
            
            // Show recording controls
            document.getElementById('reply-recording-controls').classList.remove('d-none');
            
            // Show modal
            const modal = new bootstrap.Modal(document.getElementById('reply-modal'));
            modal.show();
        }
        
        // Make openReplyModal available globally
        window.openReplyModal = openReplyModal;
        
        // Attach thread event listeners
        function attachThreadEventListeners() {
            // Reply recording button
            const replyStartBtn = document.getElementById('reply-start-recording');
            const replyStopBtn = document.getElementById('reply-stop-recording');
            const replyUploadInput = document.getElementById('reply-audio-upload');
            const replyPublishBtn = document.getElementById('reply-publish-btn');
            
            if (replyStartBtn) {
                replyStartBtn.addEventListener('click', startReplyRecording);
            }
            
            if (replyStopBtn) {
                replyStopBtn.addEventListener('click', stopReplyRecording);
            }
            
            if (replyUploadInput) {
                replyUploadInput.addEventListener('change', handleReplyAudioUpload);
            }
            
            if (replyPublishBtn) {
                replyPublishBtn.addEventListener('click', publishReply);
            }
        }
        
        // Start reply recording
        async function startReplyRecording() {
            try {
                const startBtn = document.getElementById('reply-start-recording');
                const stopBtn = document.getElementById('reply-stop-recording');
                const timerDisplay = document.getElementById('reply-timer');
                const statusDiv = document.getElementById('reply-recording-status');
                const statusText = document.getElementById('reply-status-text');
                
                // Stop any existing stream
                if (replyCurrentStream) {
                    replyCurrentStream.getTracks().forEach(track => track.stop());
                    replyCurrentStream = null;
                }
                
                statusDiv.classList.remove('d-none');
                statusText.textContent = 'Requesting microphone access...';
                
                // Request microphone access
                const stream = await navigator.mediaDevices.getUserMedia({ 
                    audio: {
                        echoCancellation: true,
                        noiseSuppression: true,
                        autoGainControl: true,
                        sampleRate: 44100
                    },
                    video: false
                });
                
                replyCurrentStream = stream;
                
                // Determine best audio MIME type
                let mimeType = 'audio/webm';
                const supportedTypes = [
                    'audio/webm;codecs=opus',
                    'audio/webm',
                    'audio/mp4',
                    'audio/ogg;codecs=opus',
                    'audio/ogg'
                ];
                
                for (const type of supportedTypes) {
                    if (MediaRecorder.isTypeSupported(type)) {
                        mimeType = type;
                        break;
                    }
                }
                
                replyMediaRecorder = new MediaRecorder(stream, { mimeType: mimeType });
                replyRecordedChunks = [];
                
                replyMediaRecorder.ondataavailable = (event) => {
                    if (event.data.size > 0) {
                        replyRecordedChunks.push(event.data);
                    }
                };
                
                replyMediaRecorder.onstop = () => {
                    const blob = new Blob(replyRecordedChunks, { type: mimeType });
                    showReplyPreview(blob);
                    if (replyCurrentStream) {
                        replyCurrentStream.getTracks().forEach(track => track.stop());
                        replyCurrentStream = null;
                    }
                };
                
                replyMediaRecorder.start();
                
                // Start timer (30 seconds max)
                let timer = 30;
                timerDisplay.textContent = timer;
                replyTimerInterval = setInterval(() => {
                    timer--;
                    timerDisplay.textContent = timer;
                    if (timer <= 0) {
                        stopReplyRecording();
                    }
                }, 1000);
                
                // Update UI
                startBtn.classList.add('d-none');
                stopBtn.classList.remove('d-none');
                statusDiv.classList.add('d-none');
                timerDisplay.classList.remove('d-none');
                
            } catch (error) {
                console.error('‚ùå Error starting reply recording:', error);
                alert(`Could not access microphone: ${error.message}`);
            }
        }
        
        // Stop reply recording
        function stopReplyRecording() {
            if (replyMediaRecorder && replyMediaRecorder.state === 'recording') {
                replyMediaRecorder.stop();
            }
            
            if (replyTimerInterval) {
                clearInterval(replyTimerInterval);
                replyTimerInterval = null;
            }
            
            const startBtn = document.getElementById('reply-start-recording');
            const stopBtn = document.getElementById('reply-stop-recording');
            const timerDisplay = document.getElementById('reply-timer');
            
            if (startBtn) startBtn.classList.remove('d-none');
            if (stopBtn) stopBtn.classList.add('d-none');
            if (timerDisplay) timerDisplay.classList.add('d-none');
        }
        
        // Handle reply audio upload
        function handleReplyAudioUpload(event) {
            const file = event.target.files[0];
            if (!file) return;
            
            // Validate file type
            const validTypes = ['audio/mpeg', 'audio/mp3', 'audio/wav', 'audio/ogg', 'audio/flac', 'audio/aac', 'audio/mp4', 'audio/x-m4a'];
            const validExtensions = ['.mp3', '.wav', '.ogg', '.flac', '.aac', '.m4a'];
            const fileExtension = '.' + file.name.split('.').pop().toLowerCase();
            
            if (!validTypes.includes(file.type) && !validExtensions.includes(fileExtension)) {
                alert('Invalid file type. Please upload an audio file.');
                return;
            }
            
            // Validate file size (max 500MB)
            const maxSize = 500 * 1024 * 1024;
            if (file.size > maxSize) {
                alert('File is too large. Maximum allowed size is 500MB.');
                return;
            }
            
            const audioBlob = new Blob([file], { type: file.type });
            showReplyPreview(audioBlob, file.name);
            
            // Reset file input
            event.target.value = '';
        }
        
        // Show reply preview
        function showReplyPreview(audioBlob, filename = null) {
            const previewSection = document.getElementById('reply-preview-section');
            const audioPreview = document.getElementById('reply-audio-preview');
            const publishBtn = document.getElementById('reply-publish-btn');
            
            const audioUrl = URL.createObjectURL(audioBlob);
            audioPreview.src = audioUrl;
            
            // Auto-fill title if filename provided
            if (filename) {
                const filenameWithoutExt = filename.replace(/\.[^/.]+$/, '');
                document.getElementById('reply-title').value = `Re: ${filenameWithoutExt}`;
            }
            
            previewSection.classList.remove('d-none');
            publishBtn.disabled = false;
            
            // Store blob for publishing
            audioPreview.dataset.blob = 'stored'; // Marker
            audioPreview.dataset.audioBlob = audioBlob; // Will be stored in closure
            window.replyAudioBlob = audioBlob; // Store globally for publish
        }
        
        // Publish reply
        async function publishReply() {
            if (!replyTargetMessageId || !window.replyAudioBlob) {
                alert('No audio recorded or uploaded. Please record or upload an audio file first.');
                return;
            }
            
            const publishBtn = document.getElementById('reply-publish-btn');
            const title = document.getElementById('reply-title').value || '';
            const description = document.getElementById('reply-description').value || '';
            
            try {
                publishBtn.disabled = true;
                publishBtn.innerHTML = '<span class="spinner-border spinner-border-sm me-2"></span>Publishing...';
                
                // Step 1: Upload audio to IPFS
                const audioFile = new File([window.replyAudioBlob], `reply_${Date.now()}.webm`, { 
                    type: window.replyAudioBlob.type || 'audio/webm' 
                });
                
                const uploadFormData = new FormData();
                uploadFormData.append('file', audioFile);
                uploadFormData.append('npub', userPubkey);
                
                console.log('üì§ Uploading reply audio to IPFS...');
                const uploadResponse = await fetch('/api/fileupload', {
                    method: 'POST',
                    body: uploadFormData
                });
                
                if (!uploadResponse.ok) {
                    throw new Error(`Upload failed: ${uploadResponse.statusText}`);
                }
                
                const uploadResult = await uploadResponse.json();
                
                if (!uploadResult.success || !uploadResult.new_cid) {
                    throw new Error(uploadResult.message || 'IPFS upload failed');
                }
                
                console.log('‚úÖ Reply audio uploaded to IPFS:', uploadResult.new_cid);
                
                // Step 2: Get user email for player field
                let playerValue = '';
                try {
                    if (typeof fetchUserEmailWithFallback === 'function') {
                        playerValue = await fetchUserEmailWithFallback(userPubkey);
                    } else if (typeof window !== 'undefined' && typeof window.fetchUserEmailWithFallback === 'function') {
                        playerValue = await window.fetchUserEmailWithFallback(userPubkey);
                    }
                    
                    if (!playerValue || !playerValue.includes('@')) {
                        playerValue = '';
                    }
                } catch (e) {
                    console.warn('‚ö†Ô∏è Could not fetch email, backend will resolve from directory');
                }
                
                // Step 3: Prepare form data for reply (kind 1244)
                const formData = new FormData();
                formData.append('player', playerValue);
                formData.append('ipfs_cid', uploadResult.new_cid);
                formData.append('title', title || 'Voice Reply');
                formData.append('description', description);
                formData.append('npub', userPubkey);
                formData.append('file_hash', uploadResult.fileHash || '');
                formData.append('duration', (uploadResult.duration || 0).toString());
                formData.append('mime_type', uploadResult.mimeType || 'audio/webm');
                
                // Reply-specific: kind 1244 and parent event reference
                formData.append('kind', '1244'); // Reply kind
                formData.append('reply_to_event_id', replyTargetMessageId);
                formData.append('reply_to_pubkey', replyTargetMessage.pubkey);
                
                if (uploadResult.info) {
                    formData.append('info_cid', uploadResult.info);
                }
                
                formData.append('publish_nostr', 'true');
                
                // Step 4: Publish reply
                console.log('üì° Publishing reply to NOSTR...');
                const response = await fetch('/vocals', {
                    method: 'POST',
                    body: formData
                });
                
                if (!response.ok) {
                    const errorText = await response.text().catch(() => '');
                    throw new Error(`Publication failed: ${response.statusText}${errorText ? ' - ' + errorText : ''}`);
                }
                
                // Success
                publishBtn.innerHTML = '‚úÖ Published!';
                publishBtn.classList.remove('btn-primary');
                publishBtn.classList.add('btn-success');
                
                // Close modal after short delay
                setTimeout(() => {
                    const modal = bootstrap.Modal.getInstance(document.getElementById('reply-modal'));
                    if (modal) {
                        modal.hide();
                    }
                    
                    // Reload messages to show new reply
                    loadVoiceMessages();
                }, 1500);
                
            } catch (error) {
                console.error('‚ùå Error publishing reply:', error);
                alert(`Failed to publish reply: ${error.message}`);
                publishBtn.disabled = false;
                publishBtn.innerHTML = 'üì° Publish Reply';
            }
        }
        
        // Initialize on page load
        document.addEventListener('DOMContentLoaded', function() {
            console.log('üöÄ Initializing voice messages reader...');
            
            // Attach reply modal event listeners
            attachThreadEventListeners();
            
            // Check if already connected (from parent window if in iframe)
            const isInIframe = window.self !== window.top;
            if (isInIframe && window.parent && window.parent.userPubkey) {
                userPubkey = window.parent.userPubkey;
                if (window.parent.nostrPool) {
                    nostrPool = window.parent.nostrPool;
                } else if (typeof NostrTools !== 'undefined' && NostrTools.SimplePool) {
                    nostrPool = new NostrTools.SimplePool();
                }
                isNostrConnected = true;
                
                const connectBtn = document.getElementById('connect-btn');
                connectBtn.textContent = '‚úÖ Connected';
                connectBtn.disabled = true;
                connectBtn.classList.remove('btn-primary');
                connectBtn.classList.add('btn-secondary');
                
                loadVoiceMessages();
            }
        });
    </script>
</body>
</html>

