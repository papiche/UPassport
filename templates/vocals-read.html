<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, user-scalable=yes, viewport-fit=cover">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <title>üéß Voice Messages Reader - Decrypt & Play</title>
    
    <!-- Bootstrap 5 CSS -->
    <link href="{{ myIPFS }}/ipns/copylaradio.com/bootstrap.min.css" rel="stylesheet">
    <!-- Bootstrap Icons -->
    <link rel="stylesheet" href="{{ myIPFS }}/ipns/copylaradio.com/fonts/bootstrap-icons.css">
    <!-- Bootstrap 5 JS Bundle -->
    <script src="{{ myIPFS }}/ipns/copylaradio.com/bootstrap.bundle.min.js"></script>
    
    <!-- Nostr integration -->
    <script src="{{ myIPFS }}/ipns/copylaradio.com/nostr.bundle.js"></script>

    <!-- Common.js with enhanced UPlanet NOSTR functions -->
    <script src="{{ myIPFS }}/ipns/copylaradio.com/common.js"></script>
    
    <!-- p5.js for waveform visualization (optional, loaded dynamically) -->
    <script src="{{ myIPFS }}/ipns/copylaradio.com/p5.min.js"></script>
        
    <style>
        * {
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Roboto', 'Arial', sans-serif;
            background: #0f0f0f;
            color: #ffffff;
            min-height: 100vh;
            margin: 0;
            padding: 0;
            overflow-x: hidden;
        }
        
        /* Header with Bootstrap navbar */
        .header {
            background: #212121;
            backdrop-filter: blur(10px);
            border-bottom: 1px solid #3f3f3f;
        }
        
        .navbar-brand {
            color: #ffffff !important;
            font-size: 1.3em;
            font-weight: 400;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .navbar-toggler {
            border-color: rgba(255, 255, 255, 0.3);
        }
        
        .navbar-toggler-icon {
            background-image: url("data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 30 30'%3e%3cpath stroke='rgba%28255, 255, 255, 0.85%29' stroke-linecap='round' stroke-miterlimit='10' stroke-width='2' d='M4 7h22M4 15h22M4 23h22'/%3e%3c/svg%3e");
        }
        
        .main-container {
            max-width: 100%;
            margin: 0;
            padding: 0;
        }
        
        /* Sidebar for filters (collapsible) */
        .sidebar {
            background: #181818;
            border-right: 1px solid #3f3f3f;
            min-height: calc(100vh - 56px);
            padding: 1rem;
            transition: all 0.3s ease;
        }
        
        .sidebar.collapsed {
            width: 0;
            padding: 0;
            overflow: hidden;
        }
        
        /* Content area */
        .content-area {
            padding: 1rem;
            transition: all 0.3s ease;
        }
        
        /* View mode toggle buttons */
        .view-mode-toggle {
            display: flex;
            gap: 0.5rem;
            margin-bottom: 1rem;
        }
        
        /* List view - compact cards */
        .list-view .voice-message-card {
            padding: 0.5rem;
            margin-bottom: 0.25rem;
            border-radius: 6px;
        }
        
        .list-view .voice-message-header {
            margin-bottom: 0.25rem;
            flex-wrap: nowrap;
        }
        
        .list-view .voice-message-info {
            flex: 1;
            min-width: 0;
            overflow: hidden;
        }
        
        .list-view .voice-message-title {
            font-size: 0.9em;
            margin-bottom: 0.125rem;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        
        .list-view .voice-message-title .badge {
            font-size: 0.65em;
            padding: 0.125rem 0.375rem;
            margin-left: 0.25rem;
        }
        
        .list-view .voice-message-meta {
            font-size: 0.7em;
            gap: 0.5rem;
            flex-wrap: wrap;
        }
        
        .list-view .voice-message-meta span {
            white-space: nowrap;
        }
        
        .list-view .voice-message-actions {
            gap: 0.25rem;
            flex-shrink: 0;
        }
        
        .list-view .voice-message-actions .btn {
            padding: 0.25rem 0.5rem;
            font-size: 0.75rem;
        }
        
        .list-view .voice-message-actions .btn i {
            font-size: 0.875rem;
        }
        
        .list-view .voice-message-actions .btn .d-none {
            display: none !important;
        }
        
        .list-view .audio-player-container {
            margin: 0.25rem 0;
            padding: 0.25rem;
        }
        
        .list-view .audio-player {
            height: 40px;
        }
        
        .list-view .waveform-container {
            height: 30px;
            margin: 0.25rem 0;
        }
        
        .list-view .voice-message-card p {
            font-size: 0.75em;
            margin-bottom: 0.25rem;
            display: -webkit-box;
            -webkit-line-clamp: 1;
            line-clamp: 1;
            -webkit-box-orient: vertical;
            overflow: hidden;
        }
        
        .list-view .badge {
            font-size: 0.7em;
            padding: 0.125rem 0.375rem;
        }
        
        .list-view .form-check {
            margin-bottom: 0;
        }
        
        .list-view .form-check-label {
            font-size: 0.7em;
        }
        
        .list-view .form-switch .form-check-input {
            width: 1.5em;
            height: 0.75em;
        }
        
        .list-view .btn-sm {
            padding: 0.125rem 0.375rem;
            font-size: 0.7rem;
        }
        
        /* Detail view - full cards */
        .detail-view .voice-message-card {
            padding: 1.5rem;
            margin-bottom: 1rem;
        }
        
        /* Nav pills dark theme */
        .nav-pills .nav-link {
            color: #94a3b8;
            border-radius: 0.375rem;
            margin-bottom: 0.25rem;
        }
        
        .nav-pills .nav-link:hover {
            background-color: rgba(255, 255, 255, 0.1);
            color: #ffffff;
        }
        
        .nav-pills .nav-link.active {
            background-color: #065fd4;
            color: #ffffff;
        }
        
        /* Mobile optimizations */
        @media (max-width: 991.98px) {
            .sidebar {
                position: fixed;
                top: 56px;
                left: 0;
                width: 280px;
                height: calc(100vh - 56px);
                z-index: 1040;
                transform: translateX(-100%);
                transition: transform 0.3s ease;
                overflow-y: auto;
            }
            
            .sidebar.show {
                transform: translateX(0);
            }
            
            .sidebar-overlay {
                display: none;
                position: fixed;
                top: 56px;
                left: 0;
                right: 0;
                bottom: 0;
                background: rgba(0, 0, 0, 0.5);
                z-index: 1039;
            }
            
            .sidebar-overlay.show {
                display: block;
            }
        }
        
        /* Responsive adjustments */
        @media (max-width: 575.98px) {
            .voice-message-actions {
                flex-direction: column;
                width: 100%;
            }
            
            .voice-message-actions .btn {
                width: 100%;
                margin-bottom: 0.25rem;
            }
        }
        
        .voice-message-card {
            background: #181818;
            border: 1px solid #3f3f3f;
            border-radius: 12px;
            padding: 1.5rem;
            margin-bottom: 1rem;
            transition: all 0.3s ease;
        }
        
        .voice-message-card:hover {
            border-color: #065fd4;
            box-shadow: 0 4px 12px rgba(6, 95, 212, 0.2);
        }
        
        .voice-message-card.encrypted {
            border-color: #f59e0b;
            background: rgba(245, 158, 11, 0.05);
        }
        
        /* Threading styles */
        .thread-container {
            margin-bottom: 1.5rem;
        }
        
        .thread-root {
            border-left: 3px solid #065fd4;
        }
        
        .thread-reply {
            margin-left: 2rem;
            margin-top: 0.75rem;
            border-left: 2px solid #3f3f3f;
            padding-left: 1rem;
            background: rgba(63, 63, 63, 0.2);
            border-radius: 8px;
        }
        
        .thread-reply-nested {
            margin-left: 2rem;
        }
        
        .reply-count {
            display: inline-flex;
            align-items: center;
            gap: 4px;
            padding: 4px 8px;
            background: rgba(6, 95, 212, 0.1);
            border: 1px solid rgba(6, 95, 212, 0.3);
            border-radius: 12px;
            font-size: 0.75em;
            color: #60a5fa;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        
        .reply-count:hover {
            background: rgba(6, 95, 212, 0.2);
            border-color: #065fd4;
        }
        
        .replies-container {
            margin-top: 1rem;
            padding-top: 1rem;
            border-top: 1px solid rgba(63, 63, 63, 0.5);
        }
        
        .replies-container.collapsed {
            display: none;
        }
        
        .thread-line {
            position: absolute;
            left: 0;
            top: 0;
            bottom: 0;
            width: 2px;
            background: #3f3f3f;
        }
        
        .reply-button {
            background: transparent;
            border: 1px solid #3f3f3f;
            color: #94a3b8;
            padding: 0.375rem 0.75rem;
            border-radius: 6px;
            font-size: 0.85em;
            cursor: pointer;
            transition: all 0.2s ease;
            display: inline-flex;
            align-items: center;
            gap: 4px;
        }
        
        .reply-button:hover {
            border-color: #065fd4;
            color: #60a5fa;
            background: rgba(6, 95, 212, 0.1);
        }
        
        .voice-message-header {
            display: flex;
            justify-content: space-between;
            align-items: start;
            margin-bottom: 1rem;
            flex-wrap: wrap;
            gap: 1rem;
        }
        
        .voice-message-info {
            flex: 1;
            min-width: 200px;
        }
        
        .voice-message-title {
            font-size: 1.2em;
            font-weight: 600;
            color: #ffffff;
            margin-bottom: 0.5rem;
        }
        
        .voice-message-meta {
            font-size: 0.85em;
            color: #94a3b8;
            display: flex;
            gap: 1rem;
            flex-wrap: wrap;
        }
        
        .voice-message-actions {
            display: flex;
            gap: 0.5rem;
            flex-wrap: wrap;
        }
        
        .encryption-badge {
            display: inline-flex;
            align-items: center;
            gap: 4px;
            padding: 4px 8px;
            background: rgba(245, 158, 11, 0.2);
            border: 1px solid #f59e0b;
            border-radius: 4px;
            font-size: 0.75em;
            color: #fbbf24;
        }
        
        .audio-player-container {
            margin: 1rem 0;
            padding: 1rem;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
        }
        
        .audio-player {
            width: 100%;
            height: 60px;
        }
        
        .waveform-container {
            height: 80px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 4px;
            margin: 1rem 0;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #94a3b8;
            font-size: 0.85em;
            position: relative;
            overflow: hidden;
        }
        
        .waveform-container canvas {
            width: 100% !important;
            height: 100% !important;
        }
        
        .loading-spinner {
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 3px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            border-top-color: #065fd4;
            animation: spin 1s ease-in-out infinite;
        }
        
        @keyframes spin {
            to { transform: rotate(360deg); }
        }
        
        .error-message {
            color: #ef4444;
            padding: 0.5rem;
            background: rgba(239, 68, 68, 0.1);
            border-radius: 4px;
            margin: 0.5rem 0;
        }
        
        .decrypt-button {
            background: #f59e0b;
            color: #000;
            border: none;
            padding: 0.5rem 1rem;
            border-radius: 6px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        .decrypt-button:hover {
            background: #fbbf24;
            transform: translateY(-1px);
        }
        
        .decrypt-button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        
        .message-stats {
            font-size: 0.85em;
            color: #94a3b8;
        }
        
        .empty-state {
            text-align: center;
            padding: 3rem;
            color: #94a3b8;
        }
        
        .empty-state-icon {
            font-size: 4em;
            margin-bottom: 1rem;
        }
        
        @media (max-width: 767.98px) {
            .main-container {
                padding: 1rem;
            }
            
            .voice-message-card {
                padding: 1rem;
            }
            
            .voice-message-header {
                flex-direction: column;
            }
        }
    </style>
</head>
<body class="bg-dark text-white">
    <!-- Header with Bootstrap Navbar -->
    <nav class="navbar navbar-expand-lg navbar-dark bg-dark border-bottom border-secondary sticky-top">
        <div class="container-fluid">
            <button class="navbar-toggler d-lg-none" type="button" onclick="toggleSidebar()" aria-label="Toggle filters">
                <span class="navbar-toggler-icon"></span>
            </button>
            
            <a class="navbar-brand" href="#">
                <i class="bi bi-headphones"></i> Voice Messages
            </a>
            
            <div class="d-flex align-items-center gap-2">
                <!-- View Mode Toggle (List/Detail) -->
                <div class="btn-group btn-group-sm d-none d-md-flex" role="group" aria-label="View mode">
                    <input type="radio" class="btn-check" name="view-mode" id="view-list" autocomplete="off" checked>
                    <label class="btn btn-outline-secondary" for="view-list" onclick="setViewMode('list')" title="List view">
                        <i class="bi bi-list-ul"></i>
                    </label>
                    <input type="radio" class="btn-check" name="view-mode" id="view-detail" autocomplete="off">
                    <label class="btn btn-outline-secondary" for="view-detail" onclick="setViewMode('detail')" title="Detail view">
                        <i class="bi bi-card-text"></i>
                    </label>
                </div>
                
                <!-- NOSTR Connection Status -->
                <div class="d-flex align-items-center gap-2" id="nostr-header">
                    <button id="profile-btn" class="btn btn-success btn-sm d-none" onclick="viewProfile()" title="View my profile">
                        <i class="bi bi-person-circle"></i> <span class="d-none d-md-inline">Profile</span>
                    </button>
                    <button id="connect-btn" class="btn btn-primary btn-sm" onclick="handleNostrConnect()">
                        <i class="bi bi-plug"></i> <span class="d-none d-md-inline">Connect</span>
                    </button>
                </div>
                
                <!-- Record Button -->
                <a href="/vocals?html=1" class="btn btn-outline-secondary btn-sm d-flex align-items-center gap-1">
                    <i class="bi bi-mic-fill"></i> <span class="d-none d-md-inline">Record</span>
                </a>
            </div>
        </div>
    </nav>
    
    <!-- Sidebar Overlay for Mobile -->
    <div class="sidebar-overlay" id="sidebarOverlay" onclick="toggleSidebar()"></div>
    
    <!-- Main Container with Sidebar and Content -->
    <div class="container-fluid g-0">
        <div class="row g-0">
            <!-- Sidebar (Filters) - Collapsible -->
            <aside class="col-lg-3 col-xl-2 sidebar" id="sidebar">
                <div class="card bg-dark border-secondary mb-3">
                    <div class="card-header bg-dark border-secondary d-flex justify-content-between align-items-center">
                        <h6 class="mb-0">
                            <i class="bi bi-funnel"></i> Filters & Sort
                        </h6>
                        <button class="btn btn-sm btn-outline-secondary d-lg-none" onclick="toggleSidebar()" title="Close filters">
                            <i class="bi bi-x-lg"></i>
                        </button>
                    </div>
                    <div class="card-body">
                        <!-- View Mode Tabs -->
                        <ul class="nav nav-pills nav-pills-dark flex-column mb-3" id="viewModeTabs" role="tablist">
                            <li class="nav-item" role="presentation">
                                <button class="nav-link active w-100 text-start" id="chronological-tab" data-bs-toggle="tab" data-bs-target="#chronological" type="button" role="tab">
                                    <i class="bi bi-calendar3"></i> Chronological
                                </button>
                            </li>
                            <li class="nav-item" role="presentation">
                                <button class="nav-link w-100 text-start" id="by-author-tab" data-bs-toggle="tab" data-bs-target="#by-author" type="button" role="tab">
                                    <i class="bi bi-people"></i> By Author
                                </button>
                            </li>
                            <li class="nav-item" role="presentation">
                                <button class="nav-link w-100 text-start" id="threads-tab" data-bs-toggle="tab" data-bs-target="#threads" type="button" role="tab">
                                    <i class="bi bi-chat-dots"></i> Threads
                                </button>
                            </li>
                            <li class="nav-item" role="presentation">
                                <button class="nav-link w-100 text-start" id="personal-tab" data-bs-toggle="tab" data-bs-target="#personal" type="button" role="tab">
                                    <i class="bi bi-lock"></i> Personal
                                </button>
                            </li>
                        </ul>
                        
                        <!-- Message Count -->
                        <div class="mb-3">
                            <span id="message-count" class="badge bg-secondary w-100 py-2">
                                <i class="bi bi-envelope"></i> <span id="message-count-text">0 messages</span>
                            </span>
                        </div>
                
                        <!-- Tab Content -->
                        <div class="tab-content" id="viewModeTabContent">
                            <!-- Chronological View -->
                            <div class="tab-pane fade show active" id="chronological" role="tabpanel">
                                <div class="mb-3">
                                    <label for="filter-type" class="form-label small">
                                        <i class="bi bi-funnel"></i> Type:
                                    </label>
                                    <select id="filter-type" class="form-select form-select-sm bg-dark text-white border-secondary">
                                        <option value="all">All Messages</option>
                                        <option value="public">Public Only</option>
                                        <option value="encrypted">Encrypted Only</option>
                                        <option value="sent">Sent by Me</option>
                                        <option value="received">Received by Me</option>
                                    </select>
                                </div>
                                <div class="mb-3">
                                    <label for="filter-since" class="form-label small">
                                        <i class="bi bi-clock"></i> Since:
                                    </label>
                                    <select id="filter-since" class="form-select form-select-sm bg-dark text-white border-secondary">
                                        <option value="1h">Last Hour</option>
                                        <option value="24h" selected>Last 24 Hours</option>
                                        <option value="7d">Last 7 Days</option>
                                        <option value="30d">Last 30 Days</option>
                                        <option value="all">All Time</option>
                                    </select>
                                </div>
                                <div class="mb-3">
                                    <label for="sort-order" class="form-label small">
                                        <i class="bi bi-sort-down"></i> Sort:
                                    </label>
                                    <select id="sort-order" class="form-select form-select-sm bg-dark text-white border-secondary">
                                        <option value="newest">Newest First</option>
                                        <option value="oldest">Oldest First</option>
                                    </select>
                                </div>
                                <button id="refresh-btn" class="btn btn-primary btn-sm w-100" onclick="loadVoiceMessages()">
                                    <i class="bi bi-arrow-clockwise"></i> Refresh
                                </button>
                            </div>
                            
                            <!-- By Author View -->
                            <div class="tab-pane fade" id="by-author" role="tabpanel">
                                <div class="mb-3">
                                    <label for="filter-author" class="form-label small">
                                        <i class="bi bi-person"></i> Author:
                                    </label>
                                    <select id="filter-author" class="form-select form-select-sm bg-dark text-white border-secondary">
                                        <option value="all">All Authors</option>
                                    </select>
                                </div>
                                <div class="mb-3">
                                    <label for="filter-location" class="form-label small">
                                        <i class="bi bi-geo-alt"></i> Location:
                                    </label>
                                    <select id="filter-location" class="form-select form-select-sm bg-dark text-white border-secondary">
                                        <option value="all">All Locations</option>
                                    </select>
                                </div>
                                <button class="btn btn-primary btn-sm w-100" onclick="applyAuthorFilter()">
                                    <i class="bi bi-funnel-fill"></i> Apply Filter
                                </button>
                            </div>
                            
                            <!-- Threads View -->
                            <div class="tab-pane fade" id="threads" role="tabpanel">
                                <div class="mb-3">
                                    <label for="filter-thread-type" class="form-label small">
                                        <i class="bi bi-chat-dots"></i> Thread Type:
                                    </label>
                                    <select id="filter-thread-type" class="form-select form-select-sm bg-dark text-white border-secondary">
                                        <option value="all">All Threads</option>
                                        <option value="encrypted">Encrypted</option>
                                        <option value="public">Public</option>
                                        <option value="my-threads">My Threads</option>
                                    </select>
                                </div>
                                <div class="mb-3">
                                    <label for="filter-thread-participant" class="form-label small">
                                        <i class="bi bi-people"></i> Participant:
                                    </label>
                                    <select id="filter-thread-participant" class="form-select form-select-sm bg-dark text-white border-secondary">
                                        <option value="all">All Participants</option>
                                    </select>
                                </div>
                                <button class="btn btn-primary btn-sm w-100" onclick="applyThreadFilter()">
                                    <i class="bi bi-funnel-fill"></i> Apply Filter
                                </button>
                            </div>
                            
                            <!-- Personal View -->
                            <div class="tab-pane fade" id="personal" role="tabpanel">
                                <div class="mb-3">
                                    <label for="filter-personal-type" class="form-label small">
                                        <i class="bi bi-lock"></i> Personal:
                                    </label>
                                    <select id="filter-personal-type" class="form-select form-select-sm bg-dark text-white border-secondary">
                                        <option value="self">To Myself</option>
                                        <option value="drafts">Drafts</option>
                                        <option value="saved">Saved</option>
                                    </select>
                                </div>
                                <button class="btn btn-primary btn-sm w-100" onclick="applyPersonalFilter()">
                                    <i class="bi bi-funnel-fill"></i> Apply Filter
                                </button>
                            </div>
                        </div>
                    </div>
                </div>
            </aside>
            
            <!-- Main Content Area -->
            <main class="col-lg-9 col-xl-10 content-area">
                <!-- Pagination and View Toggle (Mobile) -->
                <div class="d-flex justify-content-between align-items-center mb-3 flex-wrap gap-2">
                    <div class="d-flex align-items-center gap-2">
                        <!-- View Mode Toggle (Mobile) -->
                        <div class="btn-group btn-group-sm d-md-none" role="group">
                            <input type="radio" class="btn-check" name="view-mode-mobile" id="view-list-mobile" autocomplete="off" checked>
                            <label class="btn btn-outline-secondary" for="view-list-mobile" onclick="setViewMode('list')" title="List view">
                                <i class="bi bi-list-ul"></i>
                            </label>
                            <input type="radio" class="btn-check" name="view-mode-mobile" id="view-detail-mobile" autocomplete="off">
                            <label class="btn btn-outline-secondary" for="view-detail-mobile" onclick="setViewMode('detail')" title="Detail view">
                                <i class="bi bi-card-text"></i>
                            </label>
                        </div>
                        <span class="text-secondary small">
                            <i class="bi bi-envelope"></i> <span id="showing-count">0</span> / <span id="total-count">0</span>
                        </span>
                    </div>
                    <nav aria-label="Messages pagination">
                        <ul class="pagination pagination-sm mb-0" id="pagination-controls">
                            <!-- Pagination will be generated dynamically -->
                        </ul>
                    </nav>
                </div>
                
                <!-- Voice Messages List -->
                <div id="voice-messages-container" class="detail-view">
                    <div class="empty-state">
                        <div class="empty-state-icon">üé§</div>
                        <p>Connect to NOSTR to load voice messages</p>
                    </div>
                </div>
            </main>
        </div>
    </div>
    
    <!-- Reply Recording Modal -->
    <div class="modal fade" id="reply-modal" tabindex="-1" aria-labelledby="reply-modal-title" aria-hidden="true" data-bs-backdrop="true" data-bs-keyboard="true">
        <div class="modal-dialog modal-dialog-centered modal-lg">
            <div class="modal-content bg-dark border-secondary">
                <div class="modal-header border-secondary">
                    <h5 class="modal-title text-white" id="reply-modal-title">
                        <i class="bi bi-mic-fill"></i> Reply with Voice Message
                    </h5>
                    <button type="button" class="btn-close btn-close-white" data-bs-dismiss="modal" aria-label="Close"></button>
                </div>
                <div class="modal-body">
                    <div class="mb-3">
                        <p class="text-secondary small mb-2">Replying to:</p>
                        <div id="reply-to-preview" class="p-2 bg-dark border border-secondary rounded"></div>
                    </div>
                    
                    <div class="alert alert-info d-none" id="reply-recording-status">
                        <span class="spinner-border spinner-border-sm me-2" role="status"></span>
                        <span id="reply-status-text">Preparing recording...</span>
                    </div>
                    
                    <div id="reply-recording-controls" class="d-none">
                        <div class="text-center mb-3">
                            <div id="reply-timer" class="fs-2 fw-bold text-danger mb-3">30</div>
                            <div class="d-flex gap-2 justify-content-center">
                                <button id="reply-start-recording" class="btn btn-primary">
                                    <i class="bi bi-mic-fill"></i> Start Recording
                                </button>
                                <button id="reply-stop-recording" class="btn btn-danger d-none">
                                    <i class="bi bi-stop-fill"></i> Stop
                                </button>
                            </div>
                        </div>
                        
                        <div class="mb-3">
                            <label class="form-label text-white small">
                                <i class="bi bi-upload"></i> Or upload audio file:
                            </label>
                            <input type="file" class="form-control form-control-sm bg-dark text-white border-secondary" 
                                   id="reply-audio-upload" accept="audio/*,.mp3,.wav,.ogg,.flac,.aac,.m4a">
                        </div>
                    </div>
                    
                    <div id="reply-preview-section" class="d-none">
                        <div class="text-center mb-3">
                            <audio id="reply-audio-preview" class="w-100" controls style="max-height: 60px;"></audio>
                        </div>
                        
                        <div class="mb-3">
                            <label for="reply-title" class="form-label text-white">Title (optional):</label>
                            <input type="text" class="form-control bg-dark text-white border-secondary" 
                                   id="reply-title" placeholder="Reply title...">
                        </div>
                        
                        <div class="mb-3">
                            <label for="reply-description" class="form-label text-white">Description (optional):</label>
                            <textarea class="form-control bg-dark text-white border-secondary" 
                                      id="reply-description" rows="2" placeholder="Reply description..."></textarea>
                        </div>
                    </div>
                </div>
                <div class="modal-footer border-secondary">
                    <button type="button" class="btn btn-outline-secondary" data-bs-dismiss="modal">
                        <i class="bi bi-x-lg"></i> Cancel
                    </button>
                    <button type="button" class="btn btn-primary" id="reply-publish-btn" disabled>
                        <i class="bi bi-send"></i> Publish Reply
                    </button>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Global variables (avoid redeclaration conflicts with common.js)
        // userPubkey, userPrivateKey, nostrRelay, and isNostrConnected are declared in common.js
        // Use local variables with different names and sync with window/common.js scope
        let localUserPubkey = null;
        let localUserPrivateKey = null;
        let nostrPool = null;
        let localIsNostrConnected = false;
        let localNostrRelay = null;
        
        // Sync function to get values from common.js or window scope
        function syncFromCommonJS() {
            try {
                if (typeof userPubkey !== 'undefined') {
                    localUserPubkey = userPubkey;
                } else if (typeof window !== 'undefined' && window.userPubkey) {
                    localUserPubkey = window.userPubkey;
                }
            } catch (e) {
                if (typeof window !== 'undefined' && window.userPubkey) {
                    localUserPubkey = window.userPubkey;
                }
            }
            
            try {
                if (typeof userPrivateKey !== 'undefined') {
                    localUserPrivateKey = userPrivateKey;
                } else if (typeof window !== 'undefined' && window.userPrivateKey) {
                    localUserPrivateKey = window.userPrivateKey;
                }
            } catch (e) {
                if (typeof window !== 'undefined' && window.userPrivateKey) {
                    localUserPrivateKey = window.userPrivateKey;
                }
            }
            
            try {
                if (typeof isNostrConnected !== 'undefined') {
                    localIsNostrConnected = isNostrConnected;
                } else if (typeof window !== 'undefined' && window.isNostrConnected !== undefined) {
                    localIsNostrConnected = window.isNostrConnected;
                }
            } catch (e) {
                if (typeof window !== 'undefined' && window.isNostrConnected !== undefined) {
                    localIsNostrConnected = window.isNostrConnected;
                }
            }
            
            try {
                if (typeof nostrRelay !== 'undefined') {
                    localNostrRelay = nostrRelay;
                } else if (typeof window !== 'undefined' && window.nostrRelay) {
                    localNostrRelay = window.nostrRelay;
                }
            } catch (e) {
                if (typeof window !== 'undefined' && window.nostrRelay) {
                    localNostrRelay = window.nostrRelay;
                }
            }
        }
        
        // Sync to common.js/window scope when values change
        function syncToCommonJS() {
            if (typeof window !== 'undefined') {
                window.userPubkey = localUserPubkey;
                window.userPrivateKey = localUserPrivateKey;
                window.isNostrConnected = localIsNostrConnected;
                window.nostrRelay = localNostrRelay;
            }
            try {
                if (typeof userPubkey !== 'undefined') userPubkey = localUserPubkey;
                if (typeof userPrivateKey !== 'undefined') userPrivateKey = localUserPrivateKey;
                if (typeof isNostrConnected !== 'undefined') isNostrConnected = localIsNostrConnected;
                if (typeof nostrRelay !== 'undefined') nostrRelay = localNostrRelay;
            } catch (e) {
                // Variables not accessible, only sync to window
            }
        }
        
        // Initial sync (with delays to ensure common.js is loaded)
        syncFromCommonJS();
        setTimeout(syncFromCommonJS, 100);
        setTimeout(syncFromCommonJS, 500);
        setTimeout(syncFromCommonJS, 1000);
        
        // Note: The code below uses localUserPubkey, localUserPrivateKey, localIsNostrConnected, localNostrRelay
        // These are synced with window scope and common.js variables automatically
        // We'll replace references throughout the code to use these local variables
        // For now, create helper functions to access them easily
        function getUserPubkey() { syncFromCommonJS(); return localUserPubkey; }
        function setUserPubkey(v) { localUserPubkey = v; syncToCommonJS(); }
        function getUserPrivateKey() { syncFromCommonJS(); return localUserPrivateKey; }
        function setUserPrivateKey(v) { localUserPrivateKey = v; syncToCommonJS(); }
        function getIsNostrConnected() { syncFromCommonJS(); return localIsNostrConnected; }
        function setIsNostrConnected(v) { localIsNostrConnected = v; syncToCommonJS(); }
        function getNostrRelay() { syncFromCommonJS(); return localNostrRelay; }
        function setNostrRelay(v) { localNostrRelay = v; syncToCommonJS(); }
        
        // Default relays (use different name to avoid conflict with common.js)
        const VOCALS_READ_DEFAULT_RELAYS = ['wss://relay.copylaradio.com', 'wss://relay.damus.io', 'wss://nos.lol'];
        
        // Voice messages cache
        let voiceMessagesCache = [];
        let allProcessedMessages = []; // All messages for filtering
        let currentViewMode = 'chronological'; // chronological, by-author, threads, personal
        let currentPage = 1;
        const messagesPerPage = 20;
        let waveformP5Enabled = true; // p5.js visualization enabled by default
        
        // View user profile (make available globally)
        window.viewProfile = async function viewProfile() {
            if (!localUserPubkey) {
                alert('Please connect first');
                return;
            }
            
            console.log('[PROFILE] Opening profile viewer for:', localUserPubkey);
            const ipfsGateway = '{{ myIPFS }}';
            const profileUrl = `${ipfsGateway}/ipns/copylaradio.com/nostr_profile_viewer.html?hex=${localUserPubkey}`;
            window.open(profileUrl, '_blank');
        }
        
        // Connect to NOSTR (make available globally)
        window.handleNostrConnect = async function handleNostrConnect() {
            try {
                const connectBtn = document.getElementById('connect-btn');
                const profileBtn = document.getElementById('profile-btn');
                connectBtn.disabled = true;
                connectBtn.innerHTML = '<span class="spinner-border spinner-border-sm me-1"></span> <span class="d-none d-md-inline">Connecting...</span>';
                
                // Use direct extension access (avoid common.js connectNostr which may show French MULTIPASS message)
                // Check if window.nostr is available (with better error message)
                if (typeof window.nostr === 'undefined' || !window.nostr) {
                    // Provide helpful error message with MULTIPASS option
                    throw new Error(
                        'NOSTR extension not detected.\n\n' +
                        'Please ensure your NOSTR extension (Alby, nos2x, Flamingo, Nostr Connect, etc.) is installed and enabled.\n\n' +
                        'üí° Alternative: Use /scan and scan your MULTIPASS SSSS QR code with PASS code "8888" to automatically enable encryption.'
                    );
                }
                
                // Get public key directly from extension
                localUserPubkey = await window.nostr.getPublicKey();
                if (!localUserPubkey) {
                    throw new Error('No public key returned from NOSTR extension');
                }
                
                // Sync with window scope and common.js
                syncToCommonJS();
                
                console.log('‚úÖ Connected to NOSTR, pubkey:', localUserPubkey.substring(0, 8) + '...');
                
                // Initialize NOSTR pool
                if (typeof NostrTools !== 'undefined' && NostrTools.SimplePool) {
                    nostrPool = new NostrTools.SimplePool();
                } else {
                    throw new Error('NostrTools.SimplePool not available');
                }
                
                localIsNostrConnected = true;
                
                // Sync with window scope and common.js
                syncToCommonJS();
                
                // Update UI
                connectBtn.innerHTML = '<i class="bi bi-check-circle"></i> <span class="d-none d-md-inline">Connected</span>';
                connectBtn.disabled = true;
                connectBtn.classList.remove('btn-primary');
                connectBtn.classList.add('btn-secondary');
                
                // Show profile button
                if (profileBtn) {
                    profileBtn.classList.remove('d-none');
                }
                
                const statusEl = document.getElementById('connection-status');
                if (statusEl) {
                    statusEl.textContent = `Connected: ${localUserPubkey.substring(0, 8)}...`;
                    statusEl.classList.remove('d-none');
                }
                
                // Load voice messages
                await loadVoiceMessages();
                
            } catch (error) {
                console.error('‚ùå Connection error:', error);
                const connectBtn = document.getElementById('connect-btn');
                connectBtn.disabled = false;
                connectBtn.innerHTML = '<i class="bi bi-plug"></i> <span class="d-none d-md-inline">Retry</span>';
                
                // Enhanced error message with diagnostic
                let errorMessage = error.message;
                if (errorMessage.includes('NOSTR extension not detected') || errorMessage.includes('extension not available')) {
                    // Check if extension might be loading
                    const nostrExists = typeof window.nostr !== 'undefined';
                    const nostrMethods = nostrExists ? Object.keys(window.nostr || {}).join(', ') : 'none';
                    
                    errorMessage = 'NOSTR extension not detected.\n\n';
                    errorMessage += 'Please ensure your NOSTR extension (Alby, nos2x, Flamingo, Nostr Connect, etc.) is:\n';
                    errorMessage += '1. Installed in your browser\n';
                    errorMessage += '2. Enabled/activated\n';
                    errorMessage += '3. Has permissions for this website\n\n';
                    
                    if (nostrExists) {
                        errorMessage += `‚ö†Ô∏è window.nostr exists but getPublicKey is not available.\n`;
                        errorMessage += `Available methods: ${nostrMethods}\n\n`;
                        errorMessage += 'The extension may still be loading. Please wait a few seconds and try again.\n\n';
                    }
                    
                    errorMessage += 'üí° Alternative: Use /scan and scan your MULTIPASS SSSS QR code with PASS code "8888" to automatically enable encryption.';
                }
                
                alert(errorMessage);
                throw error; // Re-throw for auto-login handling
            }
        }
        
        // Load voice messages from NOSTR
        async function loadVoiceMessages() {
            if (!localUserPubkey || !nostrPool) {
                console.warn('‚ö†Ô∏è Not connected to NOSTR');
                return;
            }
            
            const container = document.getElementById('voice-messages-container');
            const refreshBtn = document.getElementById('refresh-btn');
            
            try {
                refreshBtn.disabled = true;
                refreshBtn.innerHTML = '<span class="spinner-border spinner-border-sm me-1"></span> Loading...';
                container.innerHTML = '<div class="text-center p-4"><div class="loading-spinner"></div><p class="mt-2">Loading voice messages...</p></div>';
                
                // Get filter values
                const filterType = document.getElementById('filter-type').value;
                const filterSince = document.getElementById('filter-since').value;
                
                // Calculate since timestamp
                let since = 0;
                const now = Math.floor(Date.now() / 1000);
                switch (filterSince) {
                    case '1h':
                        since = now - 3600;
                        break;
                    case '24h':
                        since = now - 86400;
                        break;
                    case '7d':
                        since = now - 604800;
                        break;
                    case '30d':
                        since = now - 2592000;
                        break;
                    case 'all':
                        since = 0;
                        break;
                }
                
                // Build filter - increase limit to 120
                const filter = {
                    kinds: [1222, 1244], // Voice message kinds
                    since: since,
                    limit: 120
                };
                
                // Adjust filter based on type
                if (filterType === 'sent') {
                    filter.authors = [localUserPubkey];
                } else if (filterType === 'received') {
                    // For received, we need to check p tags
                    // This is handled in post-processing
                }
                
                console.log('üì° Fetching voice messages with filter:', JSON.stringify(filter, null, 2));
                console.log('üì° Using relays:', VOCALS_READ_DEFAULT_RELAYS);
                console.log('üì° User pubkey:', localUserPubkey ? localUserPubkey.substring(0, 8) + '...' : 'not set');
                
                // Fetch events from relays
                const events = await nostrPool.list(VOCALS_READ_DEFAULT_RELAYS, [filter]);
                
                // Also fetch deletion events (kind 5) to filter out deleted messages
                const deletionFilter = {
                    kinds: [5], // NIP-09 deletion events
                    since: since,
                    limit: 200
                };
                if (filter.authors) {
                    deletionFilter.authors = filter.authors;
                }
                const deletionEvents = await nostrPool.list(VOCALS_READ_DEFAULT_RELAYS, [deletionFilter]);
                
                // Build set of deleted event IDs
                const deletedEventIds = new Set();
                deletionEvents.forEach(deletionEvent => {
                    // Extract event IDs from e tags
                    deletionEvent.tags.forEach(tag => {
                        if (tag[0] === 'e' && tag[1]) {
                            deletedEventIds.add(tag[1]);
                        }
                    });
                });
                
                // Filter out deleted events
                const nonDeletedEvents = events.filter(event => !deletedEventIds.has(event.id));
                
                console.log(`‚úÖ Fetched ${events.length} voice message events (${deletionEvents.length} deletion events, ${nonDeletedEvents.length} non-deleted)`);
                if (events.length > 0) {
                    console.log('üìã Sample event:', {
                        id: events[0].id?.substring(0, 16) + '...',
                        kind: events[0].kind,
                        pubkey: events[0].pubkey?.substring(0, 8) + '...',
                        created_at: new Date(events[0].created_at * 1000).toISOString(),
                        tags_count: events[0].tags?.length || 0
                    });
                } else {
                    console.warn('‚ö†Ô∏è No events found. This could mean:');
                    console.warn('  1. No messages published yet');
                    console.warn('  2. Messages published to different relay');
                    console.warn('  3. Time filter excluding messages');
                    console.warn('  4. Relay not synced yet (try refreshing)');
                }
                
                // Process events (only non-deleted ones)
                const processedMessages = await processVoiceMessageEvents(nonDeletedEvents, filterType);
                
                // Store all processed messages
                allProcessedMessages = processedMessages;
                
                // Update cache (flat list for decryption)
                voiceMessagesCache = processedMessages;
                
                // Update message count
                updateMessageCount(processedMessages.length);
                
                // Populate filter dropdowns
                populateAuthorFilter(processedMessages);
                populateLocationFilter(processedMessages);
                populateThreadParticipantFilter(processedMessages);
                
                // Apply current view mode
                applyCurrentViewMode();
                
            } catch (error) {
                console.error('‚ùå Error loading voice messages:', error);
                container.innerHTML = `<div class="error-message">Error loading voice messages: ${error.message}</div>`;
            } finally {
                refreshBtn.disabled = false;
                refreshBtn.innerHTML = '<i class="bi bi-arrow-clockwise"></i> Refresh';
            }
        }
        
        // Process voice message events
        async function processVoiceMessageEvents(events, filterType) {
            const processed = [];
            
            for (const event of events) {
                try {
                    // Check if encrypted
                    const isEncrypted = event.tags.some(tag => tag[0] === 'encrypted' && tag[1] === 'true');
                    const encryptionMethod = event.tags.find(tag => tag[0] === 'encryption')?.[1] || 'nip44';
                    
                    // Check expiration date (NIP-40: Expiration Timestamp)
                    // Relays supporting NIP-40 will delete the event after this timestamp
                    const expirationTag = event.tags.find(tag => tag[0] === 'expiration');
                    let expirationTimestamp = null;
                    let isExpired = false;
                    
                    if (expirationTag && expirationTag[1]) {
                        expirationTimestamp = parseInt(expirationTag[1]);
                        const now = Math.floor(Date.now() / 1000);
                        
                        if (expirationTimestamp < now) {
                            isExpired = true; // Message has expired (relay should have deleted it, but may still be visible)
                        }
                    }
                    
                    // Check if received (for filterType === 'received')
                    if (filterType === 'received') {
                        const recipientTags = event.tags.filter(tag => tag[0] === 'p');
                        const isRecipient = recipientTags.some(tag => {
                            // Convert npub to hex for comparison
                            try {
                                const hexPubkey = npubToHex(tag[1]);
                                return hexPubkey && hexPubkey.toLowerCase() === localUserPubkey.toLowerCase();
                            } catch (e) {
                                return false;
                            }
                        });
                        
                        if (!isRecipient && event.pubkey !== localUserPubkey) {
                            continue; // Skip if not a recipient and not sent by user
                        }
                    }
                    
                    // Check if public (for filterType === 'public')
                    if (filterType === 'public' && isEncrypted) {
                        continue; // Skip encrypted messages
                    }
                    
                    // Check if encrypted (for filterType === 'encrypted')
                    if (filterType === 'encrypted' && !isEncrypted) {
                        continue; // Skip public messages
                    }
                    
                    // Parse imeta tags for metadata
                    const imetaTags = event.tags.filter(tag => tag[0] === 'imeta');
                    let metadata = {};
                    imetaTags.forEach(tag => {
                        if (tag.length > 1) {
                            const imetaContent = tag.slice(1).join(' ');
                            // Parse imeta format: "url https://... duration 45 waveform 0 7 35 8 100... title ... description ..."
                            // Note: waveform has multiple space-separated values, so we need special handling
                            const parts = imetaContent.split(/\s+/);
                            let i = 0;
                            while (i < parts.length) {
                                const key = parts[i];
                                
                                // Special handling for waveform (multiple numeric values)
                                if (key === 'waveform') {
                                    // Collect all numeric values until next key word
                                    const waveformValues = [];
                                    i++; // Skip 'waveform'
                                    while (i < parts.length) {
                                        const nextPart = parts[i];
                                        // Check if next part is a key (not a number)
                                        if (nextPart === 'url' || nextPart === 'duration' || nextPart === 'title' || 
                                            nextPart === 'description' || nextPart === 'waveform' || 
                                            nextPart === 'dim' || nextPart === 'image' || nextPart === 'gifanim' ||
                                            nextPart === 'm' || nextPart === 'x' || nextPart === 'info') {
                                            break; // Found next key, stop collecting waveform values
                                        }
                                        // Try to parse as number
                                        const numValue = parseFloat(nextPart);
                                        if (!isNaN(numValue)) {
                                            waveformValues.push(nextPart); // Keep as string to preserve precision
                                        } else {
                                            // Not a number, might be next key
                                            break;
                                        }
                                        i++;
                                    }
                                    if (waveformValues.length > 0) {
                                        metadata.waveform = waveformValues.join(' ');
                                        console.log(`üìä Found waveform for event ${event.id.substring(0, 8)}...: ${waveformValues.length} points`);
                                    }
                                    continue; // Don't increment i, we're already at the next key
                                }
                                
                                // Special handling for description/title (multi-word values)
                                if (key === 'description' || key === 'title') {
                                    i++; // Skip key
                                    // Collect remaining parts until next key word
                                    const valueParts = [];
                                    while (i < parts.length) {
                                        const nextPart = parts[i];
                                        // Check if next part is a key
                                        if (nextPart === 'url' || nextPart === 'duration' || nextPart === 'title' || 
                                            nextPart === 'description' || nextPart === 'waveform' ||
                                            nextPart === 'dim' || nextPart === 'image' || nextPart === 'gifanim' ||
                                            nextPart === 'm' || nextPart === 'x' || nextPart === 'info') {
                                            break;
                                        }
                                        valueParts.push(nextPart);
                                        i++;
                                    }
                                    if (valueParts.length > 0) {
                                        metadata[key] = valueParts.join(' ');
                                    }
                                    continue; // Don't increment i, we're already at the next key
                                }
                                
                                // Standard key-value pairs (url, duration, etc.)
                                if (i + 1 < parts.length) {
                                    const value = parts[i + 1];
                                    // Check if value is actually a key (next key word)
                                    if (value === 'url' || value === 'duration' || value === 'title' || 
                                        value === 'description' || value === 'waveform' ||
                                        value === 'dim' || value === 'image' || value === 'gifanim' ||
                                        value === 'm' || value === 'x' || value === 'info') {
                                        // Value is actually a key, this key has no value
                                        i++;
                                        continue;
                                    }
                                    
                                    if (key === 'duration') {
                                        metadata.duration = parseFloat(value);
                                    } else if (key === 'url') {
                                        metadata.url = value;
                                    } else if (key === 'title') {
                                        metadata.title = value;
                                    } else if (key === 'description') {
                                        metadata.description = value;
                                    }
                                    i += 2; // Move to next key-value pair
                                } else {
                                    i++; // No value, just move to next
                                }
                            }
                        }
                    });
                    
                    // Also check for title and description in separate tags (if present)
                    const titleTag = event.tags.find(tag => tag[0] === 'title');
                    if (titleTag && titleTag[1]) {
                        metadata.title = titleTag[1];
                    }
                    const descriptionTag = event.tags.find(tag => tag[0] === 'description');
                    if (descriptionTag && descriptionTag[1]) {
                        metadata.description = descriptionTag[1];
                    }
                    
                    // Also check for url tag (if imeta doesn't have it)
                    const urlTag = event.tags.find(tag => tag[0] === 'url');
                    if (urlTag && urlTag[1] && !metadata.url) {
                        metadata.url = urlTag[1];
                    }
                    
                    // Convert relative IPFS URL to absolute URL with gateway
                    if (metadata.url && metadata.url.startsWith('/ipfs/')) {
                        // Get gateway from common.js (window.IPFS_GATEWAY) or use default
                        let ipfsGateway = 'https://ipfs.copylaradio.com'; // Default fallback
                        if (typeof window !== 'undefined' && window.IPFS_GATEWAY) {
                            ipfsGateway = window.IPFS_GATEWAY;
                        } else if (typeof window !== 'undefined' && window.gateway) {
                            // Fallback to window.gateway if IPFS_GATEWAY not set
                            ipfsGateway = window.gateway;
                        }
                        metadata.url = ipfsGateway + metadata.url;
                    }
                    
                    // Get sender profile
                    let senderProfile = null;
                    try {
                        const profileEvents = await nostrPool.list(VOCALS_READ_DEFAULT_RELAYS, [
                            { kinds: [0], authors: [event.pubkey], limit: 1 }
                        ]);
                        if (profileEvents.length > 0) {
                            senderProfile = JSON.parse(profileEvents[0].content);
                        }
                    } catch (e) {
                        console.warn('‚ö†Ô∏è Could not fetch sender profile:', e);
                    }
                    
                    // Detect if this is a reply (kind 1244) and extract thread info
                    const isReply = event.kind === 1244;
                    let rootEventId = null;
                    let parentEventId = null;
                    let replyToPubkey = null;
                    
                    if (isReply) {
                        // NIP-22: Extract e tags for root and parent
                        const eTags = event.tags.filter(tag => tag[0] === 'e');
                        // Find root (usually first e tag or marked with "root")
                        const rootTag = eTags.find(tag => tag.length > 3 && tag[3] === 'root') || 
                                       eTags.find(tag => tag.length === 2 || tag.length === 3);
                        if (rootTag) {
                            rootEventId = rootTag[1];
                        }
                        // Find parent (marked with "reply" or second e tag)
                        const parentTag = eTags.find(tag => tag.length > 3 && tag[3] === 'reply') ||
                                         (eTags.length > 1 ? eTags[1] : null);
                        if (parentTag) {
                            parentEventId = parentTag[1];
                        }
                        // Extract p tag for the original sender
                        const pTags = event.tags.filter(tag => tag[0] === 'p');
                        if (pTags.length > 0) {
                            replyToPubkey = pTags[0][1];
                        }
                    }
                    
                    // Normalize pubkeys for comparison (convert npub to hex if needed)
                    let normalizedEventPubkey = event.pubkey;
                    let normalizedUserPubkey = localUserPubkey;
                    
                    // Helper function to normalize pubkey to hex
                    function normalizePubkeyToHex(pubkey) {
                        if (!pubkey) return null;
                        // If already hex (64 chars), return as-is
                        if (pubkey.length === 64 && /^[0-9a-fA-F]{64}$/.test(pubkey)) {
                            return pubkey.toLowerCase();
                        }
                        // If npub, try to convert to hex
                        if (pubkey.startsWith('npub1')) {
                            try {
                                if (typeof NostrTools !== 'undefined' && NostrTools.nip19) {
                                    const decoded = NostrTools.nip19.decode(pubkey);
                                    if (decoded.type === 'npub' && decoded.data) {
                                        const data = decoded.data;
                                        if (data instanceof Uint8Array) {
                                            return Array.from(data)
                                                .map(b => b.toString(16).padStart(2, '0'))
                                                .join('')
                                                .toLowerCase();
                                        }
                                    }
                                }
                            } catch (e) {
                                console.warn('‚ö†Ô∏è Could not decode npub:', e);
                            }
                        }
                        return pubkey.toLowerCase();
                    }
                    
                    normalizedEventPubkey = normalizePubkeyToHex(event.pubkey);
                    normalizedUserPubkey = normalizePubkeyToHex(localUserPubkey);
                    const isOwnMessage = normalizedEventPubkey && normalizedUserPubkey && 
                                        normalizedEventPubkey === normalizedUserPubkey;
                    
                    // Log if waveform is found
                    if (metadata.waveform) {
                        console.log(`‚úÖ Message ${event.id.substring(0, 8)}... has waveform: ${metadata.waveform.split(/\s+/).length} points`);
                    } else {
                        // Check if imeta tags exist but no waveform
                        const hasImeta = event.tags.some(tag => tag[0] === 'imeta');
                        if (hasImeta) {
                            console.log(`‚ÑπÔ∏è Message ${event.id.substring(0, 8)}... has imeta but no waveform`);
                        }
                    }
                    
                    processed.push({
                        event: event,
                        id: event.id,
                        kind: event.kind,
                        pubkey: event.pubkey,
                        normalizedPubkey: normalizedEventPubkey, // For comparison
                        created_at: event.created_at,
                        content: event.content,
                        isEncrypted: isEncrypted,
                        encryptionMethod: encryptionMethod,
                        metadata: metadata,
                        senderProfile: senderProfile,
                        tags: event.tags,
                        expirationTimestamp: expirationTimestamp,
                        isExpired: isExpired,
                        isReply: isReply,
                        rootEventId: rootEventId,
                        parentEventId: parentEventId || rootEventId,
                        replyToPubkey: replyToPubkey,
                        isOwnMessage: isOwnMessage // Flag to show delete button
                    });
                    
                } catch (error) {
                    console.error('‚ùå Error processing event:', error);
                }
            }
            
            return processed;
        }
        
        // Organize messages into threads
        function organizeIntoThreads(messages) {
            const threads = new Map(); // rootEventId -> { root: message, replies: [] }
            const replyMap = new Map(); // replyId -> reply message
            
            // First pass: identify roots and replies
            for (const msg of messages) {
                if (msg.isReply) {
                    replyMap.set(msg.id, msg);
                } else {
                    // Root message (kind 1222)
                    threads.set(msg.id, {
                        root: msg,
                        replies: [],
                        allReplies: new Map() // For nested replies
                    });
                }
            }
            
            // Second pass: attach replies to threads
            for (const [replyId, reply] of replyMap) {
                const rootId = reply.rootEventId || reply.parentEventId;
                if (rootId && threads.has(rootId)) {
                    const thread = threads.get(rootId);
                    // Build reply tree
                    attachReplyToThread(reply, thread, replyMap);
                } else {
                    // Orphan reply - create a thread for it
                    threads.set(replyId, {
                        root: reply,
                        replies: [],
                        allReplies: new Map()
                    });
                }
            }
            
            // Convert to array and sort by root created_at (newest first)
            return Array.from(threads.values()).sort((a, b) => 
                b.root.created_at - a.root.created_at
            );
        }
        
        // Recursively attach replies to thread
        function attachReplyToThread(reply, thread, replyMap) {
            thread.allReplies.set(reply.id, reply);
            
            const parentId = reply.parentEventId;
            if (parentId === thread.root.id) {
                // Direct reply to root
                thread.replies.push(reply);
            } else if (thread.allReplies.has(parentId)) {
                // Nested reply - attach to parent reply
                const parentReply = thread.allReplies.get(parentId);
                if (!parentReply.replies) {
                    parentReply.replies = [];
                }
                parentReply.replies.push(reply);
            } else {
                // Fallback: attach to root
                thread.replies.push(reply);
            }
        }
        
        // Apply current view mode
        function applyCurrentViewMode() {
            let messagesToDisplay = [...allProcessedMessages];
            
            // Apply filters based on current view mode
            switch (currentViewMode) {
                case 'chronological':
                    messagesToDisplay = applyChronologicalFilter(messagesToDisplay);
                    break;
                case 'by-author':
                    messagesToDisplay = applyAuthorViewFilter(messagesToDisplay);
                    break;
                case 'threads':
                    messagesToDisplay = applyThreadViewFilter(messagesToDisplay);
                    break;
                case 'personal':
                    messagesToDisplay = applyPersonalViewFilter(messagesToDisplay);
                    break;
            }
            
            // Sort messages
            const sortOrder = document.getElementById('sort-order')?.value || 'newest';
            if (sortOrder === 'newest') {
                messagesToDisplay.sort((a, b) => b.created_at - a.created_at);
            } else {
                messagesToDisplay.sort((a, b) => a.created_at - b.created_at);
            }
            
            // Paginate
            const totalPages = Math.ceil(messagesToDisplay.length / messagesPerPage);
            const startIndex = (currentPage - 1) * messagesPerPage;
            const endIndex = startIndex + messagesPerPage;
            const paginatedMessages = messagesToDisplay.slice(startIndex, endIndex);
            
            // Update pagination UI
            updatePagination(totalPages, messagesToDisplay.length);
            
            // Organize into threads if needed
            if (currentViewMode === 'threads') {
                const threads = organizeIntoThreads(paginatedMessages);
                renderThreads(threads);
            } else {
                // Render as flat list
                renderMessagesList(paginatedMessages);
            }
        }
        
        // Apply chronological filter
        function applyChronologicalFilter(messages) {
            const filterType = document.getElementById('filter-type')?.value || 'all';
            return filterMessagesByType(messages, filterType);
        }
        
        // Apply author view filter
        function applyAuthorViewFilter(messages) {
            const authorFilter = document.getElementById('filter-author')?.value || 'all';
            const locationFilter = document.getElementById('filter-location')?.value || 'all';
            
            let filtered = messages;
            
            if (authorFilter !== 'all') {
                filtered = filtered.filter(msg => msg.pubkey === authorFilter);
            }
            
            if (locationFilter !== 'all') {
                // Filter by location if available in metadata
                filtered = filtered.filter(msg => {
                    const location = msg.metadata?.location || msg.senderProfile?.location;
                    return location && location.includes(locationFilter);
                });
            }
            
            return filtered;
        }
        
        // Apply thread view filter
        function applyThreadViewFilter(messages) {
            const threadType = document.getElementById('filter-thread-type')?.value || 'all';
            const participant = document.getElementById('filter-thread-participant')?.value || 'all';
            
            let filtered = messages;
            
            if (threadType === 'encrypted') {
                filtered = filtered.filter(msg => msg.isEncrypted);
            } else if (threadType === 'public') {
                filtered = filtered.filter(msg => !msg.isEncrypted);
            } else if (threadType === 'my-threads') {
                filtered = filtered.filter(msg => 
                    msg.pubkey === localUserPubkey || 
                    msg.tags.some(tag => tag[0] === 'p' && tag[1] === localUserPubkey)
                );
            }
            
            if (participant !== 'all') {
                filtered = filtered.filter(msg => 
                    msg.pubkey === participant || 
                    msg.tags.some(tag => tag[0] === 'p' && tag[1] === participant)
                );
            }
            
            return filtered;
        }
        
        // Apply personal view filter
        function applyPersonalViewFilter(messages) {
            const personalType = document.getElementById('filter-personal-type')?.value || 'self';
            
            if (personalType === 'self') {
                // Messages to myself (p tag with my pubkey)
                return messages.filter(msg => 
                    msg.pubkey === localUserPubkey && 
                    msg.tags.some(tag => tag[0] === 'p' && tag[1] === localUserPubkey)
                );
            } else if (personalType === 'drafts') {
                // Drafts - messages not yet published (would need local storage)
                return [];
            } else if (personalType === 'saved') {
                // Saved messages (would need local storage or tags)
                return messages.filter(msg => 
                    msg.tags.some(tag => tag[0] === 'saved' && tag[1] === 'true')
                );
            }
            
            return messages;
        }
        
        // Filter messages by type
        function filterMessagesByType(messages, filterType) {
            if (filterType === 'all') return messages;
            if (filterType === 'public') return messages.filter(msg => !msg.isEncrypted);
            if (filterType === 'encrypted') return messages.filter(msg => msg.isEncrypted);
            if (filterType === 'sent') return messages.filter(msg => msg.pubkey === localUserPubkey);
            if (filterType === 'received') {
                return messages.filter(msg => {
                    if (msg.pubkey === localUserPubkey) return false;
                    const recipientTags = msg.tags.filter(tag => tag[0] === 'p');
                    return recipientTags.some(tag => {
                        try {
                            const hexPubkey = npubToHex(tag[1]);
                            return hexPubkey && hexPubkey.toLowerCase() === localUserPubkey.toLowerCase();
                        } catch (e) {
                            return false;
                        }
                    });
                });
            }
            return messages;
        }
        
        // Populate author filter dropdown
        function populateAuthorFilter(messages) {
            const authorSelect = document.getElementById('filter-author');
            if (!authorSelect) return;
            
            const authors = new Map();
            messages.forEach(msg => {
                const pubkey = msg.pubkey;
                if (!authors.has(pubkey)) {
                    const name = msg.senderProfile?.name || msg.senderProfile?.display_name || pubkey.substring(0, 8) + '...';
                    authors.set(pubkey, name);
                }
            });
            
            // Clear existing options except "All Authors"
            authorSelect.innerHTML = '<option value="all">All Authors</option>';
            
            // Add authors sorted by name
            Array.from(authors.entries())
                .sort((a, b) => a[1].localeCompare(b[1]))
                .forEach(([pubkey, name]) => {
                    const option = document.createElement('option');
                    option.value = pubkey;
                    option.textContent = `${name} (${pubkey.substring(0, 8)}...)`;
                    authorSelect.appendChild(option);
                });
        }
        
        // Populate location filter dropdown
        function populateLocationFilter(messages) {
            const locationSelect = document.getElementById('filter-location');
            if (!locationSelect) return;
            
            const locations = new Set();
            messages.forEach(msg => {
                const location = msg.metadata?.location || msg.senderProfile?.location;
                if (location) {
                    locations.add(location);
                }
            });
            
            locationSelect.innerHTML = '<option value="all">All Locations</option>';
            Array.from(locations).sort().forEach(location => {
                const option = document.createElement('option');
                option.value = location;
                option.textContent = location;
                locationSelect.appendChild(option);
            });
        }
        
        // Populate thread participant filter
        function populateThreadParticipantFilter(messages) {
            const participantSelect = document.getElementById('filter-thread-participant');
            if (!participantSelect) return;
            
            const participants = new Map();
            messages.forEach(msg => {
                // Add message author
                if (!participants.has(msg.pubkey)) {
                    const name = msg.senderProfile?.name || msg.senderProfile?.display_name || msg.pubkey.substring(0, 8) + '...';
                    participants.set(msg.pubkey, name);
                }
                // Add p tag recipients
                msg.tags.filter(tag => tag[0] === 'p').forEach(tag => {
                    if (!participants.has(tag[1])) {
                        participants.set(tag[1], tag[1].substring(0, 8) + '...');
                    }
                });
            });
            
            participantSelect.innerHTML = '<option value="all">All Participants</option>';
            Array.from(participants.entries())
                .sort((a, b) => a[1].localeCompare(b[1]))
                .forEach(([pubkey, name]) => {
                    const option = document.createElement('option');
                    option.value = pubkey;
                    option.textContent = `${name} (${pubkey.substring(0, 8)}...)`;
                    participantSelect.appendChild(option);
                });
        }
        
        // Update message count
        function updateMessageCount(count) {
            const countEl = document.getElementById('message-count-text');
            if (countEl) {
                countEl.textContent = `${count} message${count !== 1 ? 's' : ''}`;
            }
        }
        
        // Toggle sidebar (mobile)
        function toggleSidebar() {
            const sidebar = document.getElementById('sidebar');
            const overlay = document.getElementById('sidebarOverlay');
            if (sidebar && overlay) {
                sidebar.classList.toggle('show');
                overlay.classList.toggle('show');
            }
        }
        
        // Make toggleSidebar available globally
        window.toggleSidebar = toggleSidebar;
        
        // Set view mode (list or detail)
        let currentViewModeType = 'detail'; // 'list' or 'detail'
        function setViewMode(mode) {
            currentViewModeType = mode;
            const container = document.getElementById('voice-messages-container');
            if (container) {
                container.classList.remove('list-view', 'detail-view');
                container.classList.add(mode + '-view');
            }
            
            // Update radio buttons
            const listRadio = document.getElementById('view-list');
            const detailRadio = document.getElementById('view-detail');
            const listRadioMobile = document.getElementById('view-list-mobile');
            const detailRadioMobile = document.getElementById('view-detail-mobile');
            
            if (mode === 'list') {
                if (listRadio) listRadio.checked = true;
                if (listRadioMobile) listRadioMobile.checked = true;
            } else {
                if (detailRadio) detailRadio.checked = true;
                if (detailRadioMobile) detailRadioMobile.checked = true;
            }
        }
        
        // Make setViewMode available globally
        window.setViewMode = setViewMode;
        
        // Update pagination
        function updatePagination(totalPages, totalMessages) {
            const showingCount = Math.min((currentPage - 1) * messagesPerPage + 1, totalMessages);
            const showingEnd = Math.min(currentPage * messagesPerPage, totalMessages);
            
            document.getElementById('showing-count').textContent = showingCount === showingEnd ? showingCount : `${showingCount}-${showingEnd}`;
            document.getElementById('total-count').textContent = totalMessages;
            
            const paginationEl = document.getElementById('pagination-controls');
            if (!paginationEl) return;
            
            paginationEl.innerHTML = '';
            
            if (totalPages <= 1) return;
            
            // Previous button
            const prevLi = document.createElement('li');
            prevLi.className = `page-item ${currentPage === 1 ? 'disabled' : ''}`;
            prevLi.innerHTML = `<a class="page-link" href="#" onclick="changePage(${currentPage - 1}); return false;">Previous</a>`;
            paginationEl.appendChild(prevLi);
            
            // Page numbers
            const startPage = Math.max(1, currentPage - 2);
            const endPage = Math.min(totalPages, currentPage + 2);
            
            if (startPage > 1) {
                const firstLi = document.createElement('li');
                firstLi.className = 'page-item';
                firstLi.innerHTML = `<a class="page-link" href="#" onclick="changePage(1); return false;">1</a>`;
                paginationEl.appendChild(firstLi);
                if (startPage > 2) {
                    const ellipsis = document.createElement('li');
                    ellipsis.className = 'page-item disabled';
                    ellipsis.innerHTML = '<span class="page-link">...</span>';
                    paginationEl.appendChild(ellipsis);
                }
            }
            
            for (let i = startPage; i <= endPage; i++) {
                const li = document.createElement('li');
                li.className = `page-item ${i === currentPage ? 'active' : ''}`;
                li.innerHTML = `<a class="page-link" href="#" onclick="changePage(${i}); return false;">${i}</a>`;
                paginationEl.appendChild(li);
            }
            
            if (endPage < totalPages) {
                if (endPage < totalPages - 1) {
                    const ellipsis = document.createElement('li');
                    ellipsis.className = 'page-item disabled';
                    ellipsis.innerHTML = '<span class="page-link">...</span>';
                    paginationEl.appendChild(ellipsis);
                }
                const lastLi = document.createElement('li');
                lastLi.className = 'page-item';
                lastLi.innerHTML = `<a class="page-link" href="#" onclick="changePage(${totalPages}); return false;">${totalPages}</a>`;
                paginationEl.appendChild(lastLi);
            }
            
            // Next button
            const nextLi = document.createElement('li');
            nextLi.className = `page-item ${currentPage === totalPages ? 'disabled' : ''}`;
            nextLi.innerHTML = `<a class="page-link" href="#" onclick="changePage(${currentPage + 1}); return false;">Next</a>`;
            paginationEl.appendChild(nextLi);
        }
        
        // Change page
        function changePage(page) {
            if (page < 1) return;
            currentPage = page;
            applyCurrentViewMode();
            window.scrollTo({ top: 0, behavior: 'smooth' });
        }
        
        // Make changePage available globally
        window.changePage = changePage;
        
        // Apply author filter
        function applyAuthorFilter() {
            currentViewMode = 'by-author';
            currentPage = 1;
            applyCurrentViewMode();
        }
        
        // Make applyAuthorFilter available globally
        window.applyAuthorFilter = applyAuthorFilter;
        
        // Apply thread filter
        function applyThreadFilter() {
            currentViewMode = 'threads';
            currentPage = 1;
            applyCurrentViewMode();
        }
        
        // Make applyThreadFilter available globally
        window.applyThreadFilter = applyThreadFilter;
        
        // Apply personal filter
        function applyPersonalFilter() {
            currentViewMode = 'personal';
            currentPage = 1;
            applyCurrentViewMode();
        }
        
        // Make applyPersonalFilter available globally
        window.applyPersonalFilter = applyPersonalFilter;
        
        // Render messages as flat list
        function renderMessagesList(messages) {
            const container = document.getElementById('voice-messages-container');
            
            if (messages.length === 0) {
                container.innerHTML = `
                    <div class="empty-state">
                        <div class="empty-state-icon">üé§</div>
                        <p>No voice messages found</p>
                    </div>
                `;
                return;
            }
            
            container.innerHTML = messages.map(msg => {
                return renderMessageCard(msg, 'message', false, 0);
            }).join('');
            
            // Attach event listeners
            attachThreadEventListeners();
            
            // Render waveforms
            renderWaveforms();
        }
        
        // Render threads
        function renderThreads(threads) {
            const container = document.getElementById('voice-messages-container');
            
            if (threads.length === 0) {
                container.innerHTML = `
                    <div class="empty-state">
                        <div class="empty-state-icon">üé§</div>
                        <p>No voice messages found</p>
                    </div>
                `;
                return;
            }
            
            container.innerHTML = threads.map(thread => {
                return renderThread(thread);
            }).join('');
            
            // Attach event listeners for reply buttons and expand/collapse
            attachThreadEventListeners();
            
            // Render waveforms with p5.js
            renderWaveforms();
        }
        
        // Render a single thread (root + replies)
        function renderThread(thread) {
            const root = thread.root;
            const replyCount = thread.allReplies.size;
            const hasReplies = replyCount > 0;
            
            return `
                <div class="thread-container">
                    ${renderMessageCard(root, 'root', hasReplies, replyCount)}
                    ${hasReplies ? `
                        <div class="replies-container" id="replies-${root.id}">
                            ${thread.replies.map(reply => renderReplyTree(reply, 0)).join('')}
                        </div>
                    ` : ''}
                </div>
            `;
        }
        
        // Render reply tree recursively
        function renderReplyTree(reply, depth) {
            const hasNestedReplies = reply.replies && reply.replies.length > 0;
            const nestedCount = hasNestedReplies ? reply.replies.length : 0;
            
            return `
                <div class="thread-reply ${depth > 0 ? 'thread-reply-nested' : ''}" style="margin-left: ${depth * 2}rem;" data-event-id="${reply.id}">
                    ${renderMessageCard(reply, 'reply', hasNestedReplies, nestedCount)}
                    ${hasNestedReplies ? `
                        <div class="replies-container" id="replies-${reply.id}">
                            ${reply.replies.map(nestedReply => renderReplyTree(nestedReply, depth + 1)).join('')}
                        </div>
                    ` : ''}
                </div>
            `;
        }
        
        // Render a single message card
        function renderMessageCard(msg, type, hasReplies, replyCount) {
            const date = new Date(msg.created_at * 1000);
            const dateStr = date.toLocaleString();
            const senderName = msg.senderProfile?.name || msg.senderProfile?.display_name || msg.pubkey.substring(0, 8) + '...';
            const senderPicture = msg.senderProfile?.picture || '';
            const isRoot = type === 'root';
            const cardClass = isRoot ? 'thread-root' : '';
            
            return `
                <div class="voice-message-card ${msg.isEncrypted ? 'encrypted' : ''} ${cardClass}" data-event-id="${msg.id}" data-kind="${msg.kind}">
                    <div class="voice-message-header">
                        <div class="voice-message-info">
                            <div class="voice-message-title">
                                <i class="bi bi-mic"></i> ${msg.metadata.title || 'Voice Message'}
                                ${msg.isEncrypted ? '<span class="badge bg-warning text-dark ms-2"><i class="bi bi-lock-fill"></i> Encrypted</span>' : ''}
                                ${msg.isExpired ? '<span class="badge bg-danger ms-2"><i class="bi bi-clock-history"></i> Expired</span>' : ''}
                                ${msg.expirationTimestamp && !msg.isExpired ? `<span class="badge bg-info ms-2"><i class="bi bi-hourglass-split"></i> Expires: ${new Date(msg.expirationTimestamp * 1000).toLocaleString()}</span>` : ''}
                            </div>
                            <div class="voice-message-meta">
                                <span><i class="bi bi-person"></i> ${senderName}</span>
                                <span><i class="bi bi-calendar3"></i> ${dateStr}</span>
                                ${msg.metadata.duration ? `<span><i class="bi bi-clock"></i> ${Math.round(msg.metadata.duration)}s</span>` : ''}
                                ${msg.isReply ? '<span class="text-secondary"><i class="bi bi-reply"></i> Reply</span>' : ''}
                            </div>
                        </div>
                        <div class="voice-message-actions">
                            ${msg.isEncrypted ? `
                                <button class="decrypt-button btn btn-warning btn-sm" onclick="decryptAndPlayMessage('${msg.id}', this)">
                                    <i class="bi bi-unlock"></i> <span class="d-none d-sm-inline">Decrypt</span>
                                </button>
                            ` : `
                                <button class="btn btn-primary btn-sm" onclick="playMessage('${msg.id}')">
                                    <i class="bi bi-play-fill"></i> <span class="d-none d-sm-inline">Play</span>
                                </button>
                            `}
                            <button class="reply-button btn btn-outline-secondary btn-sm" onclick="openReplyModal('${msg.id}')" title="Reply to this message">
                                <i class="bi bi-reply"></i> <span class="d-none d-sm-inline">Reply</span>
                            </button>
                            ${msg.isOwnMessage ? `
                                <button class="btn btn-danger btn-sm" onclick="deleteVoiceMessage('${msg.id}', ${msg.kind}, this)" title="Delete this message">
                                    <i class="bi bi-trash"></i> <span class="d-none d-sm-inline">Delete</span>
                                </button>
                            ` : ''}
                        </div>
                    </div>
                    ${msg.metadata.description ? `<p class="text-secondary small mb-2"><i class="bi bi-card-text"></i> ${msg.metadata.description}</p>` : ''}
                    ${hasReplies ? `
                        <div class="mt-2">
                            <span class="badge bg-primary" style="cursor: pointer;" onclick="toggleReplies('${msg.id}')" id="reply-toggle-${msg.id}">
                                <i class="bi bi-chat-dots"></i> ${replyCount} ${replyCount === 1 ? 'reply' : 'replies'}
                            </span>
                        </div>
                    ` : ''}
                    ${msg.isEncrypted ? `
                        <div id="decrypt-status-${msg.id}" class="d-none"></div>
                        <div id="audio-container-${msg.id}" class="d-none">
                            <div class="audio-player-container">
                                <audio id="audio-player-${msg.id}" class="audio-player" controls></audio>
                            </div>
                        </div>
                    ` : `
                        <div class="audio-player-container">
                            <audio id="audio-player-${msg.id}" class="audio-player" controls src="${msg.metadata.url || msg.content}"></audio>
                        </div>
                    `}
                    ${msg.metadata.waveform ? `
                        <div class="d-flex align-items-center gap-2 mb-2">
                            <div class="form-check form-switch mb-0">
                                <input class="form-check-input" type="checkbox" id="waveform-toggle-${msg.id}" checked onchange="toggleWaveformForMessage('${msg.id}', this.checked)">
                                <label class="form-check-label small text-white" for="waveform-toggle-${msg.id}" title="Toggle waveform visualization">
                                    <i class="bi bi-graph-up"></i> Waveform
                                </label>
                            </div>
                        </div>
                        <div class="waveform-container" id="waveform-${msg.id}" data-waveform="${msg.metadata.waveform}"></div>
                    ` : `
                        <div class="d-flex align-items-center gap-2 mb-2">
                            <button class="btn btn-outline-primary btn-sm" id="generate-waveform-btn-${msg.id}" onclick="generateWaveformFromAudio('${msg.id}', this)" title="Generate waveform visualization from audio">
                                <i class="bi bi-graph-up"></i> <span class="d-none d-sm-inline">Generate Waveform</span>
                            </button>
                        </div>
                        <div class="waveform-container d-none" id="waveform-${msg.id}"></div>
                    `}
                </div>
            `;
        }
        
        // Render voice messages (legacy - kept for compatibility)
        function renderVoiceMessages(messages) {
            const container = document.getElementById('voice-messages-container');
            
            if (messages.length === 0) {
                container.innerHTML = `
                    <div class="empty-state">
                        <div class="empty-state-icon">üé§</div>
                        <p>No voice messages found</p>
                    </div>
                `;
                return;
            }
            
            container.innerHTML = messages.map(msg => {
                const date = new Date(msg.created_at * 1000);
                const dateStr = date.toLocaleString();
                const senderName = msg.senderProfile?.name || msg.senderProfile?.display_name || msg.pubkey.substring(0, 8) + '...';
                const senderPicture = msg.senderProfile?.picture || '';
                
                return `
                    <div class="voice-message-card ${msg.isEncrypted ? 'encrypted' : ''}" data-event-id="${msg.id}">
                        <div class="voice-message-header">
                            <div class="voice-message-info">
                                <div class="voice-message-title">
                                    ${msg.metadata.title || 'Voice Message'}
                                    ${msg.isEncrypted ? '<span class="encryption-badge">üîê Encrypted</span>' : ''}
                                    ${msg.isExpired ? '<span class="encryption-badge" style="background: rgba(239, 68, 68, 0.2); border-color: #ef4444; color: #fca5a5;">‚è∞ Expired (NIP-40)</span>' : ''}
                                    ${msg.expirationTimestamp && !msg.isExpired ? `<span class="encryption-badge" style="background: rgba(59, 130, 246, 0.2); border-color: #3b82f6; color: #93c5fd;">‚è∞ Expires: ${new Date(msg.expirationTimestamp * 1000).toLocaleString()} (NIP-40)</span>` : ''}
                                </div>
                                <div class="voice-message-meta">
                                    <span>üë§ ${senderName}</span>
                                    <span>üìÖ ${dateStr}</span>
                                    ${msg.metadata.duration ? `<span>‚è±Ô∏è ${Math.round(msg.metadata.duration)}s</span>` : ''}
                                </div>
                            </div>
                            <div class="voice-message-actions">
                                ${msg.isEncrypted ? `
                                    <button class="decrypt-button" onclick="decryptAndPlayMessage('${msg.id}', this)">
                                        üîì Decrypt & Play
                                    </button>
                                ` : `
                                    <button class="btn btn-primary btn-sm" onclick="playMessage('${msg.id}')">
                                        ‚ñ∂Ô∏è Play
                                    </button>
                                `}
                                ${msg.isOwnMessage ? `
                                    <button class="btn btn-danger btn-sm" onclick="deleteVoiceMessage('${msg.id}', ${msg.kind}, this)" title="Delete this message">
                                        üóëÔ∏è Delete
                                    </button>
                                ` : ''}
                            </div>
                        </div>
                        ${msg.metadata.description ? `<p class="text-secondary small mb-2">${msg.metadata.description}</p>` : ''}
                        ${msg.isEncrypted ? `
                            <div id="decrypt-status-${msg.id}" class="d-none"></div>
                            <div id="audio-container-${msg.id}" class="d-none">
                                <div class="audio-player-container">
                                    <audio id="audio-player-${msg.id}" class="audio-player" controls></audio>
                                </div>
                            </div>
                        ` : `
                            <div class="audio-player-container">
                                <audio id="audio-player-${msg.id}" class="audio-player" controls src="${msg.metadata.url || msg.content}"></audio>
                            </div>
                        `}
                        ${msg.metadata.waveform ? `
                            <div class="d-flex align-items-center gap-2 mb-2">
                                <div class="form-check form-switch mb-0">
                                    <input class="form-check-input" type="checkbox" id="waveform-toggle-${msg.id}" checked onchange="toggleWaveformForMessage('${msg.id}', this.checked)">
                                    <label class="form-check-label small text-white" for="waveform-toggle-${msg.id}" title="Toggle waveform visualization">
                                        üìä Waveform
                                    </label>
                                </div>
                            </div>
                            <div class="waveform-container" id="waveform-${msg.id}" data-waveform="${msg.metadata.waveform}"></div>
                        ` : `
                            <div class="d-flex align-items-center gap-2 mb-2">
                                <button class="btn btn-outline-primary btn-sm" id="generate-waveform-btn-${msg.id}" onclick="generateWaveformFromAudio('${msg.id}', this)" title="Generate waveform visualization from audio">
                                    üìä Generate Waveform
                                </button>
                            </div>
                            <div class="waveform-container d-none" id="waveform-${msg.id}"></div>
                        `}
                    </div>
                `;
            }).join('');
            
            // Render waveforms with p5.js
            renderWaveforms();
        }
        
        // Toggle waveform p5.js visualization for a specific message
        function toggleWaveformForMessage(messageId, enabled) {
            console.log(`üîÑ Toggling waveform visualization for message ${messageId}:`, enabled ? 'ON' : 'OFF');
            
            const waveformId = `waveform-${messageId}`;
            const container = document.getElementById(waveformId);
            
            if (!container) {
                console.warn(`‚ö†Ô∏è Waveform container not found for message ${messageId}`);
                return;
            }
            
            // Clean up existing p5.js instance for this message
            if (window.waveformSketches && window.waveformSketches[waveformId]) {
                try {
                    if (typeof window.waveformSketches[waveformId].remove === 'function') {
                        window.waveformSketches[waveformId].remove();
                    }
                    delete window.waveformSketches[waveformId];
                } catch (e) {
                    console.warn('‚ö†Ô∏è Error removing p5 sketch:', e);
                }
            }
            
            // Clear container
            container.innerHTML = '';
            
            if (!enabled) {
                // Show text only
                const waveformData = container.getAttribute('data-waveform');
                if (waveformData) {
                    const waveformPoints = waveformData.split(/\s+/).filter(v => v.trim() !== '');
                    container.innerHTML = `<span class="text-secondary small">Waveform: ${waveformPoints.length} points (visualization disabled)</span>`;
                }
                return;
            }
            
            // Render waveform for this specific message
            renderWaveformForContainer(container, waveformId);
        }
        
        // Make toggleWaveformForMessage available globally
        window.toggleWaveformForMessage = toggleWaveformForMessage;
        
        // Render waveform for a specific container
        async function renderWaveformForContainer(container, waveformId) {
            const waveformData = container.getAttribute('data-waveform');
            if (!waveformData) return;
            
            // Parse waveform data (space-separated values)
            const waveformPoints = waveformData.split(/\s+/).map(v => parseFloat(v)).filter(v => !isNaN(v));
            
            if (waveformPoints.length === 0) {
                container.textContent = 'No waveform data';
                return;
            }
            
            // Try to use p5.js
            let canUseP5 = false;
            if (typeof p5 !== 'undefined') {
                canUseP5 = true;
            } else {
                // Try to load p5.js
                canUseP5 = await loadP5JS();
            }
            
            if (!canUseP5 || typeof p5 === 'undefined') {
                // Fallback to HTML5 canvas
                console.warn('‚ö†Ô∏è p5.js not available, using HTML5 canvas fallback');
                renderWaveformCanvas(container);
                return;
            }
            
            // Create p5 instance for this waveform
            const sketch = function(p) {
                p.setup = function() {
                    const canvas = p.createCanvas(container.offsetWidth, container.offsetHeight);
                    canvas.parent(container);
                    p.noLoop();
                };
                
                p.draw = function() {
                    p.background(0, 0, 0, 0); // Transparent background
                    
                    const width = p.width;
                    const height = p.height;
                    const centerY = height / 2;
                    
                    // Normalize waveform values to fit canvas
                    const maxValue = Math.max(...waveformPoints.map(Math.abs));
                    if (maxValue === 0) return;
                    
                    // Draw waveform
                    p.stroke(6, 95, 212); // Blue color (#065fd4)
                    p.strokeWeight(2);
                    p.noFill();
                    
                    p.beginShape();
                    for (let i = 0; i < waveformPoints.length; i++) {
                        const x = p.map(i, 0, waveformPoints.length - 1, 0, width);
                        const normalizedValue = waveformPoints[i] / maxValue;
                        const y = centerY - (normalizedValue * (height / 2 - 10)); // Leave 10px margin
                        p.vertex(x, y);
                    }
                    p.endShape();
                    
                    // Draw center line
                    p.stroke(63, 63, 63, 100); // Gray center line
                    p.strokeWeight(1);
                    p.line(0, centerY, width, centerY);
                };
                
                p.windowResized = function() {
                    p.resizeCanvas(container.offsetWidth, container.offsetHeight);
                    p.redraw();
                };
            };
            
            // Store p5 instance to avoid conflicts
            if (!window.waveformSketches) {
                window.waveformSketches = {};
            }
            
            // Remove existing sketch if any
            if (window.waveformSketches[waveformId]) {
                try {
                    window.waveformSketches[waveformId].remove();
                } catch (e) {
                    console.warn('Could not remove p5 sketch:', e);
                }
            }
            
            // Create new p5 instance
            try {
                window.waveformSketches[waveformId] = new p5(sketch, container);
            } catch (e) {
                console.error('Error creating p5 sketch:', e);
                // Fallback to canvas
                renderWaveformCanvas(container);
            }
        }
        
        // Render waveforms using p5.js (optional) or HTML5 canvas fallback
        // Now checks individual switches for each message
        async function renderWaveforms() {
            // Find all waveform containers
            const waveformContainers = document.querySelectorAll('.waveform-container[data-waveform]');
            
            if (waveformContainers.length === 0) return;
            
            // Try to use p5.js
            let canUseP5 = false;
            if (typeof p5 !== 'undefined') {
                canUseP5 = true;
            } else {
                // Try to load p5.js
                canUseP5 = await loadP5JS();
            }
            
            // Render each waveform based on its individual switch
            waveformContainers.forEach(container => {
                const waveformId = container.id;
                const messageId = waveformId.replace('waveform-', '');
                const toggle = document.getElementById(`waveform-toggle-${messageId}`);
                
                // Check if toggle exists and is checked
                const isEnabled = toggle ? toggle.checked : waveformP5Enabled;
                
                if (!isEnabled) {
                    // Show text only
                    const waveformData = container.getAttribute('data-waveform');
                    if (waveformData) {
                        const waveformPoints = waveformData.split(/\s+/).filter(v => v.trim() !== '');
                        container.innerHTML = `<span class="text-secondary small">Waveform: ${waveformPoints.length} points (visualization disabled)</span>`;
                    }
                    return;
                }
                
                // Render waveform for this container
                if (canUseP5 && typeof p5 !== 'undefined') {
                    renderWaveformForContainer(container, waveformId);
                } else {
                    // Fallback to HTML5 canvas
                    renderWaveformCanvas(container);
                }
            });
        }
        
        // Fallback: Render waveform using HTML5 canvas
        function renderWaveformCanvas(container) {
            const waveformData = container.getAttribute('data-waveform');
            if (!waveformData) return;
            
            // Parse waveform data
            const waveformPoints = waveformData.split(/\s+/).map(v => parseFloat(v)).filter(v => !isNaN(v));
            
            if (waveformPoints.length === 0) {
                container.innerHTML = '<span class="text-secondary small">No waveform data</span>';
                return;
            }
            
            // Clear container
            container.innerHTML = '';
            
            // Create canvas
            const canvas = document.createElement('canvas');
            canvas.width = container.offsetWidth || 800;
            canvas.height = container.offsetHeight || 80;
            canvas.style.width = '100%';
            canvas.style.height = '100%';
            container.appendChild(canvas);
            
            const ctx = canvas.getContext('2d');
            const width = canvas.width;
            const height = canvas.height;
            const centerY = height / 2;
            
            // Normalize waveform values
            const maxValue = Math.max(...waveformPoints.map(Math.abs));
            if (maxValue === 0) return;
            
            // Draw waveform
            ctx.strokeStyle = '#065fd4'; // Blue
            ctx.lineWidth = 2;
            ctx.beginPath();
            
            for (let i = 0; i < waveformPoints.length; i++) {
                const x = (i / (waveformPoints.length - 1)) * width;
                const normalizedValue = waveformPoints[i] / maxValue;
                const y = centerY - (normalizedValue * (height / 2 - 10));
                
                if (i === 0) {
                    ctx.moveTo(x, y);
                } else {
                    ctx.lineTo(x, y);
                }
            }
            
            ctx.stroke();
            
            // Draw center line
            ctx.strokeStyle = 'rgba(63, 63, 63, 0.4)';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(0, centerY);
            ctx.lineTo(width, centerY);
            ctx.stroke();
        }
        
        // Play public message
        function playMessage(messageId) {
            const audioPlayer = document.getElementById(`audio-player-${messageId}`);
            if (audioPlayer) {
                audioPlayer.play();
            }
        }
        
        // Generate waveform from audio (lazy loading - on demand)
        async function generateWaveformFromAudio(messageId, buttonElement) {
            const message = voiceMessagesCache.find(msg => msg.id === messageId);
            if (!message) {
                console.error('Message not found:', messageId);
                return;
            }
            
            const button = buttonElement || document.getElementById(`generate-waveform-btn-${messageId}`);
            const waveformContainer = document.getElementById(`waveform-${messageId}`);
            const audioPlayer = document.getElementById(`audio-player-${messageId}`);
            
            if (!audioPlayer || !waveformContainer) {
                console.error('Audio player or waveform container not found for message:', messageId);
                return;
            }
            
            try {
                // Update button state
                button.disabled = true;
                button.textContent = '‚è≥ Generating...';
                
                // Get audio source URL
                const audioUrl = audioPlayer.src || message.metadata?.url || message.content;
                if (!audioUrl) {
                    throw new Error('No audio URL found');
                }
                
                console.log(`üìä Generating waveform for message ${messageId.substring(0, 8)}... from audio:`, audioUrl);
                
                // Load audio file
                const response = await fetch(audioUrl);
                if (!response.ok) {
                    throw new Error(`Failed to load audio: ${response.statusText}`);
                }
                
                const arrayBuffer = await response.arrayBuffer();
                
                // Create AudioContext
                const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                const audioBuffer = await audioContext.decodeAudioData(arrayBuffer);
                
                // Get audio data
                const channelData = audioBuffer.getChannelData(0); // Use first channel
                const sampleRate = audioBuffer.sampleRate;
                const duration = audioBuffer.duration;
                const totalSamples = channelData.length;
                
                // Generate waveform points (max 100 points as per NIP-A0)
                const maxPoints = 100;
                const pointsPerSample = Math.max(1, Math.floor(totalSamples / maxPoints));
                const waveformPoints = [];
                
                // Sample the audio data
                for (let i = 0; i < totalSamples; i += pointsPerSample) {
                    // Get a chunk of samples
                    const chunk = channelData.slice(i, Math.min(i + pointsPerSample, totalSamples));
                    
                    // Calculate RMS (Root Mean Square) for this chunk
                    let sumSquares = 0;
                    for (let j = 0; j < chunk.length; j++) {
                        sumSquares += chunk[j] * chunk[j];
                    }
                    const rms = Math.sqrt(sumSquares / chunk.length);
                    
                    // Convert to 0-100 scale (as per NIP-A0 format)
                    const normalizedValue = Math.round(Math.abs(rms) * 100);
                    waveformPoints.push(normalizedValue);
                    
                    // Stop if we have enough points
                    if (waveformPoints.length >= maxPoints) {
                        break;
                    }
                }
                
                // Ensure we have at least some points
                if (waveformPoints.length === 0) {
                    throw new Error('Failed to generate waveform points');
                }
                
                // Convert to space-separated string (NIP-A0 format)
                const waveformString = waveformPoints.join(' ');
                
                console.log(`‚úÖ Generated waveform: ${waveformPoints.length} points for message ${messageId.substring(0, 8)}...`);
                
                // Update message metadata in cache
                if (!message.metadata) {
                    message.metadata = {};
                }
                message.metadata.waveform = waveformString;
                
                // Update waveform container
                waveformContainer.setAttribute('data-waveform', waveformString);
                waveformContainer.classList.remove('d-none');
                
                // Hide button and show toggle switch instead
                button.style.display = 'none';
                
                // Create toggle switch (similar to existing waveform messages)
                const buttonContainer = button.parentElement;
                buttonContainer.innerHTML = `
                    <div class="form-check form-switch mb-0">
                        <input class="form-check-input" type="checkbox" id="waveform-toggle-${messageId}" checked onchange="toggleWaveformForMessage('${messageId}', this.checked)">
                        <label class="form-check-label small text-white" for="waveform-toggle-${messageId}" title="Toggle waveform visualization">
                            üìä Waveform
                        </label>
                    </div>
                `;
                
                // Render the waveform
                await renderWaveformForContainer(waveformContainer, `waveform-${messageId}`);
                
                // Clean up AudioContext
                audioContext.close();
                
            } catch (error) {
                console.error('‚ùå Error generating waveform:', error);
                button.disabled = false;
                button.textContent = 'üìä Generate Waveform';
                button.classList.add('btn-danger');
                button.classList.remove('btn-outline-primary');
                button.textContent = '‚ùå Error - Retry';
                
                // Show error message
                if (waveformContainer) {
                    waveformContainer.classList.remove('d-none');
                    waveformContainer.innerHTML = `<span class="text-danger small">Error generating waveform: ${error.message}</span>`;
                }
            }
        }
        
        // Make generateWaveformFromAudio available globally
        window.generateWaveformFromAudio = generateWaveformFromAudio;
        
        // Decrypt and play encrypted message
        async function decryptAndPlayMessage(messageId, buttonElement) {
            const message = voiceMessagesCache.find(msg => msg.id === messageId);
            if (!message || !message.isEncrypted) {
                console.error('Message not found or not encrypted');
                return;
            }
            
            const decryptBtn = buttonElement || document.querySelector(`[data-event-id="${messageId}"] .decrypt-button`);
            const statusDiv = document.getElementById(`decrypt-status-${messageId}`);
            const audioContainer = document.getElementById(`audio-container-${messageId}`);
            
            try {
                decryptBtn.disabled = true;
                decryptBtn.textContent = 'üîì Decrypting...';
                statusDiv.classList.remove('d-none');
                statusDiv.innerHTML = '<div class="loading-spinner"></div> Decrypting message...';
                
                // Helper function to decrypt using NostrTools (preferred - more reliable)
                async function decryptWithNostrTools(method, senderPubkey, ciphertext) {
                    if (typeof NostrTools === 'undefined') {
                        throw new Error('NostrTools library not loaded');
                    }
                    
                    // Check if we have private key (required for NostrTools decryption)
                    let privkey = userPrivateKey || window.userPrivateKey;
                    if (!privkey) {
                        throw new Error('Private key not available for decryption');
                    }
                    
                    // Convert nsec to hex if needed
                    if (typeof privkey === 'string' && privkey.startsWith('nsec1')) {
                        if (typeof NostrTools.nip19 !== 'undefined' && NostrTools.nip19.decode) {
                            const decoded = NostrTools.nip19.decode(privkey);
                            if (decoded.type === 'nsec') {
                                // decoded.data is Uint8Array, convert to hex
                                privkey = Array.from(decoded.data)
                                    .map(b => b.toString(16).padStart(2, '0'))
                                    .join('');
                            }
                        } else {
                            throw new Error('Cannot decode nsec - NostrTools.nip19 not available');
                        }
                    }
                    
                    // Ensure privkey is hex string (not Uint8Array)
                    if (privkey instanceof Uint8Array) {
                        privkey = Array.from(privkey)
                            .map(b => b.toString(16).padStart(2, '0'))
                            .join('');
                    }
                    
                    // Convert sender npub to hex if needed
                    let senderHex = senderPubkey;
                    if (senderPubkey.startsWith('npub1')) {
                        if (typeof NostrTools.nip19 !== 'undefined' && NostrTools.nip19.decode) {
                            const decoded = NostrTools.nip19.decode(senderPubkey);
                            if (decoded.type === 'npub') {
                                // decoded.data is Uint8Array, convert to hex
                                senderHex = Array.from(decoded.data)
                                    .map(b => b.toString(16).padStart(2, '0'))
                                    .join('');
                            }
                        } else {
                            throw new Error('Cannot decode npub - NostrTools.nip19 not available');
                        }
                    }
                    
                    // Ensure senderHex is hex string (not Uint8Array)
                    if (senderHex instanceof Uint8Array) {
                        senderHex = Array.from(senderHex)
                            .map(b => b.toString(16).padStart(2, '0'))
                            .join('');
                    }
                    
                    if (method === 'nip44') {
                        // NIP-44: Get conversation key first, then decrypt
                        if (!NostrTools.nip44 || !NostrTools.nip44.v2) {
                            throw new Error('NostrTools.nip44.v2 not available');
                        }
                        const conversationKey = NostrTools.nip44.v2.getConversationKey(privkey, senderHex);
                        return NostrTools.nip44.decrypt(conversationKey, ciphertext);
                    } else if (method === 'nip04') {
                        // NIP-04: Direct decryption
                        if (!NostrTools.nip04) {
                            throw new Error('NostrTools.nip04 not available');
                        }
                        return await NostrTools.nip04.decrypt(privkey, senderHex, ciphertext);
                    } else {
                        throw new Error(`Unknown encryption method: ${method}`);
                    }
                }
                
                // Decrypt content - prefer NostrTools (more reliable) over extension
                let decryptedContent = null;
                let decryptionSuccess = false;
                
                // Strategy 1: Try NostrTools first (if we have private key)
                try {
                    const privkey = userPrivateKey || window.userPrivateKey;
                    if (privkey && typeof NostrTools !== 'undefined') {
                        decryptedContent = await decryptWithNostrTools(message.encryptionMethod, message.pubkey, message.content);
                        console.log(`‚úÖ Content decrypted with ${message.encryptionMethod.toUpperCase()} using NostrTools`);
                        decryptionSuccess = true;
                    }
                } catch (nostrToolsError) {
                    console.warn('‚ö†Ô∏è NostrTools decryption failed:', nostrToolsError.message);
                    // Fall through to try extension
                }
                
                // Strategy 2: Try extension if NostrTools failed or no private key
                if (!decryptionSuccess) {
                    if (typeof window.nostr === 'undefined' || !window.nostr) {
                        throw new Error('NOSTR extension not available and private key not available for NostrTools decryption');
                    }
                    
                    if (message.encryptionMethod === 'nip44' && window.nostr.nip44 && typeof window.nostr.nip44.decrypt === 'function') {
                        decryptedContent = await window.nostr.nip44.decrypt(message.pubkey, message.content);
                        console.log('‚úÖ Content decrypted with NIP-44 using extension');
                        decryptionSuccess = true;
                    } else if (message.encryptionMethod === 'nip04' && window.nostr.nip04 && typeof window.nostr.nip04.decrypt === 'function') {
                        decryptedContent = await window.nostr.nip04.decrypt(message.pubkey, message.content);
                        console.log('‚úÖ Content decrypted with NIP-04 using extension');
                        decryptionSuccess = true;
                    }
                }
                
                if (!decryptionSuccess) {
                    const privkey = userPrivateKey || window.userPrivateKey;
                    let errorMsg = `Decryption method ${message.encryptionMethod} is not available. `;
                    
                    if (!privkey && typeof NostrTools !== 'undefined') {
                        errorMsg += 'Private key not available for NostrTools decryption. ';
                    }
                    
                    errorMsg += 'Please ensure your NOSTR extension supports decryption, or provide your private key for NostrTools decryption.';
                    
                    throw new Error(errorMsg);
                }
                
                // Parse decrypted JSON
                const decryptedData = JSON.parse(decryptedContent);
                
                console.log('‚úÖ Decrypted voice message:', decryptedData);
                
                // Update message in cache with decrypted metadata
                const messageIndex = voiceMessagesCache.findIndex(msg => msg.id === messageId);
                if (messageIndex !== -1) {
                    voiceMessagesCache[messageIndex].decryptedMetadata = decryptedData;
                    if (decryptedData.title) {
                        voiceMessagesCache[messageIndex].metadata.title = decryptedData.title;
                    }
                    if (decryptedData.description) {
                        voiceMessagesCache[messageIndex].metadata.description = decryptedData.description;
                    }
                    if (decryptedData.duration) {
                        voiceMessagesCache[messageIndex].metadata.duration = decryptedData.duration;
                    }
                    if (decryptedData.waveform) {
                        voiceMessagesCache[messageIndex].metadata.waveform = decryptedData.waveform;
                        
                        // Update waveform container if it exists
                        const waveformContainer = document.getElementById(`waveform-${messageId}`);
                        if (waveformContainer) {
                            waveformContainer.setAttribute('data-waveform', decryptedData.waveform);
                            waveformContainer.classList.remove('d-none');
                            
                            // Hide generate button if it exists and show toggle switch
                            const generateBtn = document.getElementById(`generate-waveform-btn-${messageId}`);
                            if (generateBtn) {
                                generateBtn.style.display = 'none';
                                const buttonContainer = generateBtn.parentElement;
                                buttonContainer.innerHTML = `
                                    <div class="form-check form-switch mb-0">
                                        <input class="form-check-input" type="checkbox" id="waveform-toggle-${messageId}" checked onchange="toggleWaveformForMessage('${messageId}', this.checked)">
                                        <label class="form-check-label small text-white" for="waveform-toggle-${messageId}" title="Toggle waveform visualization">
                                            üìä Waveform
                                        </label>
                                    </div>
                                `;
                            }
                            
                            // Re-render waveform
                            setTimeout(() => {
                                renderWaveforms();
                            }, 100);
                        }
                    } else {
                        // No waveform in decrypted data - show generate button if audio is available
                        const waveformContainer = document.getElementById(`waveform-${messageId}`);
                        const generateBtn = document.getElementById(`generate-waveform-btn-${messageId}`);
                        if (!waveformContainer || !generateBtn) {
                            // Create waveform section if it doesn't exist
                            const audioContainer = document.getElementById(`audio-container-${messageId}`);
                            if (audioContainer && audioContainer.parentElement) {
                                const waveformSection = document.createElement('div');
                                waveformSection.className = 'd-flex align-items-center gap-2 mb-2';
                                waveformSection.innerHTML = `
                                    <button class="btn btn-outline-primary btn-sm" id="generate-waveform-btn-${messageId}" onclick="generateWaveformFromAudio('${messageId}', this)" title="Generate waveform visualization from audio">
                                        üìä Generate Waveform
                                    </button>
                                `;
                                const waveformDiv = document.createElement('div');
                                waveformDiv.className = 'waveform-container d-none';
                                waveformDiv.id = `waveform-${messageId}`;
                                
                                audioContainer.parentElement.insertBefore(waveformSection, audioContainer.nextSibling);
                                audioContainer.parentElement.insertBefore(waveformDiv, waveformSection.nextSibling);
                            }
                        } else {
                            // Show generate button if hidden
                            if (generateBtn) {
                                generateBtn.style.display = '';
                            }
                            if (waveformContainer) {
                                waveformContainer.classList.add('d-none');
                            }
                        }
                    }
                }
                
                // Show audio player with decrypted URL
                audioContainer.classList.remove('d-none');
                const audioPlayer = document.getElementById(`audio-player-${messageId}`);
                if (audioPlayer && decryptedData.url) {
                    audioPlayer.src = decryptedData.url;
                    audioPlayer.play();
                } else {
                    throw new Error('No audio URL found in decrypted data');
                }
                
                // Update status
                statusDiv.innerHTML = '<span class="text-success">‚úÖ Decrypted successfully</span>';
                decryptBtn.textContent = '‚úÖ Decrypted';
                
                // Update UI with decrypted metadata
                const cardEl = document.querySelector(`[data-event-id="${messageId}"]`);
                if (cardEl) {
                    // Update title
                    const titleEl = cardEl.querySelector('.voice-message-title');
                    if (titleEl && decryptedData.title) {
                        titleEl.innerHTML = `${decryptedData.title} <span class="encryption-badge">üîê Decrypted</span>`;
                    }
                    
                    // Update description if present
                    if (decryptedData.description) {
                        let descEl = cardEl.querySelector('.voice-message-description');
                        if (!descEl) {
                            descEl = document.createElement('p');
                            descEl.className = 'text-secondary small mb-2 voice-message-description';
                            const headerEl = cardEl.querySelector('.voice-message-header');
                            if (headerEl && headerEl.nextSibling) {
                                headerEl.parentNode.insertBefore(descEl, headerEl.nextSibling);
                            } else {
                                headerEl.parentNode.appendChild(descEl);
                            }
                        }
                        descEl.textContent = decryptedData.description;
                    }
                    
                    // Update duration if present
                    if (decryptedData.duration) {
                        const metaEl = cardEl.querySelector('.voice-message-meta');
                        if (metaEl) {
                            const durationSpan = metaEl.querySelector('span:contains("‚è±Ô∏è")');
                            if (!durationSpan || !metaEl.textContent.includes('‚è±Ô∏è')) {
                                const durationSpan = document.createElement('span');
                                durationSpan.innerHTML = `‚è±Ô∏è ${Math.round(decryptedData.duration)}s`;
                                metaEl.appendChild(durationSpan);
                            }
                        }
                    }
                }
                
            } catch (error) {
                console.error('‚ùå Decryption error:', error);
                statusDiv.innerHTML = `<div class="error-message">Decryption failed: ${error.message}</div>`;
                decryptBtn.disabled = false;
                decryptBtn.textContent = 'üîì Retry Decrypt';
            }
        }
        
        // Convert npub to hex (helper function)
        function npubToHex(npub) {
            try {
                if (typeof NostrTools !== 'undefined' && NostrTools.nip19) {
                    const decoded = NostrTools.nip19.decode(npub);
                    if (decoded.type === 'npub') {
                        // decoded.data is Uint8Array, convert to hex string
                        if (decoded.data instanceof Uint8Array) {
                            return Array.from(decoded.data)
                                .map(b => b.toString(16).padStart(2, '0'))
                                .join('');
                        } else if (typeof decoded.data === 'string') {
                            return decoded.data;
                        }
                    }
                }
                return null;
            } catch (e) {
                console.warn('‚ö†Ô∏è Error converting npub to hex:', e);
                return null;
            }
        }
        
        // Toggle replies visibility
        function toggleReplies(messageId) {
            const repliesContainer = document.getElementById(`replies-${messageId}`);
            const toggleBtn = document.getElementById(`reply-toggle-${messageId}`);
            
            if (repliesContainer) {
                const isCollapsed = repliesContainer.classList.contains('collapsed');
                if (isCollapsed) {
                    repliesContainer.classList.remove('collapsed');
                    if (toggleBtn) {
                        toggleBtn.innerHTML = toggleBtn.innerHTML.replace('‚ñ∂Ô∏è', '‚ñº');
                    }
                } else {
                    repliesContainer.classList.add('collapsed');
                    if (toggleBtn) {
                        toggleBtn.innerHTML = toggleBtn.innerHTML.replace('‚ñº', '‚ñ∂Ô∏è');
                    }
                }
            }
        }
        
        // Make toggleReplies available globally
        window.toggleReplies = toggleReplies;
        
        // Reply recording variables
        let replyMediaRecorder = null;
        let replyRecordedChunks = [];
        let replyCurrentStream = null;
        let replyTargetMessageId = null;
        let replyTargetMessage = null;
        let replyTimerInterval = null;
        
        // Open reply modal
        function openReplyModal(messageId) {
            if (!localUserPubkey || !localIsNostrConnected) {
                alert('Please connect to NOSTR first to reply.');
                return;
            }
            
            const message = voiceMessagesCache.find(msg => msg.id === messageId);
            if (!message) {
                console.error('Message not found:', messageId);
                return;
            }
            
            replyTargetMessageId = messageId;
            replyTargetMessage = message;
            
            // Show preview of message being replied to
            const previewDiv = document.getElementById('reply-to-preview');
            const senderName = message.senderProfile?.name || message.senderProfile?.display_name || message.pubkey.substring(0, 8) + '...';
            const date = new Date(message.created_at * 1000).toLocaleString();
            previewDiv.innerHTML = `
                <div class="d-flex align-items-start gap-2">
                    <div class="flex-grow-1">
                        <div class="fw-semibold text-white">${message.metadata.title || 'Voice Message'}</div>
                        <div class="text-secondary small">üë§ ${senderName} ‚Ä¢ üìÖ ${date}</div>
                        ${message.metadata.description ? `<div class="text-secondary small mt-1">${message.metadata.description}</div>` : ''}
                    </div>
                </div>
            `;
            
            // Reset modal state
            document.getElementById('reply-recording-status').classList.add('d-none');
            document.getElementById('reply-recording-controls').classList.add('d-none');
            document.getElementById('reply-preview-section').classList.add('d-none');
            document.getElementById('reply-publish-btn').disabled = true;
            document.getElementById('reply-title').value = '';
            document.getElementById('reply-description').value = '';
            document.getElementById('reply-audio-upload').value = '';
            
            // Show recording controls
            document.getElementById('reply-recording-controls').classList.remove('d-none');
            
            // Show modal
            const modal = new bootstrap.Modal(document.getElementById('reply-modal'));
            modal.show();
        }
        
        // Make openReplyModal available globally
        window.openReplyModal = openReplyModal;
        
        // Attach thread event listeners
        function attachThreadEventListeners() {
            // Reply recording button
            const replyStartBtn = document.getElementById('reply-start-recording');
            const replyStopBtn = document.getElementById('reply-stop-recording');
            const replyUploadInput = document.getElementById('reply-audio-upload');
            const replyPublishBtn = document.getElementById('reply-publish-btn');
            
            if (replyStartBtn) {
                replyStartBtn.addEventListener('click', startReplyRecording);
            }
            
            if (replyStopBtn) {
                replyStopBtn.addEventListener('click', stopReplyRecording);
            }
            
            if (replyUploadInput) {
                replyUploadInput.addEventListener('change', handleReplyAudioUpload);
            }
            
            if (replyPublishBtn) {
                replyPublishBtn.addEventListener('click', publishReply);
            }
        }
        
        // Start reply recording
        async function startReplyRecording() {
            try {
                const startBtn = document.getElementById('reply-start-recording');
                const stopBtn = document.getElementById('reply-stop-recording');
                const timerDisplay = document.getElementById('reply-timer');
                const statusDiv = document.getElementById('reply-recording-status');
                const statusText = document.getElementById('reply-status-text');
                
                // Stop any existing stream
                if (replyCurrentStream) {
                    replyCurrentStream.getTracks().forEach(track => track.stop());
                    replyCurrentStream = null;
                }
                
                statusDiv.classList.remove('d-none');
                statusText.textContent = 'Requesting microphone access...';
                
                // Request microphone access
                const stream = await navigator.mediaDevices.getUserMedia({ 
                    audio: {
                        echoCancellation: true,
                        noiseSuppression: true,
                        autoGainControl: true,
                        sampleRate: 44100
                    },
                    video: false
                });
                
                replyCurrentStream = stream;
                
                // Determine best audio MIME type
                let mimeType = 'audio/webm';
                const supportedTypes = [
                    'audio/webm;codecs=opus',
                    'audio/webm',
                    'audio/mp4',
                    'audio/ogg;codecs=opus',
                    'audio/ogg'
                ];
                
                for (const type of supportedTypes) {
                    if (MediaRecorder.isTypeSupported(type)) {
                        mimeType = type;
                        break;
                    }
                }
                
                replyMediaRecorder = new MediaRecorder(stream, { mimeType: mimeType });
                replyRecordedChunks = [];
                
                replyMediaRecorder.ondataavailable = (event) => {
                    if (event.data.size > 0) {
                        replyRecordedChunks.push(event.data);
                    }
                };
                
                replyMediaRecorder.onstop = () => {
                    const blob = new Blob(replyRecordedChunks, { type: mimeType });
                    showReplyPreview(blob);
                    if (replyCurrentStream) {
                        replyCurrentStream.getTracks().forEach(track => track.stop());
                        replyCurrentStream = null;
                    }
                };
                
                replyMediaRecorder.start();
                
                // Start timer (30 seconds max)
                let timer = 30;
                timerDisplay.textContent = timer;
                replyTimerInterval = setInterval(() => {
                    timer--;
                    timerDisplay.textContent = timer;
                    if (timer <= 0) {
                        stopReplyRecording();
                    }
                }, 1000);
                
                // Update UI
                startBtn.classList.add('d-none');
                stopBtn.classList.remove('d-none');
                statusDiv.classList.add('d-none');
                timerDisplay.classList.remove('d-none');
                
            } catch (error) {
                console.error('‚ùå Error starting reply recording:', error);
                alert(`Could not access microphone: ${error.message}`);
            }
        }
        
        // Stop reply recording
        function stopReplyRecording() {
            if (replyMediaRecorder && replyMediaRecorder.state === 'recording') {
                replyMediaRecorder.stop();
            }
            
            if (replyTimerInterval) {
                clearInterval(replyTimerInterval);
                replyTimerInterval = null;
            }
            
            const startBtn = document.getElementById('reply-start-recording');
            const stopBtn = document.getElementById('reply-stop-recording');
            const timerDisplay = document.getElementById('reply-timer');
            
            if (startBtn) startBtn.classList.remove('d-none');
            if (stopBtn) stopBtn.classList.add('d-none');
            if (timerDisplay) timerDisplay.classList.add('d-none');
        }
        
        // Handle reply audio upload
        function handleReplyAudioUpload(event) {
            const file = event.target.files[0];
            if (!file) return;
            
            // Validate file type
            const validTypes = ['audio/mpeg', 'audio/mp3', 'audio/wav', 'audio/ogg', 'audio/flac', 'audio/aac', 'audio/mp4', 'audio/x-m4a'];
            const validExtensions = ['.mp3', '.wav', '.ogg', '.flac', '.aac', '.m4a'];
            const fileExtension = '.' + file.name.split('.').pop().toLowerCase();
            
            if (!validTypes.includes(file.type) && !validExtensions.includes(fileExtension)) {
                alert('Invalid file type. Please upload an audio file.');
                return;
            }
            
            // Validate file size (max 500MB)
            const maxSize = 500 * 1024 * 1024;
            if (file.size > maxSize) {
                alert('File is too large. Maximum allowed size is 500MB.');
                return;
            }
            
            const audioBlob = new Blob([file], { type: file.type });
            showReplyPreview(audioBlob, file.name);
            
            // Reset file input
            event.target.value = '';
        }
        
        // Show reply preview
        function showReplyPreview(audioBlob, filename = null) {
            const previewSection = document.getElementById('reply-preview-section');
            const audioPreview = document.getElementById('reply-audio-preview');
            const publishBtn = document.getElementById('reply-publish-btn');
            
            const audioUrl = URL.createObjectURL(audioBlob);
            audioPreview.src = audioUrl;
            
            // Auto-fill title if filename provided
            if (filename) {
                const filenameWithoutExt = filename.replace(/\.[^/.]+$/, '');
                document.getElementById('reply-title').value = `Re: ${filenameWithoutExt}`;
            }
            
            previewSection.classList.remove('d-none');
            publishBtn.disabled = false;
            
            // Store blob for publishing
            audioPreview.dataset.blob = 'stored'; // Marker
            audioPreview.dataset.audioBlob = audioBlob; // Will be stored in closure
            window.replyAudioBlob = audioBlob; // Store globally for publish
        }
        
        // Delete voice message (NIP-09: kind 5)
        async function deleteVoiceMessage(eventId, eventKind, buttonElement) {
            if (!localUserPubkey) {
                alert('Please connect to NOSTR first to delete messages.');
                return;
            }
            
            // Confirm deletion
            if (!confirm('Are you sure you want to delete this voice message? This action cannot be undone.')) {
                return;
            }
            
            try {
                // Disable button
                if (buttonElement) {
                    buttonElement.disabled = true;
                    buttonElement.innerHTML = '<span class="spinner-border spinner-border-sm me-2"></span>Deleting...';
                }
                
                // Check if NOSTR extension is available
                if (typeof window.nostr === 'undefined' || !window.nostr) {
                    throw new Error('NOSTR extension not available. Please install a NOSTR extension.');
                }
                
                // Create deletion event (kind 5) according to NIP-09
                const deletionEvent = {
                    kind: 5,
                    tags: [
                        ['e', eventId], // Event ID to delete
                        ['k', String(eventKind)] // Kind of event being deleted (1222 or 1244)
                    ],
                    content: 'Voice message deleted by author',
                    created_at: Math.floor(Date.now() / 1000)
                };
                
                // Sign event with NOSTR extension
                console.log('üóëÔ∏è Signing deletion event for:', eventId);
                const signedEvent = await window.nostr.signEvent(deletionEvent);
                
                // Publish to relays
                console.log('üì° Publishing deletion event to relays...');
                const relays = VOCALS_READ_DEFAULT_RELAYS || ['wss://relay.copylaradio.com'];
                
                // Use SimplePool if available (from NostrTools)
                if (nostrPool && typeof nostrPool.publish === 'function') {
                    // SimplePool.publish returns a Set of relay URLs that successfully published
                    const publishedRelays = await nostrPool.publish(relays, signedEvent);
                    console.log(`‚úÖ Deletion event published via SimplePool to ${publishedRelays.size} relay(s)`);
                } else if (typeof NostrTools !== 'undefined' && NostrTools.SimplePool) {
                    // Create a temporary pool if not available
                    const tempPool = new NostrTools.SimplePool();
                    const publishedRelays = await tempPool.publish(relays, signedEvent);
                    console.log(`‚úÖ Deletion event published via temporary SimplePool to ${publishedRelays.size} relay(s)`);
                    tempPool.close(relays);
                } else {
                    // Fallback: publish manually to each relay
                    console.warn('‚ö†Ô∏è SimplePool not available, using manual WebSocket publishing');
                    const publishPromises = relays.map(async (relayUrl) => {
                        try {
                            const ws = new WebSocket(relayUrl);
                            await new Promise((resolve, reject) => {
                                const timeout = setTimeout(() => {
                                    ws.close();
                                    reject(new Error('Timeout'));
                                }, 5000);
                                
                                ws.onopen = () => {
                                    ws.send(JSON.stringify(['EVENT', signedEvent]));
                                    setTimeout(() => {
                                        clearTimeout(timeout);
                                        ws.close();
                                        resolve();
                                    }, 1000);
                                };
                                ws.onerror = (error) => {
                                    clearTimeout(timeout);
                                    reject(error);
                                };
                            });
                        } catch (e) {
                            console.warn(`‚ö†Ô∏è Failed to publish to ${relayUrl}:`, e);
                        }
                    });
                    await Promise.all(publishPromises);
                    console.log('‚úÖ Deletion event published manually');
                }
                
                // Show success message
                if (buttonElement) {
                    buttonElement.innerHTML = '‚úÖ Deleted';
                    buttonElement.classList.remove('btn-danger');
                    buttonElement.classList.add('btn-secondary');
                }
                
                // Hide the message card immediately
                const messageCard = buttonElement?.closest('.voice-message-card');
                if (messageCard) {
                    messageCard.style.opacity = '0.5';
                    messageCard.style.textDecoration = 'line-through';
                    setTimeout(() => {
                        messageCard.remove();
                        // Reload messages to update the list
                        loadVoiceMessages();
                    }, 1000);
                } else {
                    // Reload messages if card not found
                    setTimeout(() => {
                        loadVoiceMessages();
                    }, 1000);
                }
                
                console.log('‚úÖ Voice message deleted successfully');
                
            } catch (error) {
                console.error('‚ùå Error deleting voice message:', error);
                alert(`Failed to delete message: ${error.message}`);
                
                // Re-enable button
                if (buttonElement) {
                    buttonElement.disabled = false;
                    buttonElement.innerHTML = 'üóëÔ∏è Delete';
                }
            }
        }
        
        // Make deleteVoiceMessage available globally
        window.deleteVoiceMessage = deleteVoiceMessage;
        
        // Publish reply
        async function publishReply() {
            if (!replyTargetMessageId || !window.replyAudioBlob) {
                alert('No audio recorded or uploaded. Please record or upload an audio file first.');
                return;
            }
            
            const publishBtn = document.getElementById('reply-publish-btn');
            const title = document.getElementById('reply-title').value || '';
            const description = document.getElementById('reply-description').value || '';
            
            try {
                publishBtn.disabled = true;
                publishBtn.innerHTML = '<span class="spinner-border spinner-border-sm me-2"></span>Publishing...';
                
                // Step 0: Verify and ensure NIP-42 authentication (required for /api/fileupload)
                if (!localUserPubkey) {
                    throw new Error('Not connected to NOSTR. Please connect first.');
                }
                
                console.log('üîê Verifying NIP-42 authentication before upload...');
                let isAuthenticated = false;
                
                // Helper function to verify authentication
                const verifyAuth = async () => {
                    if (typeof verifyAuthenticationWithAPI === 'function') {
                        try {
                            const result = await verifyAuthenticationWithAPI(localUserPubkey);
                            return result === true || (result && result.auth_verified === true);
                        } catch (authError) {
                            console.warn('‚ö†Ô∏è NIP-42 verification failed:', authError);
                            return false;
                        }
                    } else if (typeof window !== 'undefined' && typeof window.verifyAuthenticationWithAPI === 'function') {
                        try {
                            const result = await window.verifyAuthenticationWithAPI(localUserPubkey);
                            return result === true || (result && result.auth_verified === true);
                        } catch (authError) {
                            console.warn('‚ö†Ô∏è NIP-42 verification failed:', authError);
                            return false;
                        }
                    }
                    return false;
                };
                
                // Helper function to send NIP-42 auth
                // IMPORTANT: Backend checks authentication on local relay (ws://127.0.0.1:7777)
                // So we must send the NIP-42 event to the local relay, not the public relay
                const sendAuth = async () => {
                    // Determine the local relay URL (backend always checks ws://127.0.0.1:7777)
                    // Use the same logic as common.js to determine relay
                    let relayUrl = 'ws://127.0.0.1:7777'; // Default local relay
                    
                    // Try to get relay from common.js calculation
                    if (typeof window !== 'undefined') {
                        const currentUrl = new URL(window.location.href);
                        const hostname = currentUrl.hostname;
                        const port = currentUrl.port;
                        
                        // If localhost or 127.0.0.1, use local relay
                        if (hostname === '127.0.0.1' || hostname === 'localhost' || port === '8080') {
                            relayUrl = 'ws://127.0.0.1:7777';
                        } else if (hostname.startsWith('ipfs.')) {
                            // For IPFS gateways, derive relay URL
                            const baseDomain = hostname.substring('ipfs.'.length);
                            relayUrl = `wss://relay.${baseDomain}`;
                        } else if (hostname.includes('copylaradio.com') || hostname.includes('u.')) {
                            // For u.copylaradio.com, backend still checks local relay
                            // But we should send to local relay for NIP-42 auth
                            relayUrl = 'ws://127.0.0.1:7777';
                        }
                    }
                    
                    console.log('üîê Sending NIP-42 authentication event to local relay:', relayUrl);
                    
                    if (typeof sendNIP42Auth === 'function') {
                        await sendNIP42Auth(relayUrl, true);
                        return true;
                    } else if (typeof window !== 'undefined' && typeof window.sendNIP42Auth === 'function') {
                        await window.sendNIP42Auth(relayUrl, true);
                        return true;
                    }
                    return false;
                };
                
                // First check
                isAuthenticated = await verifyAuth();
                console.log('üîê Initial NIP-42 authentication check:', isAuthenticated ? '‚úÖ Authenticated' : '‚ùå Not authenticated');
                
                // If not authenticated, try to authenticate automatically (up to 3 attempts)
                if (!isAuthenticated) {
                    console.log('üîê Attempting automatic NIP-42 authentication...');
                    const maxAttempts = 3;
                    let attempt = 0;
                    
                    while (!isAuthenticated && attempt < maxAttempts) {
                        attempt++;
                        console.log(`üîê Authentication attempt ${attempt}/${maxAttempts}...`);
                        
                        try {
                            // Send auth event
                            const authSent = await sendAuth();
                            if (!authSent) {
                                console.warn('‚ö†Ô∏è Could not send NIP-42 auth event - function not available');
                                break;
                            }
                            
                            // Wait for processing (increase wait time with each attempt)
                            const waitTime = 2000 + (attempt * 1000); // 2s, 3s, 4s
                            console.log(`‚è≥ Waiting ${waitTime}ms for authentication to be processed...`);
                            await new Promise(resolve => setTimeout(resolve, waitTime));
                            
                            // Verify again
                            isAuthenticated = await verifyAuth();
                            console.log(`üîê Authentication attempt ${attempt} result:`, isAuthenticated ? '‚úÖ Authenticated' : '‚ùå Still not authenticated');
                            
                        } catch (authError) {
                            console.warn(`‚ö†Ô∏è Authentication attempt ${attempt} failed:`, authError);
                            // Continue to next attempt
                        }
                    }
                }
                
                // Final check - if still not authenticated, try one more time with longer wait
                if (!isAuthenticated) {
                    console.log('üîê Final authentication attempt with extended wait...');
                    try {
                        await sendAuth();
                        await new Promise(resolve => setTimeout(resolve, 3000));
                        isAuthenticated = await verifyAuth();
                        console.log('üîê Final authentication result:', isAuthenticated ? '‚úÖ Authenticated' : '‚ùå Not authenticated');
                    } catch (authError) {
                        console.warn('‚ö†Ô∏è Final authentication attempt failed:', authError);
                    }
                }
                
                // Log final status
                if (isAuthenticated) {
                    console.log('‚úÖ NIP-42 authentication verified - proceeding with upload');
                } else {
                    console.warn('‚ö†Ô∏è NIP-42 authentication not verified - upload may fail, but attempting anyway');
                    // Don't block the user - let the backend handle the error and return a clear message
                }
                
                // Step 1: Upload audio to IPFS
                const audioFile = new File([window.replyAudioBlob], `reply_${Date.now()}.webm`, { 
                    type: window.replyAudioBlob.type || 'audio/webm' 
                });
                
                const uploadFormData = new FormData();
                uploadFormData.append('file', audioFile);
                uploadFormData.append('npub', localUserPubkey);
                
                console.log('üì§ Uploading reply audio to IPFS...');
                const uploadResponse = await fetch('/api/fileupload', {
                    method: 'POST',
                    body: uploadFormData
                });
                
                if (!uploadResponse.ok) {
                    const errorText = await uploadResponse.text().catch(() => '');
                    if (uploadResponse.status === 403) {
                        throw new Error('Upload forbidden: NIP-42 authentication required. Please authenticate first using "Auth for Upload" button.');
                    }
                    throw new Error(`Upload failed: ${uploadResponse.statusText}${errorText ? ' - ' + errorText : ''}`);
                }
                
                const uploadResult = await uploadResponse.json();
                
                if (!uploadResult.success || !uploadResult.new_cid) {
                    throw new Error(uploadResult.message || 'IPFS upload failed');
                }
                
                console.log('‚úÖ Reply audio uploaded to IPFS:', uploadResult.new_cid);
                
                // Step 2: Get user email for player field
                let playerValue = '';
                try {
                    if (typeof fetchUserEmailWithFallback === 'function') {
                        playerValue = await fetchUserEmailWithFallback(localUserPubkey);
                    } else if (typeof window !== 'undefined' && typeof window.fetchUserEmailWithFallback === 'function') {
                        playerValue = await window.fetchUserEmailWithFallback(localUserPubkey);
                    }
                    
                    if (!playerValue || !playerValue.includes('@')) {
                        playerValue = '';
                    }
                } catch (e) {
                    console.warn('‚ö†Ô∏è Could not fetch email, backend will resolve from directory');
                }
                
                // Step 3: Prepare form data for reply (kind 1244)
                const formData = new FormData();
                formData.append('player', playerValue);
                formData.append('ipfs_cid', uploadResult.new_cid);
                formData.append('title', title || 'Voice Reply');
                formData.append('description', description);
                formData.append('npub', localUserPubkey);
                formData.append('file_hash', uploadResult.fileHash || '');
                formData.append('duration', (uploadResult.duration || 0).toString());
                formData.append('mime_type', uploadResult.mimeType || 'audio/webm');
                
                // Reply-specific: kind 1244 and parent event reference
                formData.append('kind', '1244'); // Reply kind
                formData.append('reply_to_event_id', replyTargetMessageId);
                formData.append('reply_to_pubkey', replyTargetMessage.pubkey);
                
                if (uploadResult.info) {
                    formData.append('info_cid', uploadResult.info);
                }
                
                formData.append('publish_nostr', 'true');
                
                // Step 4: Publish reply
                console.log('üì° Publishing reply to NOSTR...');
                const response = await fetch('/vocals', {
                    method: 'POST',
                    body: formData
                });
                
                if (!response.ok) {
                    const errorText = await response.text().catch(() => '');
                    throw new Error(`Publication failed: ${response.statusText}${errorText ? ' - ' + errorText : ''}`);
                }
                
                // Success
                publishBtn.innerHTML = '‚úÖ Published!';
                publishBtn.classList.remove('btn-primary');
                publishBtn.classList.add('btn-success');
                
                // Close modal after short delay
                setTimeout(() => {
                    const modal = bootstrap.Modal.getInstance(document.getElementById('reply-modal'));
                    if (modal) {
                        modal.hide();
                    }
                    
                    // Reload messages to show new reply
                    loadVoiceMessages();
                }, 1500);
                
            } catch (error) {
                console.error('‚ùå Error publishing reply:', error);
                alert(`Failed to publish reply: ${error.message}`);
                publishBtn.disabled = false;
                publishBtn.innerHTML = 'üì° Publish Reply';
            }
        }
        
            // Handle tab changes
            document.addEventListener('DOMContentLoaded', function() {
                console.log('üöÄ Initializing voice messages reader...');
                
                // Close sidebar when clicking outside (mobile)
                const sidebarOverlay = document.getElementById('sidebarOverlay');
                if (sidebarOverlay) {
                    sidebarOverlay.addEventListener('click', function() {
                        toggleSidebar();
                    });
                }
                
                // Attach reply modal event listeners
                attachThreadEventListeners();
                
                // Handle view mode tab changes
                const viewModeTabs = document.querySelectorAll('#viewModeTabs button[data-bs-toggle="tab"]');
                viewModeTabs.forEach(tab => {
                    tab.addEventListener('shown.bs.tab', function(event) {
                        const targetId = event.target.getAttribute('data-bs-target');
                        if (targetId === '#chronological') {
                            currentViewMode = 'chronological';
                        } else if (targetId === '#by-author') {
                            currentViewMode = 'by-author';
                        } else if (targetId === '#threads') {
                            currentViewMode = 'threads';
                        } else if (targetId === '#personal') {
                            currentViewMode = 'personal';
                        }
                        currentPage = 1;
                        applyCurrentViewMode();
                    });
                });
                
                // Handle filter changes
                const filterInputs = ['filter-type', 'filter-since', 'sort-order'];
                filterInputs.forEach(id => {
                    const el = document.getElementById(id);
                    if (el) {
                        el.addEventListener('change', function() {
                            if (currentViewMode === 'chronological') {
                                currentPage = 1;
                                applyCurrentViewMode();
                            }
                        });
                    }
                });
                
                // Sync from common.js first to get latest connection state
                syncFromCommonJS();
                
                // Check if already connected (from parent window if in iframe, or from common.js in standalone)
                const isInIframe = window.self !== window.top;
                let shouldAutoLoad = false;
                
                if (isInIframe && window.parent && window.parent.userPubkey) {
                    // Iframe mode: use parent's connection
                    localUserPubkey = window.parent.userPubkey;
                    if (window.parent.nostrPool) {
                        nostrPool = window.parent.nostrPool;
                    } else if (typeof NostrTools !== 'undefined' && NostrTools.SimplePool) {
                        nostrPool = new NostrTools.SimplePool();
                    }
                    localIsNostrConnected = true;
                    syncToCommonJS();
                    shouldAutoLoad = true;
                } else if (localUserPubkey && localIsNostrConnected) {
                    // Standalone mode: already connected via common.js
                    console.log('‚úÖ Already connected via common.js, pubkey:', localUserPubkey.substring(0, 8) + '...');
                    // Initialize pool if not already done
                    if (!nostrPool && typeof NostrTools !== 'undefined' && NostrTools.SimplePool) {
                        nostrPool = new NostrTools.SimplePool();
                        console.log('‚úÖ Initialized NOSTR pool');
                    }
                    shouldAutoLoad = true;
                } else {
                    // Auto-login: Try to connect automatically if extension is available (silent mode)
                    // Strategy: Try direct extension access (with retry for extension loading delay)
                    function tryDirectExtensionConnection() {
                        let attempts = 0;
                        const maxAttempts = 20; // Reduced to 20 (10 seconds total) for faster UX
                        const checkInterval = 500; // Check every 500ms
                        const initialDelay = 1000; // Wait 1 second before first check (extensions need time to inject)
                        
                        const checkExtension = () => {
                            attempts++;
                            
                            // Multiple ways to check for NOSTR extension
                            const nostrAvailable = typeof window.nostr !== 'undefined' && window.nostr !== null;
                            const nostrGetPublicKey = nostrAvailable && typeof window.nostr.getPublicKey === 'function';
                            
                            if (nostrGetPublicKey) {
                                // Extension available - try to connect automatically (silently)
                                // Try to test if extension actually works (some extensions need user interaction)
                                try {
                                    const testPromise = window.nostr.getPublicKey();
                                    if (testPromise && typeof testPromise.then === 'function') {
                                        // It's async, try to connect silently
                                        handleNostrConnect().then(() => {
                                            // Connection successful - handleNostrConnect already loads messages
                                            const profileBtn = document.getElementById('profile-btn');
                                            if (profileBtn && localUserPubkey) {
                                                profileBtn.classList.remove('d-none');
                                            }
                                        }).catch(() => {
                                            // Silent failure - user can click Connect button if needed
                                        });
                                    } else {
                                        // Synchronous, might work
                                        handleNostrConnect().then(() => {
                                            const profileBtn = document.getElementById('profile-btn');
                                            if (profileBtn && localUserPubkey) {
                                                profileBtn.classList.remove('d-none');
                                            }
                                        }).catch(() => {
                                            // Silent failure
                                        });
                                    }
                                } catch (testError) {
                                    // Extension exists but might need user interaction - silent
                                }
                            } else if (attempts < maxAttempts) {
                                // Extension not ready yet, retry silently
                                setTimeout(checkExtension, checkInterval);
                            }
                            // If max attempts reached, just stop silently - user can click Connect button
                        };
                        
                        // Start checking after initial delay to let extensions initialize
                        setTimeout(checkExtension, initialDelay);
                    }
                    
                    // Try direct extension access first (silent mode - no logs unless successful)
                    tryDirectExtensionConnection();
                }
                
                if (shouldAutoLoad) {
                    const connectBtn = document.getElementById('connect-btn');
                    const profileBtn = document.getElementById('profile-btn');
                    if (connectBtn) {
                        connectBtn.innerHTML = '<i class="bi bi-check-circle"></i> <span class="d-none d-md-inline">Connected</span>';
                        connectBtn.disabled = true;
                        connectBtn.classList.remove('btn-primary');
                        connectBtn.classList.add('btn-secondary');
                    }
                    if (profileBtn && localUserPubkey) {
                        profileBtn.classList.remove('d-none');
                    }
                    
                    // Auto-load messages
                    loadVoiceMessages();
                }
                // If not connected, silent - user can click Connect button if needed
            });
    </script>
</body>
</html>

